<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>defer和async</title>
    <link href="/2021/02/25/async_defer/"/>
    <url>/2021/02/25/async_defer/</url>
    
    <content type="html"><![CDATA[<a id="more"></a><h5 id="1-defer"><a href="#1-defer" class="headerlink" title="1. defer"></a>1. defer</h5><p>　　立即下载，延迟执行。</p><p>　　HTML5 规范要求脚本按照他们出现的顺序执行，因此第一个延迟脚本会先于第二个延迟脚本执行，而这两个脚本会优先于<code> DOMContentLoaded</code> 事件触发前执行；</p><p>　　在现实当中，延迟脚本并不一定会按照顺序执行，也不一定在 DOMCotentLoaded 事件出发前执行，一次最好只包含一个延迟脚本；</p><p>　　使用范围： </p><p>　　　　只适用于外部脚本文件；HTML5 已经规定，因此支持HTML5的实现会忽略给嵌入脚本设置的defer属性</p><p>　　PS： 在XHTML文档中，要把defer属性设置为 defer=”defer”</p><h5 id="2-async"><a href="#2-async" class="headerlink" title="2. async"></a>2. async</h5><p>　　立即下载，异步执行，异步加载页面其他内容<br>　　乱序执行，不能保证执行顺序，所以要确保脚本文件不相互依赖；建议异步脚本不要在加载期间修改 DOM</p><p>　　异步脚本一定会在<code>load</code>事件之前执行，但可能会在 <code>DOMContentLoaded</code> 事件触发之前或者之后执行。</p><p>　　使用范围： </p><p>　　　　只适用于外部脚本文件；HTML5 已经规定，因此支持HTML5的实现会忽略给嵌入脚本设置的defer属性</p><p>　　PS： 在XHTML文档中，要把defer属性设置为 defer=”defer”</p><h5 id="dom文件加载的步骤为："><a href="#dom文件加载的步骤为：" class="headerlink" title="dom文件加载的步骤为："></a>dom文件加载的步骤为：</h5><ul><li>1,解析HTML结构。</li><li>2,DOM树构建完成。//DOMContentLoaded</li><li>3,加载外部脚本和样式表文件。</li><li>4,解析并执行脚本代码。</li><li>5,加载图片等外部文件。</li><li>6,页面加载完毕。//load</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>正则表达式</title>
    <link href="/2021/02/22/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8C%B9%E9%85%8D/"/>
    <url>/2021/02/22/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8C%B9%E9%85%8D/</url>
    
    <content type="html"><![CDATA[<p>正则表达式</p><a id="more"></a><p>正则表达式通常用的两个字符串方法：search()和replace()</p><ul><li><p>search():用于检索字符串中指定的子字符串，或检索与正则表达式相匹配的子字符串，并返回<code>子字符串的起始位置</code>。</p></li><li><p>replace():用于在字符串中用一些字符替换另一些字符，或替换一个正则表达式匹配的子串</p><p>replace(‘正则’，‘替换到的字符串’)</p></li></ul><h5 id="1、正则表达式修饰符"><a href="#1、正则表达式修饰符" class="headerlink" title="1、正则表达式修饰符"></a>1、正则表达式修饰符</h5><table><thead><tr><th>修饰符</th><th>描述</th></tr></thead><tbody><tr><td>i</td><td>执行对大小写不敏感的匹配</td></tr><tr><td>g</td><td>执行全局匹配（查找所有匹配而非在找到第一个匹配后停止）</td></tr><tr><td>m</td><td>执行多行匹配</td></tr></tbody></table><h5 id="2、正则表达式模式"><a href="#2、正则表达式模式" class="headerlink" title="2、正则表达式模式"></a>2、正则表达式模式</h5><p>1、方括号用于查找某个范围内的字符</p><table><thead><tr><th>表达式</th><th>描述</th></tr></thead><tbody><tr><td>[abc]</td><td>查找方括号之间的任何字符</td></tr><tr><td>[0-9]</td><td>查找任何从0-9的数字</td></tr><tr><td>(x|y)</td><td>查找任何以 | 分隔的选项</td></tr></tbody></table><p>2、元字符是拥有特殊含义的字符</p><table><thead><tr><th>元字符</th><th>描述</th></tr></thead><tbody><tr><td>\d</td><td>查找数字</td></tr><tr><td>\s</td><td>查看空白字符</td></tr><tr><td>\b</td><td>匹配单词边界</td></tr><tr><td>\uxxxx</td><td>查找以十六进制数xxxx规定的Unicode字符</td></tr></tbody></table><p>3、量词</p><table><thead><tr><th>量词</th><th>描述</th></tr></thead><tbody><tr><td>n+</td><td>匹配任何包含至少一个n的字符串</td></tr><tr><td>n*</td><td>匹配任何包含零个或多个n的字符串</td></tr><tr><td>n?</td><td>匹配任何包含零个或一个n的字符串</td></tr></tbody></table><h5 id="3、使用RegExp对象"><a href="#3、使用RegExp对象" class="headerlink" title="3、使用RegExp对象"></a>3、使用RegExp对象</h5><p>test()方法是一个正则表达式方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> patt = <span class="hljs-regexp">/e/</span>;  <span class="hljs-comment">//正则的规则</span><br>patt.test(<span class="hljs-string">&quot;这里是你输入的字符串&quot;</span>)<br><span class="hljs-comment">//合并写也行</span><br>/e/.test(<span class="hljs-string">&quot;这里是你输入的字符串&quot;</span>);<br></code></pre></td></tr></table></figure><h5 id="4、表单验证实例"><a href="#4、表单验证实例" class="headerlink" title="4、表单验证实例"></a>4、表单验证实例</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/*是否带有小数*/</span><br><span class="hljs-function"><span class="hljs-keyword">function</span>    <span class="hljs-title">isDecimal</span>(<span class="hljs-params">strValue </span>)  </span>&#123;  <br>   <span class="hljs-keyword">var</span>  objRegExp= <span class="hljs-regexp">/^\d+\.\d+$/</span>;<br>   <span class="hljs-keyword">return</span>  objRegExp.test(strValue);  <br>&#125;  <br><br><span class="hljs-comment">/*校验是否中文名称组成 */</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">ischina</span>(<span class="hljs-params">str</span>) </span>&#123;<br>    <span class="hljs-keyword">var</span> reg=<span class="hljs-regexp">/^[\u4E00-\u9FA5]&#123;2,4&#125;$/</span>;   <span class="hljs-comment">/*定义验证表达式*/</span><br>    <span class="hljs-keyword">return</span> reg.test(str);     <span class="hljs-comment">/*进行验证*/</span><br>&#125;<br><br><span class="hljs-comment">/*校验是否全由8位数字组成 */</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isStudentNo</span>(<span class="hljs-params">str</span>) </span>&#123;<br>    <span class="hljs-keyword">var</span> reg=<span class="hljs-regexp">/^[0-9]&#123;8&#125;$/</span>;   <span class="hljs-comment">/*定义验证表达式*/</span><br>    <span class="hljs-keyword">return</span> reg.test(str);     <span class="hljs-comment">/*进行验证*/</span><br>&#125;<br><br><span class="hljs-comment">/*校验电话码格式 */</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">isTelCode</span>(<span class="hljs-params">str</span>) </span>&#123;<br>    <span class="hljs-keyword">var</span> reg= <span class="hljs-regexp">/^((0\d&#123;2,3&#125;-\d&#123;7,8&#125;)|(1[3584]\d&#123;9&#125;))$/</span>;<br>    <span class="hljs-keyword">return</span> reg.test(str);<br>&#125;<br><br><span class="hljs-comment">/*校验邮件地址是否合法 */</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">IsEmail</span>(<span class="hljs-params">str</span>) </span>&#123;<br>    <span class="hljs-keyword">var</span> reg=<span class="hljs-regexp">/^\w+@[a-zA-Z0-9]&#123;2,10&#125;(?:\.[a-z]&#123;2,4&#125;)&#123;1,3&#125;$/</span>;<br>    <span class="hljs-keyword">return</span> reg.test(str);<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>通用</category>
      
    </categories>
    
    
    <tags>
      
      <tag>通用</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>字节跳动北京国际化</title>
    <link href="/2021/02/20/%E5%AD%97%E8%8A%82%E8%B7%B3%E5%8A%A8%E5%8C%97%E4%BA%AC%E5%9B%BD%E9%99%85%E4%BC%9A/"/>
    <url>/2021/02/20/%E5%AD%97%E8%8A%82%E8%B7%B3%E5%8A%A8%E5%8C%97%E4%BA%AC%E5%9B%BD%E9%99%85%E4%BC%9A/</url>
    
    <content type="html"><![CDATA[<h5 id="1、雨水算法"><a href="#1、雨水算法" class="headerlink" title="1、雨水算法"></a>1、雨水算法</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">rain</span>(<span class="hljs-params">arr</span>)</span>&#123;<br>    <span class="hljs-keyword">let</span> l_m = [arr[<span class="hljs-number">0</span>]];<br>    <span class="hljs-keyword">let</span> r_m = [arr[arr.length-<span class="hljs-number">1</span>]];<br>    <span class="hljs-keyword">let</span> res = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>;i &lt; arr.length-<span class="hljs-number">1</span>;i++)&#123;<br>        <span class="hljs-keyword">if</span>(l_m[l_m.length-<span class="hljs-number">1</span>] &lt; arr[i])&#123;<br>            l_m.push(arr[i])<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            l_m.push(l_m[l_m.length-<span class="hljs-number">1</span>])<br>        &#125;<br>        <span class="hljs-keyword">if</span>(r_m[<span class="hljs-number">0</span>] &lt; arr[arr.length-i-<span class="hljs-number">1</span>])&#123;<br>            r_m.unshift(arr[arr.length-i-<span class="hljs-number">1</span>])<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            r_m.unshift(r_m[<span class="hljs-number">0</span>]);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>;i &lt; arr.length-<span class="hljs-number">1</span>;i++)&#123;<br>        <span class="hljs-keyword">let</span> now = <span class="hljs-built_in">Math</span>.min(l_m[i],r_m[i])-arr[i]<br>        res += now&gt;<span class="hljs-number">0</span>?now:<span class="hljs-number">0</span>;<br>    &#125;<br>   <span class="hljs-keyword">return</span> res;<br>&#125;<br><span class="hljs-built_in">console</span>.log(rain([<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>]));<br></code></pre></td></tr></table></figure><h5 id="2、Vue-nextTick-的原理和用途"><a href="#2、Vue-nextTick-的原理和用途" class="headerlink" title="2、Vue.nextTick()的原理和用途"></a>2、Vue.nextTick()的原理和用途</h5><p>Vue实现响应式并不是数据发生变化之后DOM立刻变化，而是按一定的策略进行DOM的更新。</p><p>在Vue的文档中，说明Vue是异步执行的DOM更新的。</p><p>具体来说，异步执行的运行机制如下。</p><ol><li>所有同步任务都在主线程上执行，形成一个执行栈（execution context stack）</li><li>主线程之外，还存在一个”任务队列”（task queue)。只要异步任务有了运行结果，就在“任务队列”之中放置一个事件。</li><li>一旦“执行栈”中所有同步任务执行完毕，系统就会读取“任务队列”，看看里面有哪些事件。哪些对应的异步任务于是结束等待状态，进入执行栈，开始执行。</li><li>主线程不断重复上面的第三步。</li></ol><p>简单来说，Vue在修改数据后，视图不会立刻更新，而是等<code>同一事件循环</code>中的所有数据变化完成之后，再统一进行视图更新。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//改变数据</span><br>vm.message = <span class="hljs-string">&#x27;changed&#x27;</span><br><br><span class="hljs-comment">//想要立刻使用更新后的DOM。这样不行，因为设置message后DON还没更新</span><br><span class="hljs-built_in">console</span>.log(vm.$el.textContent) <span class="hljs-comment">//并不会得到&#x27;changed&#x27;</span><br><br>Vue.nextTick(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br><span class="hljs-built_in">console</span>.log(vm.$el.textContent) <span class="hljs-comment">//可以得到&#x27;changed&#x27;</span><br>&#125;)<br></code></pre></td></tr></table></figure><p>事件循环：</p><p>第一个tick，就是本次循环：首先会修改数据，这是同步任务。同一事件循环的所有的同步任务都在主线程上执行，形成一个执行栈，此时未涉及DOM。Vue开启一个异步队列，并缓冲在此事件循环中发生的所有数据改变。如果同一个watcher被多次触发，只会被推入到队列中一次。</p><p>第二个tick，就是下次更新循环：同步任务执行完毕，开始执行异步watcher队列的任务，更新DOM。Vue在内部尝试对异步队列使用原生的Promise.then和MessageChannel方法，如果执行环境不支持，会采用setTimeout(fn,0)代替。</p><p>第三个tick：也就是下次DOM更新循环结束之后，此时通过Vue.nextTick获取到改变后的DOM。通过setTImeout(fn,0)也可以同样获取到。</p><p><code>注意</code>：在created和mounted阶段，如果需要操作渲染后的视图，也要使用nextTick方法。</p><p> mounted 不会承诺所有的子组件也都一起被挂载。如果你希望等到整个视图都渲染完毕，可以用 vm.$nextTick 替换掉 mounted</p><h5 id="3、会引起回流和重绘的情况，并且如何优化"><a href="#3、会引起回流和重绘的情况，并且如何优化" class="headerlink" title="3、会引起回流和重绘的情况，并且如何优化"></a>3、会引起回流和重绘的情况，并且如何优化</h5><p>大多数浏览器都会通过队列化修改并批量执行来优化重排过程。</p><p>浏览器会把所有会引起回流、重绘的操作都放入一个队列，等过一定的时间或者操作达到了一定的阈值，浏览器就会flush队列，进行一个批处理。这样让多次的回流和重绘变成一次回流重绘。<br><strong>但是</strong>，当获取布局信息操作的时候，会<strong>强制</strong>浏览器<strong>提前flush队列</strong>，触发回流重绘返回信息，这种情况下，浏览器的优化就不起作用了。比如以下属性或方法：</p><ul><li>offsetTop、offsetLeft、offsetWidth、offsetHeight</li><li>scrollTop、scrollLeft、scrollWidth、scrollHeight</li><li>clientTop、clientLeft、clientWidth、clientHeight</li><li>getComputedStyle()</li><li>getBoundingClientRect</li></ul><p>那么，除了浏览器的优化，我们还有什么方法可以来减少回流和重绘达到性能优化？</p><p><strong>通过合并多次DOM样式的修改，来减少回流和重绘的发生次数。</strong></p><p>利用className修改元素的class</p><blockquote><p>const el = document.getElementById(‘test’);<br>el.className += ’ active’;</p></blockquote><p>利用cssText合并样式修改操作</p><blockquote><p>const el = document.getElementById(‘test’);<br>el.style.cssText += ‘border-left: 1px; border-right: 2px; padding: 5px;’;</p></blockquote><h5 id="4、如何实现一秒输出一个数字里的元素"><a href="#4、如何实现一秒输出一个数字里的元素" class="headerlink" title="4、如何实现一秒输出一个数字里的元素"></a>4、如何实现一秒输出一个数字里的元素</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">print</span>(<span class="hljs-params">arr</span>) </span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>;i &lt; arr.length;i++)&#123;<br>    (<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">i</span>) </span>&#123;<br>        <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">()=&gt;</span><span class="hljs-built_in">console</span>.log(arr[i]),<span class="hljs-number">2000</span>*i)<br>    &#125;)(i)&#125;<br>    <span class="hljs-comment">// for (let i=0; i&lt;arr.length; i++) &#123;</span><br>    <span class="hljs-comment">//     setTimeout(() =&gt; console.log(arr[i]), 1000*i)</span><br>    <span class="hljs-comment">// &#125;</span><br>&#125;<br><br><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>]<br>print(arr);<br></code></pre></td></tr></table></figure><h5 id="5、手写一个双向绑定"><a href="#5、手写一个双向绑定" class="headerlink" title="5、手写一个双向绑定"></a>5、手写一个双向绑定</h5><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">&quot;X-UA-Compatible&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;IE=edge&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Document<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">id</span> =<span class="hljs-string">&#x27;inpName&#x27;</span>&gt;</span><br>   姓名： <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">id</span> = <span class="hljs-string">&#x27;spanName&#x27;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br><span class="javascript">    <span class="hljs-keyword">let</span> obj = &#123;</span><br><span class="javascript">        name: <span class="hljs-string">&#x27;&#x27;</span></span><br>    &#125;<br><span class="javascript">    <span class="hljs-comment">// let newObj = JSON.parse(JSON.stringify(obj));</span></span><br><span class="javascript">    <span class="hljs-comment">// Object.defineProperty(obj,&#x27;name&#x27;,&#123;</span></span><br><span class="javascript">    <span class="hljs-comment">//     get()&#123;</span></span><br><span class="javascript">    <span class="hljs-comment">//         return newObj.name;</span></span><br><span class="javascript">    <span class="hljs-comment">//     &#125;,</span></span><br><span class="javascript">    <span class="hljs-comment">//     set(val)&#123;</span></span><br><span class="javascript">    <span class="hljs-comment">//         if(val === newObj.name)return;</span></span><br><span class="javascript">    <span class="hljs-comment">//         newObj.name = val;</span></span><br><span class="javascript">    <span class="hljs-comment">//         observer();</span></span><br><span class="javascript">    <span class="hljs-comment">//     &#125;</span></span><br><span class="javascript">    <span class="hljs-comment">// &#125;)</span></span><br><span class="javascript">    <span class="hljs-comment">//vue3.0的简易实现</span></span><br><span class="javascript">    obj = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Proxy</span>(obj,&#123;</span><br><span class="javascript">        <span class="hljs-function"><span class="hljs-title">get</span>(<span class="hljs-params">target,prop</span>)</span>&#123;</span><br><span class="javascript">            <span class="hljs-keyword">return</span> target[prop];</span><br>        &#125;,<br><span class="javascript">        <span class="hljs-function"><span class="hljs-title">set</span>(<span class="hljs-params">target,prop,value</span>)</span>&#123;</span><br>            target[prop] = value;<br>            observer();<br>        &#125;<br>    &#125;)<br><br><span class="javascript">    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">observer</span>(<span class="hljs-params"></span>)</span>&#123;</span><br>        spanName.innerHTML = obj.name;<br>        inpName.value = obj.name;<br>    &#125;<br><br><span class="javascript">    inpName.oninput = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>)</span>&#123;</span><br><span class="javascript">        obj.name = <span class="hljs-built_in">this</span>.value;</span><br>    &#125;<br><br><span class="javascript">    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">()=&gt;</span>&#123;</span><br><span class="javascript">        obj.name = <span class="hljs-string">&quot;数据影响视图&quot;</span></span><br>    &#125;,2000)<br><br><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><h5 id="6、Scheduler"><a href="#6、Scheduler" class="headerlink" title="6、Scheduler"></a>6、Scheduler</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Scheduler</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params"></span>)</span> &#123; <span class="hljs-built_in">this</span>.list = []; <span class="hljs-built_in">this</span>.count = <span class="hljs-number">0</span>; &#125;<br>    <span class="hljs-function"><span class="hljs-title">add</span>(<span class="hljs-params">promiseCreator</span>)</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-params">resolve</span> =&gt;</span> &#123;<br>            <span class="hljs-comment">// 加入任务队列       </span><br>            <span class="hljs-built_in">this</span>.list.push(<span class="hljs-function">() =&gt;</span> &#123;<br>                resolve(<span class="hljs-built_in">Promise</span>.resolve(promiseCreator()).then(<span class="hljs-function"><span class="hljs-params">s</span> =&gt;</span> &#123;<br>                    <span class="hljs-comment">// 当前任务结束后，执行下一个任务      </span><br>                    <span class="hljs-built_in">this</span>.count--;<br>                    <span class="hljs-built_in">this</span>.start();<br>                    <span class="hljs-keyword">return</span> s<br>                &#125;));<br>            &#125;);<br>            <span class="hljs-comment">// 执行当前任务   </span><br>            <span class="hljs-built_in">this</span>.start();<br>        &#125;)<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-title">start</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <span class="hljs-comment">// 最多两个同时进行的任务  </span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.count &lt; <span class="hljs-number">2</span>) &#123;<br>            <span class="hljs-built_in">this</span>.count++; <span class="hljs-built_in">this</span>.list[<span class="hljs-number">0</span>] &amp;&amp; <span class="hljs-built_in">this</span>.list[<span class="hljs-number">0</span>](); <span class="hljs-built_in">this</span>.list.shift();<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">const</span> timeout = <span class="hljs-function">(<span class="hljs-params">time</span>) =&gt;</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-params">resolve</span> =&gt;</span> &#123;<br>    <span class="hljs-built_in">setTimeout</span>(resolve, time)<br>&#125;)<br><span class="hljs-keyword">const</span> scheduler = <span class="hljs-keyword">new</span> Scheduler();<br><span class="hljs-keyword">const</span> addTask = <span class="hljs-function">(<span class="hljs-params">time, order</span>) =&gt;</span> &#123;<br>    scheduler.add(<span class="hljs-function">() =&gt;</span> timeout(time))<br>        .then(<span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">console</span>.log(time, <span class="hljs-string">&#x27;time, order&#x27;</span>, order))<br>&#125;<br>addTask(<span class="hljs-number">1000</span>, <span class="hljs-string">&#x27;1&#x27;</span>);<br>addTask(<span class="hljs-number">500</span>, <span class="hljs-string">&#x27;2&#x27;</span>);<br>addTask(<span class="hljs-number">300</span>, <span class="hljs-string">&#x27;3&#x27;</span>);<br>addTask(<span class="hljs-number">400</span>, <span class="hljs-string">&#x27;4&#x27;</span>);<br>           <span class="hljs-comment">// output: 2 3 1 4</span><br>           <span class="hljs-comment">// 一开始，1、2两个任务进入队列</span><br>            <span class="hljs-comment">// 500ms时，2完成，输出2，任务3进队 </span><br>            <span class="hljs-comment">// 800ms时，3完成，输出3，任务4进队 </span><br>            <span class="hljs-comment">// 1000ms时，1完成，输出1 </span><br>            <span class="hljs-comment">// 1200ms时，4完成，输出4</span><br></code></pre></td></tr></table></figure><h5 id="7、封装ajax请求"><a href="#7、封装ajax请求" class="headerlink" title="7、封装ajax请求"></a>7、封装ajax请求</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> request = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">method, url, isajax</span>) </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>            <span class="hljs-keyword">let</span> req = <span class="hljs-keyword">new</span> XMLHttpRequest();<br>            req.open(method, url, isajax);<br>            req.onload = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>                <span class="hljs-keyword">if</span> (req.readState === <span class="hljs-number">4</span> &amp;&amp; req.status === <span class="hljs-number">200</span>) &#123;<br>                    resolve(req.response)<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    reject(req.statusText);<br>                &#125;<br>               <br>                req.onerror = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>                    reject(<span class="hljs-built_in">Error</span>(<span class="hljs-string">&quot;网络异常&quot;</span>))<br>                &#125;<br>            &#125;<br>            req.send();<br>        &#125;)<br>    &#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>面经总结</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面经总结</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>webpack</title>
    <link href="/2021/02/02/webpack/"/>
    <url>/2021/02/02/webpack/</url>
    
    <content type="html"><![CDATA[<h5 id="1、有哪些常见的Loader？他们是解决什么问题的？"><a href="#1、有哪些常见的Loader？他们是解决什么问题的？" class="headerlink" title="1、有哪些常见的Loader？他们是解决什么问题的？"></a>1、有哪些常见的Loader？他们是解决什么问题的？</h5><ul><li>file-loader：把文件输出到一个文件夹中，在代码中通过相对 URL 去引用输出的文件</li><li>url-loader：和 file-loader 类似，但是能在文件很小的情况下以 base64 的方式把文件内容注入到代码中去</li><li>source-map-loader：加载额外的 Source Map 文件，以方便断点调试</li><li>image-loader：加载并且压缩图片文件</li><li>babel-loader：把 ES6 转换成 ES5</li><li>css-loader：加载 CSS，支持模块化、压缩、文件导入等特性</li><li>style-loader：把 CSS 代码注入到 JavaScript 中，通过 DOM 操作去加载 CSS。</li><li>eslint-loader：通过 ESLint 检查 JavaScript 代码</li></ul><h5 id="2、有哪些常见的Plugin？他们是解决什么问题的？"><a href="#2、有哪些常见的Plugin？他们是解决什么问题的？" class="headerlink" title="2、有哪些常见的Plugin？他们是解决什么问题的？"></a>2、有哪些常见的Plugin？他们是解决什么问题的？</h5><ul><li>define-plugin：定义环境变量</li><li>commons-chunk-plugin：提取公共代码</li><li>uglifyjs-webpack-plugin：通过UglifyES压缩ES6代码</li></ul><h5 id="3、Loader和Plugin的不同？"><a href="#3、Loader和Plugin的不同？" class="headerlink" title="3、Loader和Plugin的不同？"></a>3、Loader和Plugin的不同？</h5><p><strong>不同的作用</strong></p><ul><li><strong>Loader</strong>直译为”加载器”。Webpack将一切文件视为模块，但是webpack原生是只能解析js文件，如果想将其他文件也打包的话，就会用到loader。 所以Loader的作用是让webpack拥有了加载和解析非JavaScript文件的能力。</li><li><strong>Plugin</strong>直译为”插件”。Plugin可以扩展webpack的功能，让webpack具有更多的灵活性。 在 Webpack 运行的生命周期中会广播出许多事件，Plugin 可以监听这些事件，在合适的时机通过 Webpack 提供的 API 改变输出结果。</li></ul><p><strong>不同的用法</strong></p><ul><li><strong>Loader</strong>在module.rules中配置，也就是说他作为模块的解析规则而存在。 类型为数组，每一项都是一个Object，里面描述了对于什么类型的文件（test），使用什么加载(loader)和使用的参数（options）</li><li><strong>Plugin</strong>在plugins中单独配置。 类型为数组，每一项是一个plugin的实例，参数都通过构造函数传入</li></ul><h5 id="4、如何利用webpack来优化前端性能？（提高性能和体验）"><a href="#4、如何利用webpack来优化前端性能？（提高性能和体验）" class="headerlink" title="4、如何利用webpack来优化前端性能？（提高性能和体验）"></a>4、如何利用webpack来优化前端性能？（提高性能和体验）</h5><p>用webpack优化前端性能是指优化webpack的输出结果，让打包的最终结果在浏览器运行快速高效。</p><ul><li>压缩代码。删除多余的代码、注释、简化代码的写法等等方式。可以利用webpack的UglifyJsPlugin和ParallelUglifyPlugin来压缩JS文件， 利用cssnano（css-loader?minimize）来压缩css</li><li>利用<a href="https://cloud.tencent.com/product/cdn?from=10680">CDN</a>加速。在构建过程中，将引用的静态资源路径修改为CDN上对应的路径。可以利用webpack对于output参数和各loader的publicPath参数来修改资源路径</li><li>删除死代码（Tree Shaking）。将代码中永远不会走到的片段删除掉。可以通过在启动webpack时追加参数–optimize-minimize来实现</li><li>提取公共代码。</li></ul><h5 id="5、webpack热更新的原理。"><a href="#5、webpack热更新的原理。" class="headerlink" title="5、webpack热更新的原理。"></a>5、webpack热更新的原理。</h5><p>首先要知道server端和client端都做了处理工作</p><ol><li>第一步，在 webpack 的 watch 模式下，文件系统中某一个文件发生修改，webpack 监听到文件变化，根据配置文件对模块重新编译打包，并将打包后的代码通过简单的 JavaScript 对象保存在内存中。</li><li>第二步是 webpack-dev-server 和 webpack 之间的接口交互，而在这一步，主要是 dev-server 的中间件 webpack-dev-middleware 和 webpack 之间的交互，webpack-dev-middleware 调用 webpack 暴露的 API对代码变化进行监控，并且告诉 webpack，将代码打包到内存中。</li><li>第三步是 webpack-dev-server 对文件变化的一个监控，这一步不同于第一步，并不是监控代码变化重新打包。当我们在配置文件中配置了devServer.watchContentBase 为 true 的时候，Server 会监听这些配置文件夹中静态文件的变化，变化后会通知浏览器端对应用进行 live reload。注意，这儿是浏览器刷新，和 HMR 是两个概念。</li><li>第四步也是 webpack-dev-server 代码的工作，该步骤主要是通过 sockjs（webpack-dev-server 的依赖）在浏览器端和服务端之间建立一个 websocket 长连接，将 webpack 编译打包的各个阶段的状态信息告知浏览器端，同时也包括第三步中 Server 监听静态文件变化的信息。浏览器端根据这些 socket 消息进行不同的操作。当然服务端传递的最主要信息还是新模块的 hash 值，后面的步骤根据这一 hash 值来进行模块热替换。</li><li>webpack-dev-server/client 端并不能够请求更新的代码，也不会执行热更模块操作，而把这些工作又交回给了 webpack，webpack/hot/dev-server 的工作就是根据 webpack-dev-server/client 传给它的信息以及 dev-server 的配置决定是刷新浏览器呢还是进行模块热更新。当然如果仅仅是刷新浏览器，也就没有后面那些步骤了。</li><li>HotModuleReplacement.runtime 是客户端 HMR 的中枢，它接收到上一步传递给他的新模块的 hash 值，它通过 JsonpMainTemplate.runtime 向 server 端发送 Ajax 请求，服务端返回一个 json，该 json 包含了所有要更新的模块的 hash 值，获取到更新列表后，该模块再次通过 jsonp 请求，获取到最新的模块代码。这就是上图中 7、8、9 步骤。</li><li>而第 10 步是决定 HMR 成功与否的关键步骤，在该步骤中，HotModulePlugin 将会对新旧模块进行对比，决定是否更新模块，在决定更新模块后，检查模块之间的依赖关系，更新模块的同时更新模块间的依赖引用。</li><li>最后一步，当 HMR 失败后，回退到 live reload 操作，也就是进行浏览器刷新来获取最新打包代码。</li></ol>]]></content>
    
    
    <categories>
      
      <category>webpack</category>
      
    </categories>
    
    
    <tags>
      
      <tag>webpack</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>git常用命令</title>
    <link href="/2021/02/02/git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <url>/2021/02/02/git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<h2 id="一、新建代码库"><a href="#一、新建代码库" class="headerlink" title="一、新建代码库"></a>一、新建代码库</h2><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 在当前目录新建一个Git代码库</span><br>$ git init<br><br><span class="hljs-comment"># 新建一个目录，将其初始化为Git代码库</span><br>$ git init [project-name]<br><br><span class="hljs-comment"># 下载一个项目和它的整个代码历史</span><br>$ git <span class="hljs-built_in">clone</span> [url]<br></code></pre></td></tr></table></figure></blockquote><h2 id="二、配置"><a href="#二、配置" class="headerlink" title="二、配置"></a>二、配置</h2><p>Git的设置文件为<code>.gitconfig</code>，它可以在用户主目录下（全局配置），也可以在项目目录下（项目配置）。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 显示当前的Git配置</span><br>$ git config --list<br><br><span class="hljs-comment"># 编辑Git配置文件</span><br>$ git config -e [--global]<br><br><span class="hljs-comment"># 设置提交代码时的用户信息</span><br>$ git config [--global] user.name <span class="hljs-string">&quot;[name]&quot;</span><br>$ git config [--global] user.email <span class="hljs-string">&quot;[email address]&quot;</span><br></code></pre></td></tr></table></figure></blockquote><h2 id="三、增加-删除文件"><a href="#三、增加-删除文件" class="headerlink" title="三、增加/删除文件"></a>三、增加/删除文件</h2><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 添加指定文件到暂存区</span><br>$ git add [file1] [file2] ...<br><br><span class="hljs-comment"># 添加指定目录到暂存区，包括子目录</span><br>$ git add [dir]<br><br><span class="hljs-comment"># 添加当前目录的所有文件到暂存区</span><br>$ git add .<br><br><span class="hljs-comment"># 添加每个变化前，都会要求确认</span><br><span class="hljs-comment"># 对于同一个文件的多处变化，可以实现分次提交</span><br>$ git add -p<br><br><span class="hljs-comment"># 删除工作区文件，并且将这次删除放入暂存区</span><br>$ git rm [file1] [file2] ...<br><br><span class="hljs-comment"># 停止追踪指定文件，但该文件会保留在工作区</span><br>$ git rm --cached [file]<br><br><span class="hljs-comment"># 改名文件，并且将这个改名放入暂存区</span><br>$ git mv [file-original] [file-renamed]<br></code></pre></td></tr></table></figure></blockquote><h2 id="四、代码提交"><a href="#四、代码提交" class="headerlink" title="四、代码提交"></a>四、代码提交</h2><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 提交暂存区到仓库区</span><br>$ git commit -m [message]<br><br><span class="hljs-comment"># 提交暂存区的指定文件到仓库区</span><br>$ git commit [file1] [file2] ... -m [message]<br><br><span class="hljs-comment"># 提交工作区自上次commit之后的变化，直接到仓库区</span><br>$ git commit -a<br><br><span class="hljs-comment"># 提交时显示所有diff信息</span><br>$ git commit -v<br><br><span class="hljs-comment"># 使用一次新的commit，替代上一次提交</span><br><span class="hljs-comment"># 如果代码没有任何新变化，则用来改写上一次commit的提交信息</span><br>$ git commit --amend -m [message]<br><br><span class="hljs-comment"># 重做上一次commit，并包括指定文件的新变化</span><br>$ git commit --amend [file1] [file2] ...<br></code></pre></td></tr></table></figure></blockquote><h2 id="五、分支"><a href="#五、分支" class="headerlink" title="五、分支"></a>五、分支</h2><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 列出所有本地分支</span><br>$ git branch<br><br><span class="hljs-comment"># 列出所有远程分支</span><br>$ git branch -r<br><br><span class="hljs-comment"># 列出所有本地分支和远程分支</span><br>$ git branch -a<br><br><span class="hljs-comment"># 新建一个分支，但依然停留在当前分支</span><br>$ git branch [branch-name]<br><br><span class="hljs-comment"># 新建一个分支，并切换到该分支</span><br>$ git checkout -b [branch]<br><br><span class="hljs-comment"># 新建一个分支，指向指定commit</span><br>$ git branch [branch] [commit]<br><br><span class="hljs-comment"># 新建一个分支，与指定的远程分支建立追踪关系</span><br>$ git branch --track [branch] [remote-branch]<br><br><span class="hljs-comment"># 切换到指定分支，并更新工作区</span><br>$ git checkout [branch-name]<br><br><span class="hljs-comment"># 切换到上一个分支</span><br>$ git checkout -<br><br><span class="hljs-comment"># 建立追踪关系，在现有分支与指定的远程分支之间</span><br>$ git branch --set-upstream [branch] [remote-branch]<br><br><span class="hljs-comment"># 合并指定分支到当前分支</span><br>$ git merge [branch]<br><br><span class="hljs-comment"># 选择一个commit，合并进当前分支</span><br>$ git cherry-pick [commit]<br><br><span class="hljs-comment"># 删除分支</span><br>$ git branch -d [branch-name]<br><br><span class="hljs-comment"># 删除远程分支</span><br>$ git push origin --delete [branch-name]<br>$ git branch -dr [remote/branch]<br></code></pre></td></tr></table></figure></blockquote><h2 id="六、标签"><a href="#六、标签" class="headerlink" title="六、标签"></a>六、标签</h2><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 列出所有tag</span><br>$ git tag<br><br><span class="hljs-comment"># 新建一个tag在当前commit</span><br>$ git tag [tag]<br><br><span class="hljs-comment"># 新建一个tag在指定commit</span><br>$ git tag [tag] [commit]<br><br><span class="hljs-comment"># 删除本地tag</span><br>$ git tag -d [tag]<br><br><span class="hljs-comment"># 删除远程tag</span><br>$ git push origin :refs/tags/[tagName]<br><br><span class="hljs-comment"># 查看tag信息</span><br>$ git show [tag]<br><br><span class="hljs-comment"># 提交指定tag</span><br>$ git push [remote] [tag]<br><br><span class="hljs-comment"># 提交所有tag</span><br>$ git push [remote] --tags<br><br><span class="hljs-comment"># 新建一个分支，指向某个tag</span><br>$ git checkout -b [branch] [tag]<br></code></pre></td></tr></table></figure></blockquote><h2 id="七、查看信息"><a href="#七、查看信息" class="headerlink" title="七、查看信息"></a>七、查看信息</h2><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 显示有变更的文件</span><br>$ git status<br><br><span class="hljs-comment"># 显示当前分支的版本历史</span><br>$ git <span class="hljs-built_in">log</span><br><br><span class="hljs-comment"># 显示commit历史，以及每次commit发生变更的文件</span><br>$ git <span class="hljs-built_in">log</span> --<span class="hljs-built_in">stat</span><br><br><span class="hljs-comment"># 搜索提交历史，根据关键词</span><br>$ git <span class="hljs-built_in">log</span> -S [keyword]<br><br><span class="hljs-comment"># 显示某个commit之后的所有变动，每个commit占据一行</span><br>$ git <span class="hljs-built_in">log</span> [tag] HEAD --pretty=format:%s<br><br><span class="hljs-comment"># 显示某个commit之后的所有变动，其&quot;提交说明&quot;必须符合搜索条件</span><br>$ git <span class="hljs-built_in">log</span> [tag] HEAD --grep feature<br><br><span class="hljs-comment"># 显示某个文件的版本历史，包括文件改名</span><br>$ git <span class="hljs-built_in">log</span> --follow [file]<br>$ git whatchanged [file]<br><br><span class="hljs-comment"># 显示指定文件相关的每一次diff</span><br>$ git <span class="hljs-built_in">log</span> -p [file]<br><br><span class="hljs-comment"># 显示过去5次提交</span><br>$ git <span class="hljs-built_in">log</span> -5 --pretty --oneline<br><br><span class="hljs-comment"># 显示所有提交过的用户，按提交次数排序</span><br>$ git shortlog -sn<br><br><span class="hljs-comment"># 显示指定文件是什么人在什么时间修改过</span><br>$ git blame [file]<br><br><span class="hljs-comment"># 显示暂存区和工作区的差异</span><br>$ git diff<br><br><span class="hljs-comment"># 显示暂存区和上一个commit的差异</span><br>$ git diff --cached [file]<br><br><span class="hljs-comment"># 显示工作区与当前分支最新commit之间的差异</span><br>$ git diff HEAD<br><br><span class="hljs-comment"># 显示两次提交之间的差异</span><br>$ git diff [first-branch]...[second-branch]<br><br><span class="hljs-comment"># 显示今天你写了多少行代码</span><br>$ git diff --shortstat <span class="hljs-string">&quot;@&#123;0 day ago&#125;&quot;</span><br><br><span class="hljs-comment"># 显示某次提交的元数据和内容变化</span><br>$ git show [commit]<br><br><span class="hljs-comment"># 显示某次提交发生变化的文件</span><br>$ git show --name-only [commit]<br><br><span class="hljs-comment"># 显示某次提交时，某个文件的内容</span><br>$ git show [commit]:[filename]<br><br><span class="hljs-comment"># 显示当前分支的最近几次提交</span><br>$ git reflog<br></code></pre></td></tr></table></figure></blockquote><h2 id="八、远程同步"><a href="#八、远程同步" class="headerlink" title="八、远程同步"></a>八、远程同步</h2><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 下载远程仓库的所有变动</span><br>$ git fetch [remote]<br><br><span class="hljs-comment"># 显示所有远程仓库</span><br>$ git remote -v<br><br><span class="hljs-comment"># 显示某个远程仓库的信息</span><br>$ git remote show [remote]<br><br><span class="hljs-comment"># 增加一个新的远程仓库，并命名</span><br>$ git remote add [shortname] [url]<br><br><span class="hljs-comment"># 取回远程仓库的变化，并与本地分支合并</span><br>$ git pull [remote] [branch]<br><br><span class="hljs-comment"># 上传本地指定分支到远程仓库</span><br>$ git push [remote] [branch]<br><br><span class="hljs-comment"># 强行推送当前分支到远程仓库，即使有冲突</span><br>$ git push [remote] --force<br><br><span class="hljs-comment"># 推送所有分支到远程仓库</span><br>$ git push [remote] --all<br></code></pre></td></tr></table></figure></blockquote><h2 id="九、撤销"><a href="#九、撤销" class="headerlink" title="九、撤销"></a>九、撤销</h2><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 恢复暂存区的指定文件到工作区</span><br>$ git checkout [file]<br><br><span class="hljs-comment"># 恢复某个commit的指定文件到暂存区和工作区</span><br>$ git checkout [commit] [file]<br><br><span class="hljs-comment"># 恢复暂存区的所有文件到工作区</span><br>$ git checkout .<br><br><span class="hljs-comment"># 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变</span><br>$ git reset [file]<br><br><span class="hljs-comment"># 重置暂存区与工作区，与上一次commit保持一致</span><br>$ git reset --hard<br><br><span class="hljs-comment"># 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变</span><br>$ git reset [commit]<br><br><span class="hljs-comment"># 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致</span><br>$ git reset --hard [commit]<br><br><span class="hljs-comment"># 重置当前HEAD为指定commit，但保持暂存区和工作区不变</span><br>$ git reset --keep [commit]<br><br><span class="hljs-comment"># 新建一个commit，用来撤销指定commit</span><br><span class="hljs-comment"># 后者的所有变化都将被前者抵消，并且应用到当前分支</span><br>$ git revert [commit]<br><br><span class="hljs-comment"># 暂时将未提交的变化移除，稍后再移入</span><br>$ git stash<br>$ git stash pop<br></code></pre></td></tr></table></figure></blockquote><h2 id="十、其他"><a href="#十、其他" class="headerlink" title="十、其他"></a>十、其他</h2><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 生成一个可供发布的压缩包</span><br>$ git archive<br></code></pre></td></tr></table></figure></blockquote>]]></content>
    
    
    <categories>
      
      <category>git</category>
      
    </categories>
    
    
    <tags>
      
      <tag>git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>computerd和watch的对比</title>
    <link href="/2021/02/02/computed%E5%92%8Cwatch%E7%9A%84%E5%AF%B9%E6%AF%94/"/>
    <url>/2021/02/02/computed%E5%92%8Cwatch%E7%9A%84%E5%AF%B9%E6%AF%94/</url>
    
    <content type="html"><![CDATA[<h2 id="computed"><a href="#computed" class="headerlink" title="computed"></a>computed</h2><blockquote><p>computed 是计算属性，它会根据你所依赖的数据动态显示新的计算结果</p></blockquote><p>计算属性将被加入到 Vue 实例中。所有 getter 和 setter 的 this 上下文<strong>自动地绑定为 Vue 实例</strong></p><p>通过计算出来的属性<strong>不需要调用</strong>直接可以在 DOM 里使用</p><h3 id="基础例子"><a href="#基础例子" class="headerlink" title="基础例子"></a>基础例子</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> vm = <span class="hljs-keyword">new</span> Vue(&#123;<br>  el: <span class="hljs-string">&#x27;#app&#x27;</span>,<br>  data: &#123;<br>    message: <span class="hljs-string">&#x27;hello&#x27;</span><br>  &#125;,<br>  template: <span class="hljs-string">`</span><br><span class="hljs-string">  &lt;div&gt;</span><br><span class="hljs-string">  &lt;p&gt;我是原始值: &quot;&#123;&#123; message &#125;&#125;&quot;&lt;/p&gt;</span><br><span class="hljs-string">  &lt;p&gt;我是计算属性的值: &quot;&#123;&#123; computedMessage&#125;&#125;&quot;&lt;/p&gt; // computed 在 DOM 里直接使用不需要调用</span><br><span class="hljs-string">  &lt;/div&gt;</span><br><span class="hljs-string">  `</span>,<br>  computed: &#123;<br>    <span class="hljs-comment">// 计算属性的 getter</span><br>    computedMessage: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>      <span class="hljs-comment">// `this` 指向 vm 实例</span><br>      <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.message.split(<span class="hljs-string">&#x27;&#x27;</span>).reverse().join(<span class="hljs-string">&#x27;&#x27;</span>)<br>    &#125;<br>  &#125;<br>&#125;)<br></code></pre></td></tr></table></figure><p>结果：</p><p>我是原始值: “Hello”<br>我是计算属性的值: “olleH”</p><p>如果不使用计算属性，那么 message.split(‘’).reverse().join(‘’) 就会直接写到 template 里，那么在模版中放入太多声明式的逻辑会让模板本身过重，尤其当在页面中使用大量复杂的逻辑表达式处理数据时，<strong>会对页面的可维护性造成很大的影响</strong></p><p><strong>而且计算属性如果依赖不变的话，它就会变成缓存，computed 的值就不会重新计算</strong></p><p>所以，如果数据要通过复杂逻辑来得出结果，那么就推荐使用计算属性</p><h2 id="watch"><a href="#watch" class="headerlink" title="watch"></a>watch</h2><blockquote><p>一个对象，键是 data 对应的数据，值是对应的回调函数。值也可以是方法名，或者包含选项的对象，当 data 的数据发生变化时，就会发生一个回调，他有两个参数，一个 val （修改后的 data 数据），一个 oldVal（原来的 data 数据）<br>Vue 实例将会在实例化时调用<code>$watch()</code>，遍历 watch 对象的每一个属性</p></blockquote><h3 id="基础例子-1"><a href="#基础例子-1" class="headerlink" title="基础例子"></a>基础例子</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">new</span> Vue(&#123;<br>  data: &#123;<br>    n: <span class="hljs-number">0</span>,<br>    obj: &#123;<br>      a: <span class="hljs-string">&quot;a&quot;</span><br>    &#125;<br>  &#125;,<br>  template: <span class="hljs-string">`</span><br><span class="hljs-string">    &lt;div&gt;</span><br><span class="hljs-string">      &lt;button @click=&quot;n += 1&quot;&gt;n+1&lt;/button&gt;</span><br><span class="hljs-string">      &lt;button @click=&quot;obj.a += &#x27;hi&#x27;&quot;&gt;obj.a + &#x27;hi&#x27;&lt;/button&gt;</span><br><span class="hljs-string">      &lt;button @click=&quot;obj = &#123;a:&#x27;a&#x27;&#125;&quot;&gt;obj = 新对象&lt;/button&gt;</span><br><span class="hljs-string">    &lt;/div&gt;</span><br><span class="hljs-string">  `</span>,<br>  watch: &#123;<br>    <span class="hljs-function"><span class="hljs-title">n</span>(<span class="hljs-params"></span>)</span> &#123;<br>      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;n 变了&quot;</span>);<br>    &#125;,<br>    obj:&#123;<br>      handler: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">val, oldVal</span>) </span>&#123; <br>      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;obj 变了&quot;</span>)<br>    &#125;,<br>      deep: <span class="hljs-literal">true</span> <span class="hljs-comment">// 该属性设定在任何被侦听的对象的 property 改变时都要执行 handler 的回调，不论其被嵌套多深</span><br>    &#125;,<br>    <span class="hljs-string">&quot;obj.a&quot;</span>:&#123;<br>      handler: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">val, oldVal</span>) </span>&#123; <br>      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;obj.a 变了&quot;</span>)<br>    &#125;,<br>      immediate: <span class="hljs-literal">true</span> <span class="hljs-comment">// 该属性设定该回调将会在侦听开始之后被立即调用</span><br>    &#125;<br>  &#125;<br>&#125;).$mount(<span class="hljs-string">&quot;#app&quot;</span>);<br></code></pre></td></tr></table></figure><p>注意：<strong>不应该使用箭头函数来定义 watcher 函数</strong>，因为箭头函数没有 this，它的 this 会继承它的父级函数，但是它的父级函数是 window，导致箭头函数的 this 指向 window，而不是 Vue 实例</p><ul><li><strong>deep 控制是否要看这个对象里面的属性变化</strong></li><li><strong>immediate 控制是否在第一次渲染是执行这个函数</strong></li></ul><p><strong>vm.$watch()</strong> 的用法和 watch 回调类似</p><ul><li>vm.$watch(‘data属性名’, fn, {deep: .., immediate: ..})</li></ul><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs text">vm.$watch(&quot;n&quot;, function(val, newVal)&#123;<br>      console.log(&quot;n 变了&quot;);<br>&#125;,&#123;deep: true, immediate: true&#125;)<br></code></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>如果一个数据需要经过复杂计算就用 computed</li><li>如果一个数据需要被监听并且对数据做一些操作就用 watch</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>javascript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>vue3.0和2.0对比</title>
    <link href="/2021/02/01/vue3.0%E5%92%8C2.0%E5%AF%B9%E6%AF%94/"/>
    <url>/2021/02/01/vue3.0%E5%92%8C2.0%E5%AF%B9%E6%AF%94/</url>
    
    <content type="html"><![CDATA[<a id="more"></a><ul><li><p>2.0跟3.0的变化也挺大的，</p><ul><li>结构: 2.0用Flow ,3.0用 TypeScript。</li><li>性能: 3.0优化了Virtual Dom的算法。</li><li>响应式原理:2.0用 Object.defineProperty,3.0用Proxy</li><li>…</li></ul><h2 id="Vue2-0和Vue3-0实现原理"><a href="#Vue2-0和Vue3-0实现原理" class="headerlink" title="Vue2.0和Vue3.0实现原理"></a>Vue2.0和Vue3.0实现原理</h2><ol><li><p><strong>Vue 2.0</strong></p><p>Vue2.0实现<strong>MVVM</strong>(双向数据绑定)的原理是通过 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty">Object.defineProperty</a> 来劫持各个属性的setter、getter，在数据变动时发布消息给订阅者，触发相应的监听回调。</p><p><a href="https://cn.vuejs.org/v2/guide/reactivity.html">Vue官网</a>也给出了解释:</p></li></ol></li></ul><pre><code> ![img](https://user-gold-cdn.xitu.io/2020/3/30/1712bd3f25858548?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)</code></pre><ol start="2"><li><p><strong>Vue 3.0</strong> 实现响应式基于ES6: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy">Proxy</a></p><h2 id="Vue2-0和Vue3-0的差异如下"><a href="#Vue2-0和Vue3-0的差异如下" class="headerlink" title="Vue2.0和Vue3.0的差异如下:"></a>Vue2.0和Vue3.0的差异如下:</h2><h3 id="Vue2-0"><a href="#Vue2-0" class="headerlink" title="Vue2.0"></a>Vue2.0</h3></li></ol><ul><li><p>基于<strong>Object.defineProperty</strong>，不具备监听数组的能力，需要重新定义数组的原型来达到响应式。</p></li><li><p><strong>Object.defineProperty</strong> 无法检测到对象属性的添加和删除 。</p></li><li><p>由于Vue会在初始化实例时对属性执行getter/setter转化，所有属性必须在data对象上存在才能让Vue将它转换为响应式。</p></li><li><p>深度监听需要一次性递归，对性能影响比较大。</p><h3 id="Vue3-0"><a href="#Vue3-0" class="headerlink" title="Vue3.0"></a>Vue3.0</h3></li><li><p>基于<strong>Proxy</strong>和<strong>Reflect</strong>，可以原生监听数组，可以监听对象属性的添加和删除。</p></li><li><p>不需要一次性遍历data的属性，可以显著提高性能。</p></li><li><p>因为Proxy是ES6新增的属性，有些浏览器还不支持,只能兼容到IE11 。</p><h2 id="Vue2-x实现响应式"><a href="#Vue2-x实现响应式" class="headerlink" title="Vue2.x实现响应式"></a>Vue2.x实现响应式</h2><p>下面是基于<strong>Object.defineProperty</strong> ,一步步实现简单版Vue2.0。</p></li></ul><ol><li><p>由于<strong>Object.defineProperty</strong> 无法监听数组，所以数组类型实现响应式，需要处理。 判断如果是数组类型，就重写数组的原型方法(‘push’,’pop’,’shift’,unshift)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 重新定义数组原型，Object.defineProperty不具备监听数组的方法</span><br><span class="hljs-keyword">const</span> oldArrayProperty = <span class="hljs-built_in">Array</span>.prototype;<br>    <span class="hljs-keyword">const</span> arrProto = <span class="hljs-built_in">Object</span>.create(oldArrayProperty);<br>    [<span class="hljs-string">&quot;push&quot;</span>,<span class="hljs-string">&quot;pop&quot;</span>,<span class="hljs-string">&quot;shift&quot;</span>,<span class="hljs-string">&quot;unshift&quot;</span>,<span class="hljs-string">&quot;splice&quot;</span>].forEach(<br>        methodName =&gt; <br>        (arrProto[methodName] = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>            updateView();<br>            oldArrayProperty[methodName].call(<span class="hljs-built_in">this</span>, ...arguments);<br>        &#125;)<br>    )<br></code></pre></td></tr></table></figure></li><li><p>将传入的data属性进行深度监听，判断是对象还是数组。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">observer</span>(<span class="hljs-params">target</span>)</span>&#123;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-keyword">typeof</span> target !== <span class="hljs-string">&#x27;object&#x27;</span> || target === <span class="hljs-literal">null</span>)&#123;<br>        <span class="hljs-keyword">return</span> target<br>    &#125;<br><br>    <span class="hljs-comment">// 如果是数组类型,重写数组原型的方法(&quot;push&quot;,&quot;pop&quot;,&quot;shift&quot;,&quot;unshift&quot;,&quot;splice&quot;)</span><br>    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">Array</span>.isArray(target))&#123;<br>        target.__proto__ == arrProto;<br>    &#125;<br><br>    <span class="hljs-comment">// 如果是对象，遍历对象所有的属性，并使用Object.defineProperty把这些属性全部转为getter/setter</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> key <span class="hljs-keyword">in</span> target)&#123;<br>        defineReactive(target,key,target[key])<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>核心API Object.defineProperty，将传入属性转为  getter/setter</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">defineReactive</span>(<span class="hljs-params">target, key, value</span>)</span>&#123;<br>    <span class="hljs-comment">// 如果对象有更多的层级，再次调用observer监听方法，实现深层次的监听。</span><br>    observer(value);<br><br>    <span class="hljs-built_in">Object</span>.defineProperty(target, key, &#123;<br>        <span class="hljs-function"><span class="hljs-title">get</span>(<span class="hljs-params"></span>)</span>&#123;<br>            <span class="hljs-keyword">return</span> value;<br>        &#125;,<br>        <span class="hljs-function"><span class="hljs-title">set</span>(<span class="hljs-params">newValue</span>)</span>&#123;<br>            <span class="hljs-comment">// 设置值的时候也需要深度监听</span><br>            observer(value);<br><br>            <span class="hljs-keyword">if</span>(newValue !== value)&#123;<br>                value = newValue;<br><br>                <span class="hljs-comment">// 数据驱动视图，如果数据改变，就调用视图更新的方法。对应到Vue中是执行VDOM</span><br>                updateView();<br>            &#125;<br>        &#125;<br>    &#125;)<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>数据更新会触发视图更新，这是MVVM的绑定原理，这就会涉及到Vue的 template  编译为 render 函数，在执行 Virtual Dom， Diff算法， Vnode等 这些东西了。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">updateView</span>(<span class="hljs-params"></span>)</span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;视图更新&#x27;</span>)<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>使用</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> data = &#123;<br>  name: <span class="hljs-string">&quot;zhangsan&quot;</span>,<br>  age: <span class="hljs-number">20</span>,<br>  info: &#123;<br>    address: <span class="hljs-string">&quot;北京&quot;</span> <span class="hljs-comment">// 需要深度监听</span><br>  &#125;,<br>  nums: [<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>]<br>&#125;;<br><br>observer(data);<br></code></pre></td></tr></table></figure><h2 id="Vue3-0实现响应式"><a href="#Vue3-0实现响应式" class="headerlink" title="Vue3.0实现响应式"></a>Vue3.0实现响应式</h2><p>Vue3.0基于<strong>Proxy</strong>来做数据大劫持代理，可以原生支持到数组的响应式，不需要重写数组的原型，还可以直接支持新增和删除属性， 比Vue2.x的<strong>Object.defineProperty</strong>更加的清晰明了。</p></li><li><p>核心代码(非常少)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> proxyData = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Proxy</span>(data, &#123;<br>  <span class="hljs-function"><span class="hljs-title">get</span>(<span class="hljs-params">target,key,receive</span>)</span>&#123; <br>    <span class="hljs-comment">// 只处理本身(非原型)的属性</span><br>    <span class="hljs-keyword">const</span> ownKeys = <span class="hljs-built_in">Reflect</span>.ownKeys(target)<br>    <span class="hljs-keyword">if</span>(ownKeys.includes(key))&#123;<br>      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;get&#x27;</span>,key) <span class="hljs-comment">// 监听</span><br>    &#125;<br>    <span class="hljs-keyword">const</span> result = <span class="hljs-built_in">Reflect</span>.get(target,key,receive)<br>    <span class="hljs-keyword">return</span> result<br>  &#125;,<br>  <span class="hljs-function"><span class="hljs-title">set</span>(<span class="hljs-params">target, key, val, reveive</span>)</span>&#123;<br>    <span class="hljs-comment">// 重复的数据，不处理</span><br>    <span class="hljs-keyword">const</span> oldVal = target[key]<br>    <span class="hljs-keyword">if</span>(val == oldVal)&#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>    &#125;<br>    <span class="hljs-keyword">const</span> result = <span class="hljs-built_in">Reflect</span>.set(target, key, val,reveive)<br>    <span class="hljs-keyword">return</span> result<br>  &#125;,<br>  <span class="hljs-comment">// 删除属性</span><br>  <span class="hljs-function"><span class="hljs-title">deleteProperty</span>(<span class="hljs-params">target, key</span>)</span>&#123;<br>    <span class="hljs-keyword">const</span> result = <span class="hljs-built_in">Reflect</span>.deleteProperty(target,key)<br>    <span class="hljs-keyword">return</span> result<br>  &#125;<br>&#125;)<br></code></pre></td></tr></table></figure></li><li><p>使用</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> data = &#123;<br>  name: <span class="hljs-string">&quot;zhangsan&quot;</span>,<br>  age: <span class="hljs-number">20</span>,<br>  info: &#123;<br>    address: <span class="hljs-string">&quot;北京&quot;</span> <span class="hljs-comment">// 需要深度监听</span><br>  &#125;,<br>  nums: [<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>]<br>&#125;;<br></code></pre></td></tr></table></figure><p>直接这样就可以了，也不需要声明，Proxy直接会代理监听data的内容，非常的简单方便，唯一的不足就是部分浏览器无法兼容Proxy，也不能hack，所以目前只能兼容到IE11。</p><h2 id="全部源码"><a href="#全部源码" class="headerlink" title="全部源码"></a>全部源码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plain">可直接将代码复制到chrome浏览器的控制台，直接调试打印。<br>复制代码<br></code></pre></td></tr></table></figure></li><li><p>Vue2.0</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">defineReactive</span>(<span class="hljs-params">target, key, value</span>) </span>&#123;<br>  <span class="hljs-comment">//深度监听</span><br>  observer(value);<br><br>  <span class="hljs-built_in">Object</span>.defineProperty(target, key, &#123;<br>    <span class="hljs-function"><span class="hljs-title">get</span>(<span class="hljs-params"></span>)</span> &#123;<br>      <span class="hljs-keyword">return</span> value;<br>    &#125;,<br>    <span class="hljs-function"><span class="hljs-title">set</span>(<span class="hljs-params">newValue</span>)</span> &#123;<br>      <span class="hljs-comment">//深度监听</span><br>      observer(value);<br>      <span class="hljs-keyword">if</span> (newValue !== value) &#123;<br>        value = newValue;<br><br>        updateView();<br>      &#125;<br>    &#125;<br>  &#125;);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">observer</span>(<span class="hljs-params">target</span>) </span>&#123;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> target !== <span class="hljs-string">&quot;object&quot;</span> || target === <span class="hljs-literal">null</span>) &#123;<br>    <span class="hljs-keyword">return</span> target;<br>  &#125;<br><br>  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Array</span>.isArray(target)) &#123;<br>    target.__proto__ = arrProto;<br>  &#125;<br><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> key <span class="hljs-keyword">in</span> target) &#123;<br>    defineReactive(target, key, target[key]);<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// 重新定义数组原型</span><br><span class="hljs-keyword">const</span> oldAddrayProperty = <span class="hljs-built_in">Array</span>.prototype;<br><span class="hljs-keyword">const</span> arrProto = <span class="hljs-built_in">Object</span>.create(oldAddrayProperty);<br>[<span class="hljs-string">&quot;push&quot;</span>, <span class="hljs-string">&quot;pop&quot;</span>, <span class="hljs-string">&quot;shift&quot;</span>, <span class="hljs-string">&quot;unshift&quot;</span>, <span class="hljs-string">&quot;spluce&quot;</span>].forEach(<br>  methodName =&gt;<br>    (arrProto[methodName] = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>      updateView();<br>      oldAddrayProperty[methodName].call(<span class="hljs-built_in">this</span>, ...arguments);<br>    &#125;)<br>);<br><br><span class="hljs-comment">// 视图更新</span><br> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">updateView</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;视图更新&quot;</span>);<br>&#125;<br><br><span class="hljs-comment">// 声明要响应式的对象</span><br><span class="hljs-keyword">const</span> data = &#123;<br>  name: <span class="hljs-string">&quot;zhangsan&quot;</span>,<br>  age: <span class="hljs-number">20</span>,<br>  info: &#123;<br>    address: <span class="hljs-string">&quot;北京&quot;</span> <span class="hljs-comment">// 需要深度监听</span><br>  &#125;,<br>  nums: [<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>]<br>&#125;;<br><br><span class="hljs-comment">// 执行响应式</span><br>observer(data);<br></code></pre></td></tr></table></figure></li><li><p>Vue3.0</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> proxyData = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Proxy</span>(data, &#123;<br>  <span class="hljs-function"><span class="hljs-title">get</span>(<span class="hljs-params">target,key,receive</span>)</span>&#123; <br>    <span class="hljs-comment">// 只处理本身(非原型)的属性</span><br>    <span class="hljs-keyword">const</span> ownKeys = <span class="hljs-built_in">Reflect</span>.ownKeys(target)<br>    <span class="hljs-keyword">if</span>(ownKeys.includes(key))&#123;<br>      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;get&#x27;</span>,key) <span class="hljs-comment">// 监听</span><br>    &#125;<br>    <span class="hljs-keyword">const</span> result = <span class="hljs-built_in">Reflect</span>.get(target,key,receive)<br>    <span class="hljs-keyword">return</span> result<br>  &#125;,<br>  <span class="hljs-function"><span class="hljs-title">set</span>(<span class="hljs-params">target, key, val, reveive</span>)</span>&#123;<br>    <span class="hljs-comment">// 重复的数据，不处理</span><br>    <span class="hljs-keyword">const</span> oldVal = target[key]<br>    <span class="hljs-keyword">if</span>(val == oldVal)&#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>    &#125;<br>    <span class="hljs-keyword">const</span> result = <span class="hljs-built_in">Reflect</span>.set(target, key, val,reveive)<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;set&#x27;</span>, key, val)<br>    <span class="hljs-keyword">return</span> result<br>  &#125;,<br>  <span class="hljs-function"><span class="hljs-title">deleteProperty</span>(<span class="hljs-params">target, key</span>)</span>&#123;<br>    <span class="hljs-keyword">const</span> result = <span class="hljs-built_in">Reflect</span>.deleteProperty(target,key)<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;delete property&#x27;</span>, key)<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;result&#x27;</span>,result)<br>    <span class="hljs-keyword">return</span> result<br>  &#125;<br>&#125;)<br>     <br> <span class="hljs-comment">// 声明要响应式的对象,Proxy会自动代理</span><br><span class="hljs-keyword">const</span> data = &#123;<br>  name: <span class="hljs-string">&quot;zhangsan&quot;</span>,<br>  age: <span class="hljs-number">20</span>,<br>  info: &#123;<br>    address: <span class="hljs-string">&quot;北京&quot;</span> <span class="hljs-comment">// 需要深度监听</span><br>  &#125;,<br>  nums: [<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>]<br>&#125;;<br></code></pre></td></tr></table></figure></li></ol><p>  作者：rickchen35141<br>  链接：<a href="https://juejin.cn/post/6844904111813443598">https://juejin.cn/post/6844904111813443598</a><br>  来源：掘金<br>  著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>]]></content>
    
    
    <categories>
      
      <category>javascript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>javascript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>跨域问题</title>
    <link href="/2021/01/28/%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98/"/>
    <url>/2021/01/28/%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h2 id="CORS跨域问题"><a href="#CORS跨域问题" class="headerlink" title="CORS跨域问题"></a>CORS跨域问题</h2><a id="more"></a><p>CORS跨域资源共享：跨域资源共享（CORS）是一种机制，它使用额外的HTTP头来告诉浏览器，让运行在一个与origin上的Web应用被准许访问来自不同源服务器上的指定的资源。当一个资源从与该资源本身所在的服务器不同的域或端口请求资源时，资源会发起一个跨域的HTTP的请求。应该算是现在比较推荐的跨域解决方案。</p><ul><li>现在浏览器将CORS的请求分成两类：<code>简单请求</code>和<code>非简单请求</code></li></ul><h3 id="1、简单请求"><a href="#1、简单请求" class="headerlink" title="1、简单请求"></a>1、简单请求</h3><table><thead><tr><th>请求方式</th><th>HTTP的头信息不超过字段</th></tr></thead><tbody><tr><td>HEAD</td><td>Accept（客户端希望接受的类型，text/xml就是xml的类型）</td></tr><tr><td>GET</td><td>Accept-Language（浏览器支持的语言）</td></tr><tr><td>POST</td><td>Content-Language（精确你的语言类型，Content-Type能知道是中文还是英文，但是不知道是繁体中文还是简体中文，英语不知道是英式还是美式，而且不写默认是按文件的语言传的，同理写给用德语的人，不代表写文件的人是使用德语的，可设置语言，权重）</td></tr><tr><td></td><td>Content-Type（application/x-www-form-urlencoded（表单默认提交的数据）、mulitipart/form-data（需要在表单中进行上传文件提交的格式）、text/plain（纯文本））</td></tr></tbody></table><p>非简单请求会发出一次预检测请求，返回码是204，预检测通过才会真正发出请求，这才返回200。这里通过前端发请求的时候增加一个额外的headers来触发非简单请求。</p><ul><li><p>进行带有身份凭证的CORS请求</p><ul><li>默认情况下的跨域请求都是不会把cookie发送给服务器的，在需要发送的情况下，如果是xhr,那么需要设置xhr.withCredentials=true</li><li>如果是采用fetch获取的话，那么需要在request里面设置credential:’include’,</li><li>但是如果服务器在预请求的时候没返回Access-Control-Allow-Crenditials:ture的话，那么在实际请求的时候，cookie是不会被发送给服务器端的，要特别注意对于简单的get请求，不会有预请求的过程</li><li>那么在实际请求的时候，如果服务器没有返回Access-Control-Allow-Crenditial:true的话那么相应结果浏览器也不会交给请求者。</li></ul></li><li><p>对于附带身份凭证的请求，服务器不得设置Access-Control-Allow-Origin的值为“<code>*</code>”。这是因为请求的首部中携带了Cookie信息，如果Access-Control-Allow-Origin的值为“<code>*</code>”,请求将会失败。而将Access-Cotrol-Allow-Origin的值设置为<code>http://www.a.com</code>,则请求将成功执行。</p></li><li><p>HTTP响应首部字段</p><table><thead><tr><th>字段</th><th>意义</th></tr></thead><tbody><tr><td>Access-Control-Allow-Origin</td><td><code>&lt;origin&gt;</code>|*，如果要发送cookies就不能将这个设置成<code>*</code>,必须明确设置与请求网页一致的域名。</td></tr><tr><td>Access-Control-Expose-Headers</td><td>XMLhttpRequest对象的getResponseHeader()方法只能获取到6个基本字段（Cache-control、Content-Language、Content-Type、Expires、Last-Modfied、Pragma）如果想要拿到其他字段，就需要在这里指定，然后getResponseHeader(“字段名”)。</td></tr><tr><td>Access-Control-Max-Age</td><td>头指定了（预检）preflight请求的结果能够被缓存多久</td></tr><tr><td>Access-Control-Allow-Credentials</td><td>头指定了当浏览器的credentials设置为true时是否允许浏览器读取response的内容</td></tr><tr><td>Access-Control-Allow-Methods</td><td>首部字段用于预检请求的响应。其指明了实际请求所允许使用的HTTP方法。（GET/PUT/POST/DELETE）</td></tr><tr><td>Access-Control-Allow-Headers</td><td>首部字段用于预检请求的响应。其指明了实际请求中允许携带的首部字段(Content-Type)，如果浏览器的请求包含Access-Control-Request-Header，那么该字段则必须，表示服务器所支持的所有头信息字段。</td></tr></tbody></table></li></ul><h3 id="2、非简单请求"><a href="#2、非简单请求" class="headerlink" title="2、非简单请求"></a>2、非简单请求</h3><p>非简单请求是那种对服务器有特殊要求的请求，比如请求方法是<code>PUT</code>或<code>DELETE</code>，或者<code>Content-Type</code>字段类型为<code>application/json</code>,非简单请求的CORS请求，会在正式通信之前，增加一次HTTP查询请求，称为预检请求。</p><h5 id="预检请求包含的字段"><a href="#预检请求包含的字段" class="headerlink" title="预检请求包含的字段"></a>预检请求包含的字段</h5><table><thead><tr><th>字段</th><th>意义</th></tr></thead><tbody><tr><td>Orign</td><td>表示请求来自哪个源</td></tr><tr><td>Access-Control-Request-Method</td><td>该字段必须，用来列出浏览器的CORS请求会用到哪些HTTP方法，上例是<code>PUT</code>.</td></tr><tr><td>Access-Control-Request-Header</td><td>该字段是一个逗号分割的字符串，指定浏览器CORS请求会额外的发送的头信息的字段</td></tr></tbody></table><p>如果返还一个没有任何CORS相关的头信息字段，这时，浏览器就会认为，服务器不同意预检请求，然后发送一个错误，被XMLhttpRqueset对象的onerror捕获。</p><h3 id="3、如何取消ajax请求"><a href="#3、如何取消ajax请求" class="headerlink" title="3、如何取消ajax请求"></a>3、如何取消ajax请求</h3><ul><li>对于原生XHR对象来说，取消ajax的关键是调用XHR对象的.abort()方法</li><li>axios去发送请求的话，</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> CancelToken = axios.CancelToken;<br><span class="hljs-keyword">var</span> source = CancelToken.source();<br><br>axios(&#123;<br>method:<span class="hljs-string">&quot;GET&quot;</span>,<br>url:<span class="hljs-string">&quot;https:api.github.com&quot;</span>,<br>cancelToken:source.token<br><span class="hljs-comment">//cancelToken的值起表示作用，标识由source控制的，将要被取消的ajax操作</span><br>&#125;)<br><br>source.cancel(<span class="hljs-string">&#x27;message&#x27;</span>)<br></code></pre></td></tr></table></figure><ul><li>用fetch，有<code>var controller = new AbortControll()</code>，可以<code>controller.abort()</code></li></ul>]]></content>
    
    
    <categories>
      
      <category>web前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>web前端</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>react和vue对比</title>
    <link href="/2021/01/25/vue%E4%B8%8Ereact%E7%9A%84%E8%AF%A6%E7%BB%86%E5%AF%B9%E6%AF%94/"/>
    <url>/2021/01/25/vue%E4%B8%8Ereact%E7%9A%84%E8%AF%A6%E7%BB%86%E5%AF%B9%E6%AF%94/</url>
    
    <content type="html"><![CDATA[<p>作者：视觉派Pie<br>链接：<a href="https://www.zhihu.com/question/301860721/answer/815280420">https://www.zhihu.com/question/301860721/answer/815280420</a><br>来源：知乎<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p><p>主要从以下几个方面入手方面展开：</p><ul><li>框架的诞生</li><li>设计思想</li><li>编写语法</li><li>脚手架构建工具</li><li>数据绑定</li><li>虚拟DOM</li><li>指令</li><li>性能优化</li><li>原生渲染native</li><li>ssr服务端渲染</li><li>生命周期函数</li><li>销毁组件</li><li>状态集管理工具</li></ul><h2 id="设计思想"><a href="#设计思想" class="headerlink" title="设计思想"></a>设计思想</h2><h3 id="vue"><a href="#vue" class="headerlink" title="vue"></a>vue</h3><p>vue的官网中说它是一款渐进式框架，采用自底向上增量开发的设计。这里我们需要明确一个概念，什么是渐进式框架。在声明式渲染（视图模板引擎）的基础上，我们可以通过添加组件系统（components）、客户端路由（vue-router）、大规模状态管理（vuex）来构建一个完整的框架。Vue从设计角度来讲，<strong>虽然能够涵盖所有这些内容，但是你并不需要一上手就把所有东西全用上</strong>，因为没有必要。无论从学习角度，还是实际情况，这都是可选的。声明式渲染和组建系统是Vue的核心库所包含内容，而客户端路由、状态管理、构建工具都有专门解决方案。这些解决方案相互独立，你可以在核心的基础上任意选用其他的部件，不一定要全部整合在一起。可以看到，所说的“渐进式”，其实就是Vue的使用方式，同时也体现了Vue的设计的理念。</p><h3 id="react"><a href="#react" class="headerlink" title="react"></a>react</h3><p>react主张函数式编程，所以推崇纯组件，数据不可变，单向数据流，当然需要双向的地方也可以手动实现，比如借助 onChange 和  setState 来实现一个双向的数据流。而vue是基于可变数据的，支持双向绑定，它提供了v-model这样的指令来实现文本框的数据流双向绑定。</p><h2 id="编写语法"><a href="#编写语法" class="headerlink" title="编写语法"></a>编写语法</h2><h3 id="vue-1"><a href="#vue-1" class="headerlink" title="vue"></a>vue</h3><p>vue推荐的做法是webpack+vue-loader的单文件组件格式，vue保留了html、css、js分离的写法，使得现有的前端开发者在开发的时候能保持原有的习惯，更接近常用的web开发方式，模板就是普通的html，数据绑定使用mustache风格，样式直接使用css。其中<code>&lt;style&gt;</code>标签还提供了一个可选的scoped属性，它会为组件内  CSS 指定作用域，用它来控制仅对当前组件有效还是全局生效。</p><p>模板和JSX是各有利弊的东西。模板更贴近我们的HTML，可以让我们更直观地思考语义结构，更好地结合CSS的书写。</p><p>同时vue也支持JSX语法，因为是真正的JavaScript，拥有这个语言本身的所有的能力，可以进行复杂的逻辑判断，进行选择性的返回最终要返回的DOM结构，能够实现一些在模板的语法限制下，很难做到的一些事情。</p><h3 id="react-1"><a href="#react-1" class="headerlink" title="react"></a>react</h3><p>用过react的开发者可能知道，react是没有模板的，直接就是一个渲染函数，它中间返回的就是一个虚拟DOM树，React推荐的做法是  JSX + inline style, 也就是把HTML和CSS全都写进JavaScript了,即’all in  js’。JSX实际就是一套使用XML语法，用于让我们更简单地去描述树状结构的语法糖。在react中，所有的组件的渲染功能都依靠JSX。你可以在render()中编写类似XML的语法，它最终会被编译成原生JavaScript。不仅仅是  HTML 可以用 JSX 来表达，现在的潮流也越来越多地将 CSS 也纳入到 JavaScript 中来处理。JSX是基于 JS  之上的一套额外语法，学习使用起来有一定的成本。</p><h2 id="构建工具"><a href="#构建工具" class="headerlink" title="构建工具"></a>构建工具</h2><h3 id="vue-2"><a href="#vue-2" class="headerlink" title="vue"></a>vue</h3><p>vue提供了CLI 脚手架，可以帮助你非常容易地构建项目。全局安装之后，我们就可以用 vue create命令创建一个新的项目，vue 的  CLI 跟其他  CLI不同之处在于，有多个可选模板，有简单的也有复杂的，可以让用户自定义选择需要安装的模块，还可以将你的选择保存成模板，便于后续使用。</p><p>极简的配置，更快的安装，可以更快的上手。它也有一个更完整的模板，包括单元测试在内的各种内容都涵盖，但是，它的复杂度也更高，这又涉及到根据用例来选择恰当复杂度的问题。</p><h3 id="react-2"><a href="#react-2" class="headerlink" title="react"></a>react</h3><p>React 在这方面也提供了 create-react-app，但是现在还存在一些局限性：</p><ul><li>它不允许在项目生成时进行任何配置，而 Vue CLI 运行于可升级的运行时依赖之上，该运行时可以通过插件进行扩展。</li><li>它只提供一个构建单页面应用的默认选项，而 Vue 提供了各种用途的模板。</li><li>它不能用用户自建的预设配置构建项目，这对企业环境下预先建立约定是特别有用的。</li></ul><p>而要注意的是这些限制是故意设计的，这有它的优势。例如，如果你的项目需求非常简单，你就不需要自定义生成过程。你能把它作为一个依赖来更新。</p><h2 id="数据绑定"><a href="#数据绑定" class="headerlink" title="数据绑定"></a>数据绑定</h2><h3 id="vue-3"><a href="#vue-3" class="headerlink" title="vue"></a>vue</h3><p>vue是实现了双向数据绑定的mvvm框架，当视图改变更新模型层，当模型层改变更新视图层。在vue中，使用了双向绑定技术，就是View的变化能实时让Model发生变化，而Model的变化也能实时更新到View。</p><p>Vue采用数据劫持&amp;发布-订阅模式的方式，vue在创建vm的时候，会将数据配置在实例当中，然后通过Object.defineProperty对数据进行操作，为数据动态添加了getter与setter方法，当获取数据的时候会触发对应的getter方法，当设置数据的时候会触发对应的setter方法，从而进一步触发vm的watcher方法，然后数据更改，vm则会进一步触发视图更新操作。</p><h3 id="react-3"><a href="#react-3" class="headerlink" title="react"></a>react</h3><p>react是单向数据流，react中属性是不允许更改的，状态是允许更改的。react中组件不允许通过this.state这种方式直接更改组件的状态。自身设置的状态，可以通过setState来进行更改。在setState中，传入一个对象，就会将组件的状态中键值对的部分更改，还可以传入一个函数，这个回调函数必须向上面方式一样的一个对象函数可以接受prevState和props。通过调用this.setState去更新this.state,不能直接操作this.state，请把它当成不可变的。<br>调用setState更新this.state，它不是马上就会生效的，它是异步的。所以不要认为调用完setState后可以立马获取到最新的值。多个顺序执行的setState不是同步的一个接着一个的执行，会加入一个异步队列，然后最后一起执行，即批处理。</p><p>setState是异步的，导致获取dom可能拿的还是之前的内容，所以我们需要在setState第二个参数（回调函数）中获取更新后的新的内容。</p><h2 id="diff算法"><a href="#diff算法" class="headerlink" title="diff算法"></a>diff算法</h2><h3 id="vue-4"><a href="#vue-4" class="headerlink" title="vue"></a>vue</h3><p><strong>vue中diff算法实现流程</strong></p><ol><li>在内存中构建虚拟dom树</li><li>将内存中虚拟dom树渲染成真实dom结构</li><li>数据改变的时候，将之前的虚拟dom树结合新的数据生成新的虚拟dom树</li><li>将此次生成好的虚拟dom树和上一次的虚拟dom树进行一次比对（diff算法进行比对），来更新只需要被替换的DOM，而不是全部重绘。在Diff算法中，只平层的比较前后两棵DOM树的节点，没有进行深度的遍历。</li><li>会将对比出来的差异进行重新渲染</li></ol><h3 id="react-4"><a href="#react-4" class="headerlink" title="react"></a>react</h3><p><strong>react中diff算法实现流程</strong></p><ol><li>DOM结构发生改变—–直接卸载并重新create</li><li>DOM结构一样—–不会卸载,但是会update变化的内容</li><li>所有同一层级的子节点.他们都可以通过key来区分—–同时遵循1.2两点<br>（其实这个key的存在与否只会影响diff算法的复杂度,换言之,你不加key的情况下,diff算法就会以暴力的方式去根据一二的策略更新,但是你加了key,diff算法会引入一些另外的操作）</li></ol><p>React会逐个对节点进行更新，转换到目标节点。而最后插入新的节点，涉及到的DOM操作非常多。diff总共就是移动、删除、增加三个操作，而如果给每个节点唯一的标识（key），那么React优先采用移动的方式，能够找到正确的位置去插入新的节点。</p><p>vue会跟踪每一个组件的依赖关系，不需要重新渲染整个组件树。而对于React而言,每当应用的状态被改变时,全部组件都会重新渲染,所以react中会需要shouldComponentUpdate这个生命周期函数方法来进行控制。</p><h2 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h2><p>指令 (Directives) 是带有 <code>v-</code> 前缀的特殊特性，指令的职责是，当表达式的值改变时，将其产生的连带影响，响应式地作用于 DOM。</p><h3 id="vue-5"><a href="#vue-5" class="headerlink" title="vue"></a>vue</h3><p>vue中提供很多内部指令供我们使用，它可以让我们进行一些模板的操作，例如有时候，我们的data中的存放的数据不是个简单的数字或者字符串，而是数组Array类型，这个时候，我们要把数组的元素展示在视图上，就需要用到vue提供的  v-for 指令，来实现列表的渲染。</p><h3 id="react-5"><a href="#react-5" class="headerlink" title="react"></a>react</h3><p>因为react中没有v-for指令，所以循环渲染的时候需要用到map()方法来渲染视图，并且将符合条件的元素放入一个新数组返回。</p><h2 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h2><h3 id="vue-6"><a href="#vue-6" class="headerlink" title="vue"></a>vue</h3><p>vue中的每个组件内部自动实现了<code>shouldComponentUpdate</code>的优化，在vue里面由于依赖追踪系统的存在，当任意数据变动的时，Vue的每一个组件都精确地知道自己是否需要重绘，所以并不需要手动优化。用vue渲染这些组件的时候，数据变了，对应的组件基本上去除了手动优化的必要性。而在react中我们需要手动去优化其性能，但是当数据特别多的时候vue中的watcher也会特别多，从而造成页面卡顿，所以一般数据比较多的大型项目会倾向于使用react。在react官网中，官方也建议我们使用React来构建快速响应的大型  Web 应用程序。</p><h3 id="react-6"><a href="#react-6" class="headerlink" title="react"></a>react</h3><p>当props或state发生改变的时候会触发<code>shouldComponentUpdate</code>生命周期函数，它是用来控制组件是否被重新渲染的，如果它返回true，则执行render函数，更新组件；如果它返回false，则不会触发重新渲染的过程。</p><p>有的时候我们希望它在更新之前，和之前的状态进行一个对比，这个时候我们就需要重写<code>shouldComponentUpdate</code>来避免不必要的dom操作，对比当前的props或state和更新之后的nextProps或nextState，返回true时 ，组件更新；返回false，则不会更新，节省性能。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs text">shouldComponentUpdate(nextProps, nextState) &#123;<br>        if (this.props.a !== nextProps.a) &#123;<br>            return true;<br>        &#125;<br>        if (this.state.b !== nextState.b) &#123;<br>            return true;<br>        &#125;<br>        return false;<br>    &#125;<br></code></pre></td></tr></table></figure><p>我们也可以创建一个继承React.PureComponent的React组件，它自带<code>shouldComponentUpdate</code>，可以对props进行浅比较，发现更新之后的props与当前的props一样，就不会进行render了。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs text">class Test extends React.PureComponent&#123;<br>    constructor(props)&#123;<br>        super(props);<br>    &#125;<br>    render()&#123;<br>        return &lt;div&gt;hello...&#123;this.props.a&#125;&lt;/div&gt;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>由于React.PureComponent进行的是浅比较，也就是说它只会对比原对象的值是否相同，当我们的props或state为数组或者对象这种引用类型的时候，我们修改它的数值，由于数据引用指针没有发生改变，所以组件也是不会重新渲染的。这个时候我们就需要进行深拷贝，创建一个新的对象或数组，将原对象的各项属性的”值”（数组的所有元素）拷贝过来，是”值”而不仅仅是”引用地址”。我们可以使用slice()方法：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">ew_state.todos = new_state.todos.slice();<br></code></pre></td></tr></table></figure><p>或者引入immutable库来实现数据不可变。</p><h2 id="原生渲染native"><a href="#原生渲染native" class="headerlink" title="原生渲染native"></a>原生渲染native</h2><p>native指的是使用原生API来开发App，比如ios使用OC语言，android使用java。</p><h3 id="vue-7"><a href="#vue-7" class="headerlink" title="vue"></a>vue</h3><p>vue和Weex进行官方合作，weex是阿里巴巴发起的跨平台用户界面开发框架，它的思想是多个平台，只写一套代码，weex允许你使用 vue  语法开发不仅仅可以运行在浏览器端，还能被用于开发 iOS 和 Android  上的原生应用的组件。即只需要编写一份代码，即可运行在Web、iOS、Android上。</p><p>weex相对来说上手比较简单，安装vue-cli之后就可以使用，学习门槛低，但是它的社区目前还处于成长期，react native的社区非常成熟活跃，有非常丰富的组件可供扩展。</p><h3 id="react-7"><a href="#react-7" class="headerlink" title="react"></a>react</h3><p>react  native是Facebook在2015年3月在F8开发者大会上开源的跨平台UI框架，需针对iOS、Android不同编写2份代码，使用react   native需要按照文档安装配置很多依赖的工具，相对比较麻烦。weex的思想是多个平台，只写一套代码，而react-native的思想是多个平台可以写多套代码，但其使用的是同一套语言框架。<br>weex的目标在于抹平各个平台的差异性，从而简化应用开发。而react-native承认了各个平台之间的差异，退而求其次，在语言和框架层面对平台进行抽象，从方法论的角度去解决多平台开发的问题。</p><h2 id="ssr服务端渲染"><a href="#ssr服务端渲染" class="headerlink" title="ssr服务端渲染"></a>ssr服务端渲染</h2><p>服务端渲染核心在于方便seo优化，后端先调用数据库，获得数据之后，将数据和页面元素进行拼装，组合成完整的html页面，再直接返回给浏览器，以便用户浏览。</p><h3 id="vue-8"><a href="#vue-8" class="headerlink" title="vue"></a>vue</h3><p>2016 年 10 月 25 日，<a href="https://link.zhihu.com/?target=http://zeit.co">http://zeit.co</a>背后的团队对外发布了 Next.js，一个 React 的服务端渲染应用框架。几小时后，与 Next.js 异曲同工，一个基于 Vue.js 的服务端渲染应用框架应运而生，我们称之为：Nuxt.js。</p><p>服务端渲染支持流式渲染，因为HTTP请求也是流式，Vue 的服务端渲染结果可以直接 pipe 到返回的请求里面。这样一来，就可以更早地在浏览器中呈现给用户内容，通过合理的缓存策略，可以有效地提升服务端渲染的性能。</p><ul><li>基于 Vue.js</li><li>自动代码分层</li><li>服务端渲染</li><li>强大的路由功能，支持异步数据</li><li>静态文件服务</li><li>ES2015+ 语法支持</li><li>打包和压缩 JS 和 CSS</li><li>HTML 头部标签管理</li><li>本地开发支持热加载</li><li>集成 ESLint</li><li>支持各种样式预处理器： SASS、LESS、 Stylus 等等</li><li>支持 HTTP/2 推送</li></ul><h3 id="react-8"><a href="#react-8" class="headerlink" title="react"></a>react</h3><p>Next是一个React框架，允许使用React构建SSR和静态web应用</p><ul><li>服务器渲染，获取数据非常简单</li><li>无需学习新框架，支持静态导出。</li><li>支持CSS-in-JS库</li><li>自动代码拆分，加快页面加载速度，不加载不必要的代码</li><li>基于Webpack的开发环境，支持模块热更新（HMR）</li><li>支持Babel和Webpack自定义配置服务器、路由和next插件。</li><li>能够部署在任何能运行node的平台</li><li>内置页面搜索引擎优化（SEO）处理</li><li>在生产环境下，打包文件体积更小，运行速度更快</li></ul><h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><h3 id="vue-9"><a href="#vue-9" class="headerlink" title="vue"></a>vue</h3><p>【初始化阶段（4个）】</p><p>（1）beforeCreate</p><p>此钩子函数不能获取到数据，dom元素也没有渲染出来，此钩子函数不会用来做什么事情。</p><p>（2）created</p><p>此钩子函数，数据已经挂载了，但是dom节点还是没有渲染出来，在这个钩子函数里面，如果同步更改数据的话，不会影响运行中钩子函数的执行。可以用来发送ajax请求，也可以做一些初始化事件的相关操作。</p><p>（3）beforeMount</p><p>代表dom节点马上要被渲染出来了，但是还没有真正的渲染出来，此钩子函数跟created钩子函数基本一样，也可以做一些初始化数据的配置。</p><p>（4）mounted</p><p>是生命周期初始化阶段的最后一个钩子函数，数据已经挂载完毕了，真实dom也可以获取到了。</p><p>【运行中阶段（2个）】</p><p>（5）beforeUpdate</p><p>运行中钩子函数beforeUpdate默认是不会执行的，当数据更改的时候，才会执行。数据更新的时候，先调用beforeUpdate，然后数据更新引发视图渲染完成之后，再会执行updated。运行时beforeUpdate这个钩子函数获取的数据还是更新之前的数据（获取的是更新前的dom内容），在这个钩子函数里面，千万不能对数据进行更改，会造成死循环。</p><p>（6）updated</p><p>这个钩子函数获取的数据是更新后的数据，生成新的虚拟dom，跟上一次的虚拟dom结构进行比较，比较出来差异（diff算法）后再渲染真实dom，当数据引发dom重新渲染的时候，在updated钩子函数里面就可以获取最新的真实dom了。</p><p>【销毁阶段（2个）】</p><p>（7）beforeDestroy</p><p>切换路由的时候，组件就会被销毁了，销毁之前执行beforeDestroy。在这个钩子函数里面，我们可以做一些善后的操作，例如可以清空一下全局的定时器（created钩子函数绑定的初始化阶段的事件）、清除事件绑定。</p><p>（8）destoryed</p><p>组件销毁后执行destroyed，销毁后组件的双向数据绑定、事件监听watcher相关的都被移除掉了，但是组件的真实dom结构还是存在在页面中的。</p><p><strong>添加keep-alive标签后会增加active和deactive这两个生命周期函数，初始化操作放在actived里面，一旦切换组件，因为组件没有被销毁，所以它不会执行销毁阶段的钩子函数，所以移除操作需要放在deactived里面，在里面进行一些善后操作，这个时候created钩子函数只会执行一次，销毁的钩子函数一直没有执行。</strong></p><h3 id="react-9"><a href="#react-9" class="headerlink" title="react"></a>react</h3><p>【初始化阶段（5个）】：</p><p>（1）getDefaultProps：实例化组件之后，组件的getDefaultProps钩子函数会执行</p><p>这个钩子函数的目的是为组件的实例挂载默认的属性</p><p>这个钩子函数只会执行一次，也就是说，只在第一次实例化的时候执行，创建出所有实例共享的默认属性，后面再实例化的时候，不会执行getDefaultProps，直接使用已有的共享的默认属性</p><p>理论上来说，写成函数返回对象的方式，是为了防止实例共享，但是react专门为了让实例共享，只能让这个函数只执行一次</p><p>组件间共享默认属性会减少内存空间的浪费，而且也不需要担心某一个实例更改属性后其他的实例也会更改的问题，因为组件不能自己更改属性，而且默认属性的优先级低。</p><p>（2）getInitialState：为实例挂载初始状态，且每次实例化都会执行，也就是说，每一个组件实例都拥有自己独立的状态。</p><p>（3）componentWillMount：执行componentWillMount，相当于Vue里的created+beforeMount，这里是在渲染之前最后一次更改数据的机会，在这里更改的话是不会触发render的重新执行。</p><p>（4）<strong>render</strong>：渲染dom</p><p><code>render()</code>方法必须是一个纯函数，他不应该改变<code>state</code>，也不能直接和浏览器进行交互，应该将事件放在其他生命周期函数中。 如果<code>shouldComponentUpdate()</code>返回<code>false</code>，<code>render()</code>不会被调用。</p><p>（5）componentDidMount：相当于Vue里的mounted,多用于操作真实dom</p><p>【运行中阶段（5个）】</p><p>当组件mount到页面中之后，就进入了运行中阶段，在这里有5个钩子函数，但是这5个函数只有在数据（属性、状态）发送改变的时候才会执行</p><p>（1）componentWillReceiveProps(nextProps,nextState)</p><p>当父组件给子组件传入的属性改变的时候，子组件的这个函数才会执行。初始化props时候不会主动执行</p><p>当执行的时候，函数接收的参数是子组件接收到的新参数，这个时候，新参数还没有同步到this.props上,多用于判断新属性和原有属性的变化后更改组件的状态。</p><p>（2）接下来就会执行shouldComponentUpdate(nextProps,nextState),这个函数的作用：当属性或状态发生改变后控制组件是否要更新，提高性能,返回true就更新，否则不更新，默认返回true。</p><p>接收nextProp、nextState，根据根据新属性状态和原属性状态作出对比、判断后控制是否更新</p><p>如果<code>shouldComponentUpdate()</code>返回<code>false</code>，<code>componentWillUpdate</code>,<code>render</code>和<code>componentDidUpdate</code>不会被调用。</p><p>（3）componentWillUpdate,在这里，组件马上就要重新render了，多做一些准备工作，千万千万，不要在这里修改状态，否则会死循环 相当于Vue中的beforeUpdate</p><p>（4）render，重新渲染dom</p><p>（5）componentDidUpdate，在这里，新的dom结构已经诞生了,相当于Vue里的updated</p><p>【销毁阶段】</p><p><strong>当组件被销毁之前的一刹那，会触发componentWillUnmount，临死前的挣扎</strong></p><p>相当于Vue里的beforeDestroy，所以说一般会做一些善后的事情，例如使定时器无效，取消网络请求或清理在<code>componentDidMount</code>中创建的任何监听。</p><h2 id="销毁组件"><a href="#销毁组件" class="headerlink" title="销毁组件"></a>销毁组件</h2><h3 id="vue-10"><a href="#vue-10" class="headerlink" title="vue"></a>vue</h3><p>vue在调用$destroy方法的时候就会执行beforeDestroy生命周期函数，然后组件被销毁，这个时候组件的dom结构还存在于页面结构中，也就说如果想要对残留的dom结构进行处理必须在destroyed生命周期函数中处理。</p><h3 id="react-10"><a href="#react-10" class="headerlink" title="react"></a>react</h3><p>react执行完componentWillUnmount之后把事件、数据、dom都全部处理掉了，也就是说当父组件从渲染这个子组件变成不渲染这个子组件的时候，子组件相当于被销毁，所以根本不需要其他的钩子函数了。react销毁组件的时候，会将组件的dom结构也移除，vue则不然，在调用destory方法销毁组件的时候，组件的dom结构还是存在于页面中的，this.$destory组件结构还是存在的，只是移除了事件监听，所以这就是为什么vue中有destroyed，而react却没有componentDidUnmount。</p><h2 id="状态集管理工具"><a href="#状态集管理工具" class="headerlink" title="状态集管理工具"></a>状态集管理工具</h2><h3 id="vue-11"><a href="#vue-11" class="headerlink" title="vue"></a>vue</h3><p>vuex是一个专门为vue构建的状态集管理工具，vue和react都是基于组件化开发的，项目中包含很多的组件，组件都会有组件嵌套，想让组件中的数据被其他组件也可以访问到就需要使用到Vuex。</p><p>[图片上传失败…(image-2a0a7e-1565257938346)]</p><p><strong>vuex的流程</strong></p><ol><li>将需要共享的状态挂载到state上：this.$store.state来调用</li></ol><p>创建store，将状态挂载到state上，在根实例里面配置store，之后我们在组件中就可以通过this.$store.state来使用state中管理的数据，但是这样使用时，当state的数据更改的时候，vue组件并不会重新渲染，所以我们要通过计算属性computed来使用，但是当我们使用多个数据的时候这种写法比较麻烦，vuex提供了<strong>mapState辅助函数</strong>，帮助我们在组件中获取并使用vuex的store中保存的状态。</p><ol><li>我们通过getters来创建状态：通过this.$store.getters来调用</li></ol><p>可以根据某一个状态派生出一个新状态，vuex也提供了<strong>mapGetters辅助函数</strong>来帮助我们在组件中使用getters里的状态。</p><ol><li>使用mutations来更改state：通过this.$store.commit来调用</li></ol><p>我们不能直接在组件中更改state，而是需要使用mutations来更改，mutations也是一个纯对象，里面包含很多更改state的方法，这些方法的形参接收到state，在函数体里更改，这时，组件用到的数据也会更改，实现响应式。vuex提供了mapMutations方法来帮助我们在组件中调用mutations  的方法。</p><ol><li>使用actions来处理异步操作：this.$store.dispatch来调用</li></ol><p>Actions类似于mutations，不同在于：Actions提交的是mutations，而不是直接变更状态。Actions可以包含任意异步操作。也就是说，如果有这样的需求：在一个异步操作处理之后，更改状态，我们在组件中应该先调用actions，来进行异步动作，然后由actions调用mutations来更改数据。在组件中通过this.$store.dispatch方法调用actions的方法，当然也可以使用mapMutations来辅助使用。</p><h3 id="react-11"><a href="#react-11" class="headerlink" title="react"></a>react</h3><p>2015年Redux出现，将 Flux  与函数式编程结合一起，很短时间内就成为了最热门的前端架构。它的出现主要是为解决react中组件之间的通信问题。建议把数据放入到redux中管理，目的就是方便数据统一，好管理。项目一旦出现问题，可以直接定位问题点。组件扩展的时候，后续涉及到传递的问题。本来的话，组件使用自己的数据，但是后来公用组件，还需要考虑如何值传递，在redux中可以存储至少5G以上的数据。</p><p><strong>redux的流程</strong></p><p><img src="https://pic1.zhimg.com/50/v2-460dbc6d051b57635903769d95f55d31_hd.jpg?source=1940ef5c" alt="img"><img src="https://pic1.zhimg.com/80/v2-460dbc6d051b57635903769d95f55d31_720w.jpg?source=1940ef5c" alt="img"></p><ol><li>创建store：<br> 从redux工具中取出createStore去生成一个store。</li><li>创建一个reducer，然后将其传入到createStore中辅助store的创建。<br> reducer是一个纯函数，接收当前状态和action，返回一个状态，返回什么，store的状态就是什么，需要注意的是，不能直接操作当前状态，而是需要返回一个新的状态。<br> 想要给store创建默认状态其实就是给reducer一个参数创建默认值。</li><li>组件通过调用store.getState方法来使用store中的state，挂载在了自己的状态上。</li><li>组件产生用户操作，调用actionCreator的方法创建一个action，利用store.dispatch方法传递给reducer</li><li>reducer对action上的标示性信息做出判断后对新状态进行处理，然后返回新状态，这个时候store的数据就会发生改变， reducer返回什么状态，store.getState就可以获取什么状态。</li><li>我们可以在组件中，利用store.subscribe方法去订阅数据的变化，也就是可以传入一个函数，当数据变化的时候，传入的函数会执行，在这个函数中让组件去获取最新的状态。</li></ol>]]></content>
    
    
    <categories>
      
      <category>javascript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>javascript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>vue-router</title>
    <link href="/2021/01/20/vue-router/"/>
    <url>/2021/01/20/vue-router/</url>
    
    <content type="html"><![CDATA[<h2 id="vue-router"><a href="#vue-router" class="headerlink" title="vue-router"></a>vue-router</h2><a id="more"></a><h3 id="1、动态路由匹配"><a href="#1、动态路由匹配" class="headerlink" title="1、动态路由匹配"></a>1、动态路由匹配</h3><ul><li><p>基本使用</p><p>当我们对于不同ID各不相同的用户，都需要通过同一个组件来渲染，那么我们可以使用<code>vue-router</code>的路由路径使用<code>动态路径参数</code>来达到效果</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> router = <span class="hljs-keyword">new</span> VueRouter(&#123;<br>router: [<br><span class="hljs-comment">//动态路径参数 以：开头</span><br>&#123; <span class="hljs-attr">path</span>:<span class="hljs-string">`/user/:id`</span>, <span class="hljs-attr">component</span>:User &#125;<br>]<br>&#125;)<br></code></pre></td></tr></table></figure><p>现在，像<code>/user/foo</code>和<code>/user/bar</code>都将映射到相同的路由。</p><p>一个“路径参数”使用冒号<code>:</code>标记。当匹配到一个路由时，参数值会被设置到<code>this.$router.params</code>,可以在每个组件里使用。于是，我们可以更新<code>User</code>的模板，输出当前用户的ID</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> User =&#123;<br>template: <span class="hljs-string">&#x27;&lt;div&gt;User &#123;&#123;$route.params.id&#125;&#125;&lt;div&gt;&#x27;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>你可以在一个路由中设置多段“路径参数”，对应的值都会设置到 <code>$route.params</code> 中。例如：</p><table><thead><tr><th>模式</th><th>匹配路径</th><th>$route.params</th></tr></thead><tbody><tr><td>/user/:username</td><td>/user/evan</td><td><code>&#123; username: &#39;evan&#39; &#125;</code></td></tr><tr><td>/user/:username/post/:post_id</td><td>/user/evan/post/123</td><td><code>&#123; username: &#39;evan&#39;, post_id: &#39;123&#39; &#125;</code></td></tr></tbody></table></li><li><p>响应路由参数的变化</p><p>当使用路由参数时，例如从<code>/user/foo</code>导航到<code>/user/bar</code>，原来的组件实例会被复用。因为两个路由都渲染同一个组件，比起销毁再创建，复用则显得更加高效。不过，这也意味着组件的生命周期钩子不会再被调用。</p><p>复用组件时，想对路由参数的变化作出相应的话，你可以简单地watch(检测变化)<code>$route</code>对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> User =&#123;<br>template: <span class="hljs-string">&#x27;...&#x27;</span>,<br>watch: &#123;<br>        <span class="hljs-comment">//to表示即将要进入的那个组件，from表示从哪个组件过来的</span><br>$route(to,<span class="hljs-keyword">from</span>)&#123;<br><span class="hljs-comment">//对路由变化做出响应...</span><br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>或者使用<code>beforeRouterUpdate</code>导航守卫</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> User = &#123;<br>template: <span class="hljs-string">&#x27;...&#x27;</span>,<br><span class="hljs-function"><span class="hljs-title">beforeRouteUpdate</span>(<span class="hljs-params">to,form,next</span>)</span>&#123;<br><span class="hljs-comment">// react to route changes...</span><br><span class="hljs-comment">//don&#x27;t forget to call next()</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>path可以用<code>*</code>表示匹配，也可以匹配任意开头的路径<code>/user-*</code>,并且会将<code>*</code>匹配到的部分保存在<code>route.params.pathMatch</code>,通常用于匹配404.</p></li><li><p>高级匹配</p><p><code>vue-routr</code>使用<code>path-to-regexp</code>作为路径匹配引擎.</p></li><li><p>匹配优先级</p><p>同一个路径可以匹配多个路由，此时，匹配的优先级按照定义顺序</p></li></ul><h3 id="2、路由嵌套"><a href="#2、路由嵌套" class="headerlink" title="2、路由嵌套"></a>2、路由嵌套</h3><p>假如User中，有自己的User组件，然后在User组件的模板中，有UserProfile组件,如果需要在嵌套的出口中渲染组件，需要在<code>VueRouter</code>的参数值中使用<code>children</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> router = <span class="hljs-keyword">new</span> VueRouter(&#123;<br>router: [<br>&#123;<span class="hljs-attr">path</span>:<span class="hljs-string">&#x27;user/:id&#x27;</span> ,<span class="hljs-attr">component</span>: User,<br>children:[<br>&#123;<br><span class="hljs-comment">//当user/:id/profile匹配成功，</span><br><span class="hljs-comment">//UserProfile 会被渲染在User的&lt;router-view&gt;中</span><br>path: <span class="hljs-string">&#x27;profile&#x27;</span><br>component:UserProfile<br>&#125;,<br>&#123;<br><span class="hljs-comment">//当user/:id/profile匹配成功</span><br>path:<span class="hljs-string">&#x27;posts&#x27;</span>，<br>component:UserPosts<br>&#125;<br>]<br>&#125;<br>]<br>&#125;)<br></code></pre></td></tr></table></figure><h3 id="3、完整的导航解析流程"><a href="#3、完整的导航解析流程" class="headerlink" title="3、完整的导航解析流程"></a>3、完整的导航解析流程</h3><ol><li>导航被触发。</li><li>在失活的组件里调用 <code>beforeRouteLeave</code> 守卫。</li><li>调用全局的 <code>beforeEach</code> 守卫。</li><li>在重用的组件里调用 <code>beforeRouteUpdate</code> 守卫 (2.2+)。</li><li>在路由配置里调用 <code>beforeEnter</code>。</li><li>解析异步路由组件。</li><li>在被激活的组件里调用 <code>beforeRouteEnter</code>。</li><li>调用全局的 <code>beforeResolve</code> 守卫 (2.5+)。</li><li>导航被确认。</li><li>调用全局的 <code>afterEach</code> 钩子。</li><li>触发 DOM 更新。</li><li>调用 <code>beforeRouteEnter</code> 守卫中传给 <code>next</code> 的回调函数，创建好的组件实例会作为回调函数的参数传入。</li></ol><h3 id="4-vue-router模式"><a href="#4-vue-router模式" class="headerlink" title="4.vue-router模式"></a>4.vue-router模式</h3><h4 id="1、Hash模式："><a href="#1、Hash模式：" class="headerlink" title="1、Hash模式："></a>1、Hash模式：</h4><p><strong>vue-router 默认 hash 模式 —— 使用 URL 的 hash 来模拟一个完整的 URL，于是当 URL 改变时，页面不会重新加载。</strong> hash（#）是URL 的锚点，代表的是网页中的一个位置，单单改变#后的部分，浏览器只会滚动到相应位置，不会重新加载网页，也就是说 #是用来指导浏览器动作的，对服务器端完全无用，HTTP请求中也不会不包括#；同时每一次改变#后的部分，都会在浏览器的访问历史中增加一个记录，使用”后退”按钮，就可以回到上一个位置；所以说<strong>Hash模式通过锚点值的改变，根据不同的值，渲染指定DOM位置的不同数据</strong></p><h4 id="2、History模式："><a href="#2、History模式：" class="headerlink" title="2、History模式："></a>2、History模式：</h4><p>由于hash模式会在url中自带#，如果不想要很丑的 hash，我们可以用路由的 history 模式，只需要在配置路由规则时，加入”mode: ‘history’”,这种模式充分利用 history.pushState API 来完成 URL 跳转而无须重新加载页面。</p><p>当你使用 history 模式时，URL 就像正常的 url，例如 <a href="http://yoursite.com/user/id%EF%BC%8C%E6%AF%94%E8%BE%83%E5%A5%BD%E7%9C%8B%EF%BC%81">http://yoursite.com/user/id，比较好看！</a><br>不过这种模式要玩好，还需要后台配置支持。因为我们的应用是个单页客户端应用，如果后台没有正确的配置，当用户在浏览器直接访问 <a href="http://oursite.com/user/id">http://oursite.com/user/id</a> 就会返回 404，这就不好看了。<br>所以呢，<strong>你要在服务端增加一个覆盖所有情况的候选资源：如果 URL 匹配不到任何静态资源，则应该返回同一个 index.html 页面，这个页面就是你 app 依赖的页面。</strong></p><h3 id="5、使用路由模块来实现页面跳转的方式"><a href="#5、使用路由模块来实现页面跳转的方式" class="headerlink" title="5、使用路由模块来实现页面跳转的方式"></a>5、使用路由模块来实现页面跳转的方式</h3><p>方式1：直接修改地址栏</p><p>方式2：this.$router.push(‘路由地址’)</p><p>方式3：<code>&lt;router-link to=&quot;路由地址&quot;&gt;&lt;/router-link&gt;</code></p>]]></content>
    
    
    <categories>
      
      <category>vue.js</category>
      
    </categories>
    
    
    <tags>
      
      <tag>vue.js</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>leecode打卡本</title>
    <link href="/2021/01/19/leecode%E5%88%B7%E9%A2%98%E6%9C%AC/"/>
    <url>/2021/01/19/leecode%E5%88%B7%E9%A2%98%E6%9C%AC/</url>
    
    <content type="html"><![CDATA[<table><thead><tr><th>通过情况</th><th>题号</th><th>题目</th><th>难度</th><th>手写通过</th></tr></thead><tbody><tr><td>√</td><td>剑指 Offer 19</td><td><a href="https://leetcode-cn.com/problems/zheng-ze-biao-da-shi-pi-pei-lcof">正则表达式匹配</a></td><td>困难</td><td></td></tr><tr><td>√</td><td>剑指 Offer 43</td><td><a href="https://leetcode-cn.com/problems/1nzheng-shu-zhong-1chu-xian-de-ci-shu-lcof">1～n 整数中 1 出现的次数</a></td><td>困难</td><td></td></tr><tr><td>√</td><td>剑指 Offer 51</td><td><a href="https://leetcode-cn.com/problems/shu-zu-zhong-de-ni-xu-dui-lcof">数组中的逆序对</a></td><td>困难</td><td></td></tr><tr><td>√</td><td>剑指 Offer 37</td><td><a href="https://leetcode-cn.com/problems/xu-lie-hua-er-cha-shu-lcof">序列化二叉树</a></td><td>困难</td><td></td></tr><tr><td>√</td><td>剑指 Offer 41</td><td><a href="https://leetcode-cn.com/problems/shu-ju-liu-zhong-de-zhong-wei-shu-lcof">数据流中的中位数</a></td><td>困难</td><td></td></tr><tr><td>√</td><td>剑指 Offer 20</td><td><a href="https://leetcode-cn.com/problems/biao-shi-shu-zhi-de-zi-fu-chuan-lcof">表示数值的字符串</a></td><td>中等</td><td></td></tr><tr><td>√</td><td>剑指 Offer 67</td><td><a href="https://leetcode-cn.com/problems/ba-zi-fu-chuan-zhuan-huan-cheng-zheng-shu-lcof">把字符串转换成整数</a></td><td>中等</td><td></td></tr><tr><td>√</td><td>剑指 Offer 14- II</td><td><a href="https://leetcode-cn.com/problems/jian-sheng-zi-ii-lcof">剪绳子 II</a></td><td>中等</td><td></td></tr><tr><td>√</td><td>剑指 Offer 16</td><td><a href="https://leetcode-cn.com/problems/shu-zhi-de-zheng-shu-ci-fang-lcof">数值的整数次方</a></td><td>中等</td><td></td></tr><tr><td>√</td><td>剑指 Offer 44</td><td><a href="https://leetcode-cn.com/problems/shu-zi-xu-lie-zhong-mou-yi-wei-de-shu-zi-lcof">数字序列中某一位的数字</a></td><td>中等</td><td></td></tr><tr><td>√</td><td>剑指 Offer 04</td><td><a href="https://leetcode-cn.com/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof">二维数组中的查找</a></td><td>中等</td><td></td></tr><tr><td>√</td><td>剑指 Offer 12</td><td><a href="https://leetcode-cn.com/problems/ju-zhen-zhong-de-lu-jing-lcof">矩阵中的路径</a></td><td>中等</td><td></td></tr><tr><td>√</td><td>剑指 Offer 48</td><td><a href="https://leetcode-cn.com/problems/zui-chang-bu-han-zhong-fu-zi-fu-de-zi-zi-fu-chuan-lcof">最长不含重复字符的子字符串</a></td><td>中等</td><td></td></tr><tr><td>√</td><td>剑指 Offer 26</td><td><a href="https://leetcode-cn.com/problems/shu-de-zi-jie-gou-lcof">树的子结构</a></td><td>中等</td><td></td></tr><tr><td>√</td><td>剑指 Offer 59 - II</td><td><a href="https://leetcode-cn.com/problems/dui-lie-de-zui-da-zhi-lcof">队列的最大值</a></td><td>中等</td><td></td></tr><tr><td>√</td><td>剑指 Offer 13</td><td><a href="https://leetcode-cn.com/problems/ji-qi-ren-de-yun-dong-fan-wei-lcof">机器人的运动范围</a></td><td>中等</td><td></td></tr><tr><td>√</td><td>剑指 Offer 33</td><td><a href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-hou-xu-bian-li-xu-lie-lcof">二叉搜索树的后序遍历序列</a></td><td>中等</td><td></td></tr><tr><td>√</td><td>剑指 Offer 46</td><td><a href="https://leetcode-cn.com/problems/ba-shu-zi-fan-yi-cheng-zi-fu-chuan-lcof">把数字翻译成字符串</a></td><td>中等</td><td></td></tr><tr><td>√</td><td>剑指 Offer 60</td><td><a href="https://leetcode-cn.com/problems/nge-tou-zi-de-dian-shu-lcof">n个骰子的点数</a></td><td>中等</td><td></td></tr><tr><td>√</td><td>剑指 Offer 38</td><td><a href="https://leetcode-cn.com/problems/zi-fu-chuan-de-pai-lie-lcof">字符串的排列</a></td><td>中等</td><td></td></tr><tr><td>√</td><td>剑指 Offer 14- I</td><td><a href="https://leetcode-cn.com/problems/jian-sheng-zi-lcof">剪绳子</a></td><td>中等</td><td></td></tr><tr><td>√</td><td>剑指 Offer 45</td><td><a href="https://leetcode-cn.com/problems/ba-shu-zu-pai-cheng-zui-xiao-de-shu-lcof">把数组排成最小的数</a></td><td>中等</td><td></td></tr><tr><td>√</td><td>剑指 Offer 34</td><td><a href="https://leetcode-cn.com/problems/er-cha-shu-zhong-he-wei-mou-yi-zhi-de-lu-jing-lcof">二叉树中和为某一值的路径</a></td><td>中等</td><td></td></tr><tr><td>√</td><td>剑指 Offer 32 - III</td><td><a href="https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-iii-lcof">从上到下打印二叉树 III</a></td><td>中等</td><td></td></tr><tr><td>√</td><td>剑指 Offer 66</td><td><a href="https://leetcode-cn.com/problems/gou-jian-cheng-ji-shu-zu-lcof">构建乘积数组</a></td><td>中等</td><td></td></tr><tr><td>√</td><td>剑指 Offer 31</td><td><a href="https://leetcode-cn.com/problems/zhan-de-ya-ru-dan-chu-xu-lie-lcof">栈的压入、弹出序列</a></td><td>中等</td><td></td></tr><tr><td>√</td><td>剑指 Offer 63</td><td><a href="https://leetcode-cn.com/problems/gu-piao-de-zui-da-li-run-lcof">股票的最大利润</a></td><td>中等</td><td></td></tr><tr><td>√</td><td>剑指 Offer 49</td><td><a href="https://leetcode-cn.com/problems/chou-shu-lcof">丑数</a></td><td>中等</td><td></td></tr><tr><td>√</td><td>剑指 Offer 32 - I</td><td><a href="https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-lcof">从上到下打印二叉树</a></td><td>中等</td><td></td></tr><tr><td>√</td><td>剑指 Offer 36</td><td><a href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-yu-shuang-xiang-lian-biao-lcof">二叉搜索树与双向链表</a></td><td>中等</td><td></td></tr><tr><td>√</td><td>剑指 Offer 47</td><td><a href="https://leetcode-cn.com/problems/li-wu-de-zui-da-jie-zhi-lcof">礼物的最大价值</a></td><td>中等</td><td></td></tr><tr><td>√</td><td>剑指 Offer 07</td><td><a href="https://leetcode-cn.com/problems/zhong-jian-er-cha-shu-lcof">重建二叉树</a></td><td>中等</td><td></td></tr><tr><td>√</td><td>剑指 Offer 56 - I</td><td><a href="https://leetcode-cn.com/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-lcof">数组中数字出现的次数</a></td><td>中等</td><td></td></tr><tr><td>√</td><td>剑指 Offer 35</td><td><a href="https://leetcode-cn.com/problems/fu-za-lian-biao-de-fu-zhi-lcof">复杂链表的复制</a></td><td>中等</td><td></td></tr><tr><td>√</td><td>剑指 Offer 56 - II</td><td><a href="https://leetcode-cn.com/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-ii-lcof">数组中数字出现的次数 II</a></td><td>中等</td><td></td></tr><tr><td>√</td><td>剑指 Offer 64</td><td><a href="https://leetcode-cn.com/problems/qiu-12n-lcof">求1+2+…+n</a></td><td>中等</td><td></td></tr><tr><td>√</td><td>剑指 Offer 10- I</td><td><a href="https://leetcode-cn.com/problems/fei-bo-na-qi-shu-lie-lcof">斐波那契数列</a></td><td>简单</td><td></td></tr><tr><td>√</td><td>剑指 Offer 10- II</td><td><a href="https://leetcode-cn.com/problems/qing-wa-tiao-tai-jie-wen-ti-lcof">青蛙跳台阶问题</a></td><td>简单</td><td></td></tr><tr><td>√</td><td>剑指 Offer 58 - I</td><td><a href="https://leetcode-cn.com/problems/fan-zhuan-dan-ci-shun-xu-lcof">翻转单词顺序</a></td><td>简单</td><td></td></tr><tr><td>√</td><td>剑指 Offer 53 - II</td><td><a href="https://leetcode-cn.com/problems/que-shi-de-shu-zi-lcof">0～n-1中缺失的数字</a></td><td>简单</td><td></td></tr><tr><td>√</td><td>剑指 Offer 59 - I</td><td><a href="https://leetcode-cn.com/problems/hua-dong-chuang-kou-de-zui-da-zhi-lcof">滑动窗口的最大值</a></td><td>简单</td><td></td></tr><tr><td>√</td><td>剑指 Offer 29</td><td><a href="https://leetcode-cn.com/problems/shun-shi-zhen-da-yin-ju-zhen-lcof">顺时针打印矩阵</a></td><td>简单</td><td></td></tr><tr><td>√</td><td>剑指 Offer 61</td><td><a href="https://leetcode-cn.com/problems/bu-ke-pai-zhong-de-shun-zi-lcof">扑克牌中的顺子</a></td><td>简单</td><td>√</td></tr><tr><td>√</td><td>剑指 Offer 11</td><td><a href="https://leetcode-cn.com/problems/xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-lcof">旋转数组的最小数字</a></td><td>简单</td><td></td></tr><tr><td>√</td><td>剑指 Offer 53 - I</td><td><a href="https://leetcode-cn.com/problems/zai-pai-xu-shu-zu-zhong-cha-zhao-shu-zi-lcof">在排序数组中查找数字 I</a></td><td>简单</td><td></td></tr><tr><td>√</td><td>剑指 Offer 40</td><td><a href="https://leetcode-cn.com/problems/zui-xiao-de-kge-shu-lcof">最小的k个数</a></td><td>简单</td><td>√</td></tr><tr><td>√</td><td>剑指 Offer 65</td><td><a href="https://leetcode-cn.com/problems/bu-yong-jia-jian-cheng-chu-zuo-jia-fa-lcof">不用加减乘除做加法</a></td><td>简单</td><td></td></tr><tr><td>√</td><td>剑指 Offer 30</td><td><a href="https://leetcode-cn.com/problems/bao-han-minhan-shu-de-zhan-lcof">包含min函数的栈</a></td><td>简单</td><td>√</td></tr><tr><td>√</td><td>剑指 Offer 28</td><td><a href="https://leetcode-cn.com/problems/dui-cheng-de-er-cha-shu-lcof">对称的二叉树</a></td><td>简单</td><td>√</td></tr><tr><td>√</td><td>剑指 Offer 55 - II</td><td><a href="https://leetcode-cn.com/problems/ping-heng-er-cha-shu-lcof">平衡二叉树</a></td><td>简单</td><td></td></tr></tbody></table><table><thead><tr><th align="left"><strong>通过情况</strong></th><th align="left"><strong>题名</strong></th><th align="left"><strong>题目</strong></th><th align="center"><strong>难度</strong></th><th><strong>手写通过</strong></th></tr></thead><tbody><tr><td align="left">√</td><td align="left">剑指 Offer 18</td><td align="left"><a href="https://leetcode-cn.com/problems/shan-chu-lian-biao-de-jie-dian-lcof">删除链表的节点</a></td><td align="center">简单</td><td>√</td></tr><tr><td align="left">√</td><td align="left">剑指 Offer 42</td><td align="left"><a href="https://leetcode-cn.com/problems/lian-xu-zi-shu-zu-de-zui-da-he-lcof">连续子数组的最大和</a></td><td align="center">简单</td><td>√</td></tr><tr><td align="left">√</td><td align="left">剑指 Offer 50</td><td align="left"><a href="https://leetcode-cn.com/problems/di-yi-ge-zhi-chu-xian-yi-ci-de-zi-fu-lcof">第一个只出现一次的字符</a></td><td align="center">简单</td><td>√</td></tr><tr><td align="left">√</td><td align="left">剑指 Offer 52</td><td align="left"><a href="https://leetcode-cn.com/problems/liang-ge-lian-biao-de-di-yi-ge-gong-gong-jie-dian-lcof">两个链表的第一个公共节点</a></td><td align="center">简单</td><td>√</td></tr><tr><td align="left">√</td><td align="left">剑指 Offer 62</td><td align="left"><a href="https://leetcode-cn.com/problems/yuan-quan-zhong-zui-hou-sheng-xia-de-shu-zi-lcof">圆圈中最后剩下的数字</a></td><td align="center">简单</td><td>√</td></tr><tr><td align="left">√</td><td align="left">剑指 Offer 21</td><td align="left"><a href="https://leetcode-cn.com/problems/diao-zheng-shu-zu-shun-xu-shi-qi-shu-wei-yu-ou-shu-qian-mian-lcof">调整数组顺序使奇数位于偶数前面</a></td><td align="center">简单</td><td>√</td></tr><tr><td align="left">√</td><td align="left">剑指 Offer 57</td><td align="left"><a href="https://leetcode-cn.com/problems/he-wei-sde-liang-ge-shu-zi-lcof">和为s的两个数字</a></td><td align="center">简单</td><td>√</td></tr><tr><td align="left">√</td><td align="left">剑指 Offer 03</td><td align="left"><a href="https://leetcode-cn.com/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof">数组中重复的数字</a></td><td align="center">简单</td><td></td></tr><tr><td align="left">√</td><td align="left">剑指 Offer 39</td><td align="left"><a href="https://leetcode-cn.com/problems/shu-zu-zhong-chu-xian-ci-shu-chao-guo-yi-ban-de-shu-zi-lcof">数组中出现次数超过一半的数字</a></td><td align="center">简单</td><td>√</td></tr><tr><td align="left">√</td><td align="left">剑指 Offer 32 - II</td><td align="left"><a href="https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-ii-lcof">从上到下打印二叉树 II</a></td><td align="center">简单</td><td></td></tr><tr><td align="left">√</td><td align="left">剑指 Offer 68 - I</td><td align="left"><a href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-zui-jin-gong-gong-zu-xian-lcof">二叉搜索树的最近公共祖先</a></td><td align="center">简单</td><td></td></tr><tr><td align="left">√</td><td align="left">剑指 Offer 68 - II</td><td align="left"><a href="https://leetcode-cn.com/problems/er-cha-shu-de-zui-jin-gong-gong-zu-xian-lcof">二叉树的最近公共祖先</a></td><td align="center">简单</td><td></td></tr><tr><td align="left">√</td><td align="left">剑指 Offer 57 - II</td><td align="left"><a href="https://leetcode-cn.com/problems/he-wei-sde-lian-xu-zheng-shu-xu-lie-lcof">和为s的连续正数序列</a></td><td align="center">简单</td><td>√</td></tr><tr><td align="left">√</td><td align="left">剑指 Offer 09</td><td align="left"><a href="https://leetcode-cn.com/problems/yong-liang-ge-zhan-shi-xian-dui-lie-lcof">用两个栈实现队列</a></td><td align="center">简单</td><td>√</td></tr><tr><td align="left">√</td><td align="left">剑指 Offer 15</td><td align="left"><a href="https://leetcode-cn.com/problems/er-jin-zhi-zhong-1de-ge-shu-lcof">二进制中1的个数</a></td><td align="center">简单</td><td>√</td></tr><tr><td align="left">√</td><td align="left">剑指 Offer 25</td><td align="left"><a href="https://leetcode-cn.com/problems/he-bing-liang-ge-pai-xu-de-lian-biao-lcof">合并两个排序的链表</a></td><td align="center">简单</td><td>√</td></tr><tr><td align="left">√</td><td align="left">剑指 Offer 54</td><td align="left"><a href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-di-kda-jie-dian-lcof">二叉搜索树的第k大节点</a></td><td align="center">简单</td><td>√</td></tr><tr><td align="left">√</td><td align="left">剑指 Offer 24</td><td align="left"><a href="https://leetcode-cn.com/problems/fan-zhuan-lian-biao-lcof">反转链表</a></td><td align="center">简单</td><td>√</td></tr><tr><td align="left">√</td><td align="left">剑指 Offer 06</td><td align="left"><a href="https://leetcode-cn.com/problems/cong-wei-dao-tou-da-yin-lian-biao-lcof">从尾到头打印链表</a></td><td align="center">简单</td><td>√</td></tr><tr><td align="left">√</td><td align="left">剑指 Offer 05</td><td align="left"><a href="https://leetcode-cn.com/problems/ti-huan-kong-ge-lcof">替换空格</a></td><td align="center">简单</td><td>√</td></tr><tr><td align="left">√</td><td align="left">剑指 Offer 17</td><td align="left"><a href="https://leetcode-cn.com/problems/da-yin-cong-1dao-zui-da-de-nwei-shu-lcof">打印从1到最大的n位数</a></td><td align="center">简单</td><td>√</td></tr><tr><td align="left">√</td><td align="left">剑指 Offer 22</td><td align="left"><a href="https://leetcode-cn.com/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof">链表中倒数第k个节点</a></td><td align="center">简单</td><td>√</td></tr><tr><td align="left">√</td><td align="left">剑指 Offer 55 - I</td><td align="left"><a href="https://leetcode-cn.com/problems/er-cha-shu-de-shen-du-lcof">二叉树的深度</a></td><td align="center">简单</td><td>√</td></tr><tr><td align="left">√</td><td align="left">剑指 Offer 27</td><td align="left"><a href="https://leetcode-cn.com/problems/er-cha-shu-de-jing-xiang-lcof">二叉树的镜像</a></td><td align="center">简单</td><td>√</td></tr><tr><td align="left">√</td><td align="left">剑指 Offer 58 - II</td><td align="left"><a href="https://leetcode-cn.com/problems/zuo-xuan-zhuan-zi-fu-chuan-lcof">左旋转字符串</a></td><td align="center">简单</td><td>√</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>map、reduce、filter等高阶函数</title>
    <link href="/2021/01/19/%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0/"/>
    <url>/2021/01/19/%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<p>forEach、map、reduce、filter高阶函数</p><p>高阶函数，指的是JavaScript的函数其实都指向某个变量。既然变量可以指向函数，函数的参数能接收变量，那么一个函数就可以接收另一个函数作为参数，这种函数就称为高阶函数。</p><a id="more"></a><h5 id="1、forEach"><a href="#1、forEach" class="headerlink" title="1、forEach"></a>1、forEach</h5><p>其中forEach方法中的function回调支持三个参数，第一个是遍历的数组内容；第二个的应用的数组索引，第三个是数组本身。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">[].forEach(funciton(value,index,array))<br></code></pre></td></tr></table></figure><p>同时forEach也是可以第一个参数传回调，第二个参数传this，去改变，不传则默认为window，严格模式下将会是undefined。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> arr = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]<br><span class="hljs-keyword">delete</span> arr[<span class="hljs-number">1</span>]; <span class="hljs-comment">//移除2</span><br><span class="hljs-built_in">console</span>.log(arr)<span class="hljs-comment">// 1，，3</span><br>array.forEach(alert) <span class="hljs-comment">//弹出1和3</span><br></code></pre></td></tr></table></figure><p>同时forEach是不会遍历空元素的。</p><h5 id="2、map"><a href="#2、map" class="headerlink" title="2、map"></a>2、map</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js">array.map(callback,[ thisobject ])<br>[].map(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">value, index, array</span>)</span>&#123;<br><span class="hljs-comment">//...</span><br>&#125;)<br></code></pre></td></tr></table></figure><p>就是将原来的数组映射成新的数组</p><p>callback需要return值，不然将全部是undefined</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">Array</span>.prototype.mymap = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">fn, context</span>) </span>&#123;  <span class="hljs-comment">// 手写</span><br>    <span class="hljs-keyword">let</span> arr = [];<br>    <span class="hljs-keyword">let</span> _this = context ? contet : <span class="hljs-built_in">this</span>;<br>    <span class="hljs-keyword">if</span> (fn <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Function</span>) &#123;<br>        _this.forEach(<span class="hljs-function">(<span class="hljs-params">item, _this</span>) =&gt;</span> &#123;<br>            arr.push(fn.call(_this, item));<br>        &#125;)<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">throw</span>  <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">&quot;$&#123;fn&#125; is not a function&quot;</span>)<br>    &#125;<br>    <span class="hljs-keyword">return</span> arr;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="3、filter"><a href="#3、filter" class="headerlink" title="3、filter"></a>3、filter</h5><p>这就是一个过滤器，语法类似mapjsilter的callback需要返回布尔值，true表示通过的，false表示不需要的</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">Array</span>.prototype.myfilter = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">fn, context</span>) </span>&#123;  <span class="hljs-comment">// 手写</span><br>    <span class="hljs-keyword">let</span> arr = [];<br>    <span class="hljs-keyword">let</span> _this = context ? context : <span class="hljs-built_in">this</span>;<br>    <span class="hljs-keyword">if</span> (fn <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Function</span>) &#123;<br>        _this.forEach(<span class="hljs-function"><span class="hljs-params">element</span> =&gt;</span> &#123;<br>            <span class="hljs-keyword">if</span> (fn(element))<br>                arr.push(element);<br>        &#125;);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">&quot;func is not a function&quot;</span>)<br>    &#125;<br>    <span class="hljs-keyword">return</span> arr;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="4、reduce"><a href="#4、reduce" class="headerlink" title="4、reduce"></a>4、reduce</h5><p>功能是用于迭代的</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">arr.reduce(callback,[initialValue])<br></code></pre></td></tr></table></figure><p>其中callback可以包含四个参数</p><ul><li>previous：上次调用回调返回的结果，或者是提供的初始值（initialValue）</li><li>currentValue(数组当前被处理的元素)</li><li>index(当前元素在数组中的引用)</li><li>array(调用reduce的数组)</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//数组去重</span><br><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">4</span>,<span class="hljs-number">1</span>]<br><span class="hljs-keyword">let</span> newArr = arr.reduce(<span class="hljs-function">(<span class="hljs-params">pre,cur</span>)=&gt;</span>&#123;<br><span class="hljs-keyword">if</span>(!pre.includes(cur))<br><span class="hljs-keyword">return</span> pre.concat(cur);<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> pre;<br>&#125;,[])<br><br><span class="hljs-comment">//将二维维数组转换为一维</span><br><span class="hljs-keyword">let</span> arr = [[<span class="hljs-number">0</span>,<span class="hljs-number">1</span>], [<span class="hljs-number">2</span>,<span class="hljs-number">3</span>], [<span class="hljs-number">4</span>,<span class="hljs-number">5</span>]]<br><span class="hljs-keyword">let</span> newArr = arr.reduce(<span class="hljs-function">(<span class="hljs-params">pre,cur</span>)=&gt;</span>&#123;<br>    <span class="hljs-keyword">return</span> pre.concat(cur)<br>&#125;,[])<br><span class="hljs-built_in">console</span>.log(newArr);<br><br><span class="hljs-comment">//来改进一下，把多维数组转换成一维数组,递归实现</span><br><span class="hljs-keyword">let</span> arr = [[<span class="hljs-number">0</span>,<span class="hljs-number">1</span>],[<span class="hljs-number">2</span>,<span class="hljs-number">3</span>],[<span class="hljs-number">4</span>,[<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>]]]<br><span class="hljs-keyword">const</span> newArr = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">arr</span>)</span>&#123;<br>    <span class="hljs-keyword">return</span> arr.reduce(<span class="hljs-function">(<span class="hljs-params">pre,cur</span>)=&gt;</span>pre.concat(<span class="hljs-built_in">Array</span>.isArray(cur)?newArr(cur):cur),[])<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="5、flat"><a href="#5、flat" class="headerlink" title="5、flat"></a>5、flat</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">Array</span>.prototype.flat(level) <span class="hljs-comment">//将数组拉平，level可以写入拉平的层次</span><br><br><span class="hljs-comment">//如果不管多少层嵌套都要转换成一维数组，可以使用Infinity关键字作为参数</span><br>arr.flat(<span class="hljs-literal">Infinity</span>)<br><br><span class="hljs-comment">//如果原来数组有空位，会跳过空位</span><br>[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>].flat() <span class="hljs-comment">//[1,2,4,5]  不传参数默认是一层</span><br></code></pre></td></tr></table></figure><p>同时还有一个flatMap方法，相当于对原数组每个元素执行一次map，再拉平</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//日常手写一遍</span><br><span class="hljs-built_in">Array</span>.prototype.myflat = <span class="hljs-function"><span class="hljs-title">fucntion</span>(<span class="hljs-params">d=<span class="hljs-number">1</span></span>)</span>&#123;<br><span class="hljs-keyword">let</span> arr = <span class="hljs-built_in">this</span><br><span class="hljs-keyword">return</span> d&gt;<span class="hljs-number">0</span>?reduce(<span class="hljs-function">(<span class="hljs-params">acc,cur</span>) =&gt;</span> &#123;<br>acc.concat(<span class="hljs-built_in">Array</span>.isArray(val)?val.myflat(d-<span class="hljs-number">1</span>):val)<br>&#125;,[]):arr.slice()<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="6、手写instanceof"><a href="#6、手写instanceof" class="headerlink" title="6、手写instanceof"></a>6、手写instanceof</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">instance_of</span>(<span class="hljs-params">L, R</span>) </span>&#123;<br>    <span class="hljs-keyword">const</span> baseType = [<span class="hljs-string">&#x27;string&#x27;</span>, <span class="hljs-string">&#x27;number&#x27;</span>, <span class="hljs-string">&#x27;boolean&#x27;</span>, <span class="hljs-string">&#x27;undefined&#x27;</span>, <span class="hljs-string">&#x27;symbol&#x27;</span>]<br>    <span class="hljs-keyword">if</span> (baseType.includes(<span class="hljs-keyword">typeof</span> (L))) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">let</span> RP = R.prototype;<br>    L = L.__proto__;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>        <span class="hljs-keyword">if</span> (L === <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (L === RP) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        L = L.__proto__;<br>    &#125;<br>&#125;<br><span class="hljs-built_in">console</span>.log(instance_of(<span class="hljs-built_in">Array</span>, <span class="hljs-built_in">Object</span>))<br><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Array</span> <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Object</span>)<br></code></pre></td></tr></table></figure><h5 id="7、call、apply、bind"><a href="#7、call、apply、bind" class="headerlink" title="7、call、apply、bind"></a>7、call、apply、bind</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//call</span><br><span class="hljs-built_in">Function</span>.prototype._call = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">obj</span>)</span>&#123;<br>    <span class="hljs-keyword">var</span> _obj = obj ? <span class="hljs-built_in">Object</span>(obj) : <span class="hljs-built_in">window</span><br>    _obj.fn = <span class="hljs-built_in">this</span>;<br>    <span class="hljs-keyword">var</span> argArr = <span class="hljs-built_in">Array</span>.from(<span class="hljs-built_in">arguments</span>).slice(<span class="hljs-number">1</span>)<br>    _obj.fn(...argArr);<br>    <span class="hljs-keyword">delete</span> _obj.fn<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">test</span>(<span class="hljs-params">X,y,z</span>)</span>&#123;<br>    <span class="hljs-built_in">console</span>.log(X+y+z)<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.name);<br>&#125;<br><span class="hljs-keyword">var</span> obj = &#123;<br>    name:<span class="hljs-string">&#x27;啥名字&#x27;</span><br>&#125;<br>test._call(obj,<span class="hljs-string">&#x27;啥&#x27;</span>,<span class="hljs-string">&#x27;名&#x27;</span>,<span class="hljs-string">&#x27;字&#x27;</span>);<br><span class="hljs-built_in">console</span>.log(obj)<br><br><span class="hljs-comment">//apply</span><br><span class="hljs-built_in">Function</span>.prototype._apply = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">obj, argArr</span>) </span>&#123;<br>    <span class="hljs-comment">// 如果obj不存在则默认window对象</span><br>    <span class="hljs-keyword">var</span> _obj = obj ? obj : <span class="hljs-built_in">window</span><br>    <span class="hljs-comment">// 给_obj添加fn方法</span><br>    _obj.fn = <span class="hljs-built_in">this</span><br>    <span class="hljs-comment">// 获取第二个数组参数</span><br>    <span class="hljs-keyword">var</span> arg = []<br>    <span class="hljs-comment">// 当这个参数数组不存在或者为空时，直接执行函数，否则把数组拆分后传递给函数并执行</span><br>    <span class="hljs-keyword">if</span> (!argArr || argArr.length == <span class="hljs-number">0</span>) &#123;<br>        _obj.fn()<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; argArr.length; i++) &#123;<br>            arg.push(argArr[i])<br>        &#125;<br>        <span class="hljs-comment">//eval(&quot;_obj.fn(&quot; + arg + &quot;)&quot;)</span><br>        _obj.fn(...arg);<br>    &#125;<br>    <span class="hljs-comment">// 移除这个方法</span><br>    <span class="hljs-keyword">delete</span> _obj.fn<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">test</span>(<span class="hljs-params">x,y,z</span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(x+y+z);<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.name);<br>  &#125;<br>  <span class="hljs-keyword">var</span> obj = &#123;<br>    name: <span class="hljs-string">&#x27;前端菜鸟库&#x27;</span><br>  &#125;<br>  test._apply(obj, [<span class="hljs-string">&#x27;菜鸟&#x27;</span>, <span class="hljs-string">&#x27;库&#x27;</span>,<span class="hljs-string">&#x27;233&#x27;</span>]) <span class="hljs-comment">// 前端菜鸟库</span><br>  <span class="hljs-built_in">console</span>.log(obj) <span class="hljs-comment">// &#123;name: &quot;前端菜鸟库&quot;&#125;</span><br><br><span class="hljs-comment">//bind</span><br><span class="hljs-built_in">Function</span>.prototype._bind = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">obj</span>) </span>&#123;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-keyword">typeof</span>(<span class="hljs-built_in">this</span>) !== <span class="hljs-string">&quot;function&quot;</span>)&#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">&quot;调用_bind方法的必须为函数&quot;</span>)<br>    &#125;<br>    <span class="hljs-keyword">var</span> args = <span class="hljs-built_in">Array</span>.prototype.slice.call(<span class="hljs-built_in">arguments</span>,<span class="hljs-number">1</span>)<br>    <span class="hljs-keyword">var</span> _fn = <span class="hljs-built_in">this</span>;<br>    <span class="hljs-keyword">var</span> bindFn = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br>        <span class="hljs-keyword">var</span> newArgs = <span class="hljs-built_in">Array</span>.prototype.slice.call(<span class="hljs-built_in">arguments</span>)<br>        <span class="hljs-keyword">var</span> _obj = <span class="hljs-built_in">this</span>.constructor === _fn ? <span class="hljs-built_in">this</span>:obj<br>        _fn.apply(_obj,newArgs.concat(args))<br>    &#125;<br>     <span class="hljs-keyword">var</span> ProtoFn = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;&#125;<br>     ProtoFn.prototype = _fn.prototype<br>     bindFn.prototype = <span class="hljs-keyword">new</span> ProtoFn()<br>    <span class="hljs-keyword">return</span> bindFn;<br>&#125;<br><br><span class="hljs-keyword">var</span> obj = &#123;<br>    name: <span class="hljs-string">&quot;前端菜鸟库&quot;</span><br>  &#125;<br>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">test</span>(<span class="hljs-params">x,y,z</span>) </span>&#123;<br>    <span class="hljs-built_in">this</span>.age = <span class="hljs-string">&#x27;18&#x27;</span><br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.name) <span class="hljs-comment">// 前端菜鸟库</span><br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;x:&#x27;</span>,x,<span class="hljs-string">&#x27;y:&#x27;</span>,y,<span class="hljs-string">&#x27;z:&#x27;</span>,z) <span class="hljs-comment">// x: 1 y: 2 z: 3</span><br>    <span class="hljs-built_in">console</span>.log(x+y+z) <span class="hljs-comment">// 6</span><br>  &#125;<br>  test.prototype.book = <span class="hljs-string">&quot;JS&quot;</span><br>  <span class="hljs-keyword">var</span> Bound = test._bind(obj, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>)<br>  Bound()<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>javascript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>javascript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JS继承学习笔记</title>
    <link href="/2021/01/16/JS%E7%BB%A7%E6%89%BF%E8%AF%A6%E8%A7%A3/"/>
    <url>/2021/01/16/JS%E7%BB%A7%E6%89%BF%E8%AF%A6%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<p>很多的OO语言都支持：接口继承和实现继承。接口继承只继承方法签名，而实现继承则继承实际的方法。由于函数没有签名，在ECMASript中只实现了实现继承，而且其实实现继承主要是依赖原型链来实现的。</p><a id="more"></a><h4 id="1、原型链"><a href="#1、原型链" class="headerlink" title="1、原型链"></a>1、原型链</h4><p>ECMAScript中描述了原型链的概念，并将原型链作为实现继承的主要方式。其主要思想是利用原型让一个引用类型继承另一个引用类型的属性和方法，简单回顾一下构造函数、原型和实例的关系：每一个构造函数都有一个原型对象，原型对象都包含一个指向一个构造函数的指针，而实例都包含一个指向原型对象的内部指针。假如我们让原型对象等于另一个类型的实例，那么此时原型对象将包含一个指向另一个原型的指针，相应地，另一个原型中也包含着一个指向另一个构造函数的指针。假如另一个原型又是另一个类型的实例，那么上述关系依然成立，如此层层递进，这样就形成了实例域原型的链条。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 实现原型链有一种基本模式</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">SuperType</span>(<span class="hljs-params"></span>)</span>&#123;<br><span class="hljs-built_in">this</span>.property = <span class="hljs-literal">true</span>;<br>&#125;<br><br>SuperType.prototype.getSuperValue = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.property;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">SubType</span>(<span class="hljs-params"></span>)</span>&#123;<br>    <span class="hljs-built_in">this</span>.subproperty = <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-comment">//继承了Supertype,实现的本质是重写原型对象</span><br>SubType.prototype = <span class="hljs-keyword">new</span> SuberType();<br><br>SubType.prototype.getSubValue = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>)</span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.subproperty;<br>&#125;<br><br><span class="hljs-keyword">var</span> instance = <span class="hljs-keyword">new</span> SubType();<br>alert(instance.getSuperValue());<span class="hljs-comment">//true</span><br></code></pre></td></tr></table></figure><p>现在instance.constructor现在指向的是SuperType,这是因为原来SubType.prototype中的constructor被重写的缘故（实际上是subType的原型指向了另一个对象SuperType的原型，而原型对象的构造函数指向的是SuperType）。</p><p>通过原型链，就扩展了原型搜索机制。当然所有的引用类型都继承自Object.</p><p><code>注意：</code>需要谨慎地定义方法，子类型有时候需要覆盖超类型中的某个方法，或者需要添加超类型中不存在的某个方法。但不管怎样，<strong>给原型添加方法的代码一定要放在替换原型的语句之后</strong>。来看下面的例子</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">SuperType</span>(<span class="hljs-params"></span>)</span>&#123;<br><span class="hljs-built_in">this</span>.property = <span class="hljs-literal">true</span>;<br>&#125;<br><br>SuperType.prototype.getSuperValue = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.prototype;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">SubType</span>(<span class="hljs-params"></span>)</span>&#123;<br>    <span class="hljs-built_in">this</span>.subproperty = <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-comment">//继承了SubperType</span><br>SubType.prototype = <span class="hljs-keyword">new</span> SuperType();<br><br><span class="hljs-comment">//添加新方法</span><br>SubType.prototype.getSubValue = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>)</span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.subproperty;<br>&#125;<br><br><span class="hljs-comment">//重写超类型中的方法</span><br>SubType.prototype.getSuperValue = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>)</span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-keyword">var</span> instance = <span class="hljs-keyword">new</span> SubType();<br>alert(instance.getSuperValue()); <span class="hljs-comment">//false</span><br></code></pre></td></tr></table></figure><p>同时<code>注意</code>在通过原型链实现继承时，不能使用对象字面量创建原型方法。因为这个方法会重写原型链。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">SuperType</span>(<span class="hljs-params"></span>)</span>&#123;<br><span class="hljs-built_in">this</span>.property = <span class="hljs-literal">true</span>;<br>&#125;<br><br>SuperType.prototype.getSuperValue = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.prototype;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">SubType</span>(<span class="hljs-params"></span>)</span>&#123;<br>    <span class="hljs-built_in">this</span>.subproperty = <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-comment">//继承了SubperType</span><br>SubType.prototype = <span class="hljs-keyword">new</span> SuperType();<br><br><span class="hljs-comment">//使用字面量添加新方法，会导致上一行代码无效</span><br>SubType.prototype = &#123;<br>    getSubValue : <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>)</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.subproperty;<br>    &#125;,<br>    someOtherMethod : <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>)</span>&#123;<br>        reutrn <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">var</span> instance = <span class="hljs-keyword">new</span> SubType();<br>alert(insdtance.getSuperValue();) <span class="hljs-comment">//error!</span><br></code></pre></td></tr></table></figure><p>以上代码展示了刚刚把SuperType的实例赋值给原型，紧接着又将原型替换成一个对象字面量而导致的问题。由于现在的原型包含的是一个Object的实例，而非SuperType的实例，因此我们设想中的原型链已经被切断——SuperType和SubType之间已经没有关系了。</p><h1 id="1-借助构造函数实现继承"><a href="#1-借助构造函数实现继承" class="headerlink" title="1.借助构造函数实现继承"></a>1.借助构造函数实现继承</h1><p>原理：通过call()函数修改 this 指向，从而实现将父类属性挂载到子类实例中。</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">parent1</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">this</span>.name = <span class="hljs-string">&#x27;parent1&#x27;</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">child1</span>(<span class="hljs-params"></span>) </span>&#123;<br>    parent1.call(<span class="hljs-built_in">this</span>);<br>    <span class="hljs-built_in">this</span>.type = <span class="hljs-string">&#x27;child1&#x27;</span>;<br>&#125;<br><span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">new</span> child1);<br></code></pre></td></tr></table></figure><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p> 打印结果：</p><p><img src="https://images2017.cnblogs.com/blog/813088/201712/813088-20171206164510722-1563134517.png" alt="img"></p><p>当我们给父类 parent1 的 prototype 属性添加say方法后，但是在 child1 中是获取不到的。</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">parent1</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">this</span>.name = <span class="hljs-string">&#x27;parent1&#x27;</span>;<br>&#125;<br>parent1.prototype.say = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;hello&#x27;</span>);<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">child1</span>(<span class="hljs-params"></span>) </span>&#123;<br>    parent1.call(<span class="hljs-built_in">this</span>);<br>    <span class="hljs-built_in">this</span>.type = <span class="hljs-string">&#x27;child1&#x27;</span>;<br>&#125;<br><span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">new</span> child1, <span class="hljs-keyword">new</span> child1().say());<br></code></pre></td></tr></table></figure><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>打印结果：</p><p><img src="https://images2017.cnblogs.com/blog/813088/201712/813088-20171206164441847-1575139900.png" alt="img"></p><p>所以.借助构造函数实现继承，只能实现部分继承；如果父类属性都在构造函数中，则能够实现全部继承，如果父类原型对象上还有方法，则子类是继承不到的。</p><h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><p>   优点：<br>      1.只调用一次父类的构造函数,避免了在子类原型上创建不必要的，多余的属性 。<br>      2.原型链保持不变。<br>   缺点：只能实现部分继承；如果父类属性都在构造函数中，则能够实现全部继承，如果父类原型对象上还有方法，则子类是继承不到的。</p><h1 id="2-借助原型链实现继承（最通用的方式）"><a href="#2-借助原型链实现继承（最通用的方式）" class="headerlink" title="2.借助原型链实现继承（最通用的方式）"></a>2.借助原型链实现继承（最通用的方式）</h1><p>原理：将子类的prototype属性赋值为父类实例对象，则子类的_proto_属性继承父类。</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">parent2</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">this</span>.name = <span class="hljs-string">&#x27;parent2&#x27;</span>;<br>    <span class="hljs-built_in">this</span>.play = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br>&#125;<br>parent2.prototype.say = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;hello&#x27;</span>);<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">child2</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">this</span>.type = <span class="hljs-string">&#x27;child2&#x27;</span>;<br>&#125;<br>child2.prototype = <span class="hljs-keyword">new</span> parent2();<br><span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">new</span> child2);<br><span class="hljs-keyword">var</span> p1 = <span class="hljs-keyword">new</span> child2();<br><span class="hljs-keyword">var</span> p2 = <span class="hljs-keyword">new</span> child2();<br><span class="hljs-built_in">console</span>.log(p1.say());<br><span class="hljs-built_in">console</span>.log(p1.play, p2.play);<br>p1.play.push(<span class="hljs-number">4</span>);<br><span class="hljs-built_in">console</span>.log(p1, p2);<br><span class="hljs-built_in">console</span>.log(p1.play, p2.play);<br></code></pre></td></tr></table></figure><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>打印结果：</p><p><img src="https://images2017.cnblogs.com/blog/813088/201712/813088-20171206173534378-877742698.png" alt="img"></p><p>注意：</p><p>1.在第一种继承方式中，子类是继承不到父类 prototype 属性的内容的，但现在可以继承到了。</p><p>2.其实小颖只执行了 p1.play.push(4) ，然而 p2.play 的值也跟着变化了。</p><p>这其实都是因为  child2.prototype = new parent2()，他们的 <strong>proto</strong> 都继承了父类parent2 的所有属性。虽然表面上 p1.play.push(4)  看起来像是只改变了 p1 的 play 属性，但其实是改变了父类  parent2 的 play 属性，而p1,p2继承了 parent2 ，所以p1,p2同时发生变化。</p><h3 id="总结：-1"><a href="#总结：-1" class="headerlink" title="总结："></a>总结：</h3><p>   优点：父类的方法(getName)得到了复用。<br>   缺点：重写子类的原型 等于 父类的一个实例，（父类的实例属性变成子类的原型属性）如果父类包含引用类型的属性，那么子类所有实例都会共享该属性 （包含引用类型的<em>原型</em>属性会被实例共享）。</p><h1 id="3-组合方式"><a href="#3-组合方式" class="headerlink" title="3.组合方式"></a>3.组合方式</h1><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">parent3</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">this</span>.name = <span class="hljs-string">&#x27;parent3&#x27;</span>;<br>    <span class="hljs-built_in">this</span>.play = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">child3</span>(<span class="hljs-params"></span>) </span>&#123;<br>    parent3.call(<span class="hljs-built_in">this</span>);<br>    <span class="hljs-built_in">this</span>.type = <span class="hljs-string">&#x27;child3&#x27;</span>;<br>&#125;<br>child3.prototype = <span class="hljs-keyword">new</span> parent3();<br><span class="hljs-keyword">var</span> p3 = <span class="hljs-keyword">new</span> child3();<br><span class="hljs-keyword">var</span> p4 = <span class="hljs-keyword">new</span> child3();<br><span class="hljs-built_in">console</span>.log(p3.play, p4.play);<br>p3.play.push(<span class="hljs-number">4</span>);<br><span class="hljs-built_in">console</span>.log(p3,p4);<br><span class="hljs-built_in">console</span>.log(p3.play, p4.play);<br></code></pre></td></tr></table></figure><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>打印结果：</p><p><img src="https://images2017.cnblogs.com/blog/813088/201712/813088-20171206171316628-260342324.png" alt="img"></p><p>注意：</p><p>在上面的结果中，大家有没有发现，同样只给  p3.play.push(4) ，但是只有p3一个变了，但p4没有变，其实大家通过小颖用红框框起来的地方，大就会明白，为什么p3、p4的 <strong>proto</strong> 都继承了父类parent2 的属性，为什么修改p3，p4，这次p4却没有变化。</p><h3 id="总结：-2"><a href="#总结：-2" class="headerlink" title="总结："></a>总结：</h3><p>   优点：继承了上述两种方式的优点，摒弃了缺点，复用了方法，子类又有各自的属性。<br>   缺点：因为父类构造函数被执行了两次，子类的原型对象(Sub.prototype)中也有一份父类的实例属性，而且这些属性会被子类实例(sub1,sub2)的属性覆盖掉，也存在内存浪费。</p><h1 id="4-组合继承的优化1"><a href="#4-组合继承的优化1" class="headerlink" title="4.组合继承的优化1"></a>4.组合继承的优化1</h1><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">parent4</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">this</span>.name = <span class="hljs-string">&#x27;parent4&#x27;</span>;<br>    <span class="hljs-built_in">this</span>.play = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">child4</span>(<span class="hljs-params"></span>) </span>&#123;<br>    parent4.call(<span class="hljs-built_in">this</span>);<br>    <span class="hljs-built_in">this</span>.type = <span class="hljs-string">&#x27;child4&#x27;</span>;<br>&#125;<br>child4.prototype = parent4.prototype;<br><span class="hljs-keyword">var</span> p5 = <span class="hljs-keyword">new</span> child4();<br><span class="hljs-keyword">var</span> p6 = <span class="hljs-keyword">new</span> child4();<br><span class="hljs-built_in">console</span>.log(p5, p6);<br><span class="hljs-built_in">console</span>.log(p5 <span class="hljs-keyword">instanceof</span> child4, p5 <span class="hljs-keyword">instanceof</span> parent4);<br><span class="hljs-built_in">console</span>.log(p5.constructor);<br></code></pre></td></tr></table></figure><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>打印结果：</p><p><img src="https://images2017.cnblogs.com/blog/813088/201712/813088-20171206174856831-1511031915.png" alt="img"></p><p>注意：</p><p>instanceof 和 constructor 都是用来判断一个实例对象是不是这个构造函数的实例的。<br>不同点是：用constructor 比instanceof 更严谨，例如如果 A 继承 B，B 继承 C，A 生成的实例对象，用 instanceof 判断与 A、B、C 的关系，都是 true。所以无法区分这个到底是 A、B、C 谁生成的实例。而constructor 是原型对象的一个属性，并且这个属性的值是指向创建当前实例的对象的。</p><p>console.log(p5 instanceof child4, p5 instanceof parent4); 执行结果一样，而且 p5.constructor 竟然不是 child4 而是 parent4。</p><h1 id="5-组合继承的优化2-——寄生组合式继承"><a href="#5-组合继承的优化2-——寄生组合式继承" class="headerlink" title="5.组合继承的优化2 ——寄生组合式继承"></a>5.组合继承的优化2 ——寄生组合式继承</h1><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">parent5</span>(<span class="hljs-params"></span>) </span>&#123;<br>     <span class="hljs-built_in">this</span>.name = <span class="hljs-string">&#x27;parent5&#x27;</span>;<br>     <span class="hljs-built_in">this</span>.play = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br> &#125;<br><br> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">child5</span>(<span class="hljs-params"></span>) </span>&#123;<br>     parent5.call(<span class="hljs-built_in">this</span>);<br>     <span class="hljs-built_in">this</span>.type = <span class="hljs-string">&#x27;child5&#x27;</span>;<br> &#125;<br> child5.prototype = <span class="hljs-built_in">Object</span>.create(parent5.prototype);<br> child5.prototype.constructor = child5;<br> <span class="hljs-keyword">var</span> p7 = <span class="hljs-keyword">new</span> child5();<br> <span class="hljs-keyword">var</span> p8 = <span class="hljs-keyword">new</span> child5();<br> <span class="hljs-built_in">console</span>.log(p7, p8);<br> <span class="hljs-built_in">console</span>.log(p7.constructor);<br></code></pre></td></tr></table></figure><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p><p>打印结果：</p><p><img src="https://images2017.cnblogs.com/blog/813088/201712/813088-20171206180455003-1045333029.png" alt="img"></p><h3 id="总结：-3"><a href="#总结：-3" class="headerlink" title="总结："></a>总结：</h3><p>  组合继承的缺点就是在继承父类方法的时候调用了父类构造函数，从而造成内存浪费，并且找不到实例对象真正的 constructor 。</p><p>  那在复用父类方法的时候，使用Object.create方法也可以达到目的，没有调用父类构造函数，并将子类的 prototype.constructor 属性赋值为自己本身，则问题完美解决。</p>]]></content>
    
    
    <categories>
      
      <category>javascript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>javascript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>广州4399一面面试</title>
    <link href="/2021/01/14/%E5%B9%BF%E5%B7%9E4399%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/"/>
    <url>/2021/01/14/%E5%B9%BF%E5%B7%9E4399%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/</url>
    
    <content type="html"><![CDATA[<p>令人窒息的面试过程，我发现我还不能够掌握面试的主动权，可能就是没有一个点是可以值得深挖的吧，以至于不能长久的去讨论。发现自己可能知道如何引导，但是具体的展开还是需要多学习。</p><h5 id="1、http的状态码"><a href="#1、http的状态码" class="headerlink" title="1、http的状态码"></a>1、http的状态码</h5><ul><li>1XX:指示信息–表示请求已经被接受，继续处理</li><li>2XX:成功–表示已经被成功接受、理解、接受</li><li>3XX:重定向–要完成请求必须进行更进一步的操作</li><li>4XX:客户端错误–请求有语法错误或请求无法实现</li><li>5XX:服务器错误–服务器未能实现合法的请求</li></ul><h5 id="2、cookie、session"><a href="#2、cookie、session" class="headerlink" title="2、cookie、session"></a>2、cookie、session</h5><p>Cookies是通过在客户端记录信息确认用户身份，Session通过在服务器端记录信息来确认用户信息。</p><table><thead><tr><th>字段名</th><th>含义</th></tr></thead><tbody><tr><td>name</td><td>字段为一个cookie的名称</td></tr><tr><td>value</td><td>字段为一个cookie的值</td></tr><tr><td>domain</td><td>字段为可以访问此cookie的域名，非顶级域名，是二级域名或三级域名</td></tr><tr><td>path</td><td>字段为可以访问此cookie的页面路径。</td></tr><tr><td>expires/Max-Age</td><td>此字段为cookie的超时事件，到此之后，此cookie失效，不设置的话默认值是Session（即整个浏览器关闭后）</td></tr><tr><td>size</td><td>此cookie的大小</td></tr><tr><td>http</td><td>字段为httponly属性，如果此属性为true,则只有在http请求头中会带有此cookie的信息，而不能通过document.cookie来访问此cookie</td></tr><tr><td>secure</td><td>字段cookie的httponly属性。若此属性为true,则只有在http请求头中会带有此cookie</td></tr></tbody></table><h5 id="3、跨域的解决方案"><a href="#3、跨域的解决方案" class="headerlink" title="3、跨域的解决方案"></a>3、跨域的解决方案</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//在www.a.com域名写下如下代码，去请求www.b.com域名的数据</span><br>&lt;script&gt;<br>    <span class="hljs-keyword">var</span> script = <span class="hljs-built_in">document</span>.creatElement(<span class="hljs-string">&#x27;script&#x27;</span>);<br>    script.type = <span class="hljs-string">&#x27;text/javascript&#x27;</span>;<br>    script.src = <span class="hljs-string">&#x27;http://www.b.com/getdata?callback=demo&#x27;</span>;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">demo</span>(<span class="hljs-params">res</span>)</span>&#123;<br>      <span class="hljs-built_in">console</span>.log(res);<br>    &#125;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><ul><li>JSONP:利用动态脚本的src属性，变相地发送了一个<code>http://www.b.com/getdata?callback=domo</code>。这时候，b.com页面接受到这个请求时，如果没有JSONP,会正常返回json的数据结果，像这样：<code>&#123;msg:&#39;helloworld&#39;&#125;</code>,而利用JSONP,服务端会接受这个callback参数，然后用这个参数值包装要返回的数据：demo({msg：helloworld});到这个时候，如果a.com的页面上正好有一个demo函数</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">demo</span>(<span class="hljs-params">res</span>) </span>&#123;<br><span class="hljs-built_in">console</span>.log(res);<br>&#125;<br></code></pre></td></tr></table></figure><p>当远程数据一返回的时候，随着动态脚本的执行，这个demo函数就会被执行。</p><ul><li><p>CORS跨域资源共享：跨域资源共享（CORS）是一种机制，它使用额外的HTTP头来告诉浏览器，让运行在一个与origin上的Web应用被准许访问来自不同源服务器上的指定的资源。当一个资源从与该资源本身所在的服务器不同的域或端口请求资源时，资源会发起一个跨域的HTTP的请求。应该算是现在比较推荐的跨域解决方案。</p><ul><li>现在浏览器将CORS的请求分成两类：<code>简单请求</code>和<code>非简单请求</code></li><li>同时满足以下条件的才是简单请求</li></ul><table><thead><tr><th>请求方式</th><th>HTTP的头信息不超过字段</th></tr></thead><tbody><tr><td>HEAD</td><td>Accept</td></tr><tr><td>GET</td><td>Accept-Language</td></tr><tr><td>POST</td><td>Content-Language</td></tr><tr><td></td><td>Content-Type（application/x-www-form-urlencoded、mulitipart/form-data、text/plain）</td></tr></tbody></table><p>非简单请求会发出一次预检测请求，返回码是204，预检测通过才会真正发出请求，这才返回200。这里通过前端发请求的时候增加一个额外的headers来触发非简单请求。</p><ul><li><p>进行带有身份凭证的CORS请求</p><ul><li>默认情况下的跨域请求都是不会把cookie发送给服务器的，在需要发送的情况下，如果是xhr,那么需要设置xhr.withCredentials=true</li><li>如果是采用fetch获取的话，那么需要在request里面设置credential:’include’,</li><li>但是如果服务器在预请求的时候没返回Access-Control-Allow-Crenditials:ture的话，那么在实际请求的时候，cookie是不会被发送给服务器端的，要特别注意对于简单的get请求，不会有预请求的过程</li><li>那么在实际请求的时候，如果服务器没有返回Access-Control-Allow-Crenditial:true的话那么相应结果浏览器也不会交给请求者。</li></ul></li><li><p>对于附带身份凭证的请求，服务器不得设置Access-Control-Allow-Origin的值为“<code>*</code>”。这是因为请求的首部中携带了Cookie信息，如果Access-Control-Allow-Origin的值为“<code>*</code>”,请求将会失败。而将Access-Cotrol-Allow-Origin的值设置为<code>http://www.a.com</code>,则请求将成功执行。</p></li><li><p>HTTP响应首部字段</p><table><thead><tr><th>字段</th><th>意义</th></tr></thead><tbody><tr><td>Access-Control-Allow-Origin</td><td><code>&lt;origin&gt;</code>|*</td></tr><tr><td>Access-Control-Expose-Headers</td><td>头让服务器把允许浏览器访问的头放入白名单</td></tr><tr><td>Access-Control-Max-Age</td><td>头指定了preflight请求的结果能够被缓存多久</td></tr><tr><td>Access-Control-Allow-Credentials</td><td>头指定了当浏览器的credentials设置为true时是否允许浏览器读取response的内容</td></tr><tr><td>Access-Control-Allow-Methods</td><td>首部字段用于预检请求的响应。其指明了实际请求所允许使用的HTTP方法。（GET/PUT/POST/DELETE）</td></tr><tr><td>Access-Control-Allow-Headers</td><td>首部字段用于预检请求的响应。其指明了实际请求中允许携带的首部字段(Content-Type)</td></tr></tbody></table></li></ul></li></ul><h5 id="4、清除浮动"><a href="#4、清除浮动" class="headerlink" title="4、清除浮动"></a>4、清除浮动</h5><p>清除浮动的目的是什么，即要解决什么样的问题。一个浮动的例子。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;topDiv&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;floatDiv&quot;</span>&gt;</span>float left<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;textDiv&quot;</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;bottomDiv&quot;</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><br><span class="css"><span class="hljs-selector-class">.topDiv</span> &#123;</span><br>    width: 500px;<br>    border: 2px solid black;<br>&#125;<br><span class="css"><span class="hljs-selector-class">.floatDiv</span> &#123;</span><br>    width: 100px;<br>    height: 100px;<br>    border: 2px dotted red;<br>    color: red;<br>    margin: 4px;<br>    float: left;<br>&#125;<br><span class="css"><span class="hljs-selector-class">.bottomDiv</span> &#123;</span><br>    width: 500px;<br>    height: 100px;<br>    margin: 5px 0;<br>    border: 2px dotted black;<br>&#125;<br><span class="css"><span class="hljs-selector-class">.textDiv</span> &#123;</span><br>    color: blue;<br>    border: 2px solid blue;<br>&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br></code></pre></td></tr></table></figure><p>会看到float会覆盖在两个div上。</p><p>同时还可能会出现的问题有：</p><ul><li>文字围绕哦浮动元素排版，但我们可能希望文字（.textDiv）排列在浮动元素下方，或者我们并不希望.textDiv两边有浮动元素存放。</li><li>浮动元素排版超出其父元素（.topDiv）,父元素的高度出现了坍塌，若没有文字高度的支持，不考虑边框，父级元素高度会坍塌成零。</li><li>浮动元素甚至影响到了其父元素的兄弟元素（.bottomDiv）的排版。因为浮动元素脱离了文档流，.bottomDiv在计算元素位置的时候会忽略其影响，紧接着上一个元素的位置继续排列。</li></ul><p>解决第一个问题，需要清除.textDiv周围的浮动，而解决第二个问题，因为父元素位置只受父元素位置的影响，就需要第一种方法将父元素的高度撑起来，将浮动元素包裹其中，避免浮动元素影响父元素外部的元素排列。</p><p><code>清除浮动的方式</code>：</p><ul><li>在父元素结束标签之前插入清除浮动的块级元素</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.textDiv</span>&#123;<br><span class="hljs-attribute">color</span>:blue;<br><span class="hljs-attribute">border</span>:<span class="hljs-number">2px</span> solid blue;<br><span class="hljs-attribute">clear</span>:left;<br>&#125;<br></code></pre></td></tr></table></figure><p>通过上面的样式，.textDiv告诉浏览器，我的左边不允许有浮动的元素存在，请清除掉我左边的浮动元素。然而，因为浮动元素（.floatDiv）位置已经确定，浏览器在计算.textDiv的位置时，为满足其需求，将textDiv渲染在浮动元素下方，保证了.textDiv左边没有浮动元素。同时可以看出，父元素的高度也被撑起来了，其兄弟元素的渲染也不再受到浮动的影响，这是因为.textDiv仍然在文档流中，它必须在父元素的边界内，父元素只有增加其高度才能达到其目的，哪边不允许有浮动，clear就是对应方向的值。</p><p>但是如果任然是上面的这个例子，我们将浮动元素和上面一个的文本块交换位置以后，无论文本块如何应用清除浮动，情况都是会影响下面父亲的兄弟块。</p><p>那么可以在浮动元素的后面插入一个空白元素块，并且<code>clear:both</code>这和之前的清除原理一致。</p><ul><li>利用伪元素（clearfix）</li></ul><p>在HTML结构如下，为了惯例相符，在.topDiv的div上再添加一个clearfix类：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;topDiv clearfix&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;floatDiv&quot;</span>&gt;</span>float left<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;textDiv&quot;</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;bottomDiv&quot;</span>&gt;</span>...<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><br>.clearfix:after &#123;<br>content: &#x27;.&#x27;;<br>height: 0;<br>display:block;<br>clear:both;<br>&#125;<br></code></pre></td></tr></table></figure><p>该样式在clearfix，即父元素的最后，添加了一个：after伪元素，通过清除伪元素的浮动，达到称起父元素高度的目的。注意到该元素的display值为block，即它是一个不可见的块级元素，他们的底层本质是一样的。</p><ul><li><p>overflow清除浮动</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.topDiv</span> &#123;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">500px</span>;<br>    <span class="hljs-attribute">padding</span>: <span class="hljs-number">4px</span>;<br>    <span class="hljs-attribute">border</span>: <span class="hljs-number">2px</span> solid black;<br> <br>    // 区别在这里<br>    <span class="hljs-selector-tag">overflow</span>: <span class="hljs-selector-tag">auto</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><p>仅仅只在父元素上添加了一个值为auto的overflow属性，父元素的高度立刻被撑起，将浮动元素包裹在内。看起来，浮动被清除了，浮动不再会影响到后续元素的渲染。其实，这里的overflow值，还可以是除了“visible”之外的任何有效值，它们都能达到撑起父元素的高度，清除浮动的目的，不过，有的值可能会带来副作用，比如，scrool的值会导致滚动条始终可见，hidden会使得超出边框部分不可见等。那他们是如何清除浮动的呢？</p><p>要讲清除这个解决方案的原理，有一个概念始终是绕不过去，那就是格式化上下文(BFC)，然而这又是一个要讲清楚这个解决方案的原理</p><p>MDN上对BFC的定义：块级格式化上下文是CSS可视化渲染的一部分。它是一块区域，规定了内部块盒的渲染方式，以及浮动相互之间的影响关系。</p><p><code>块级格式化上下文</code>有以下几个特点：</p><ul><li>BFC像一道屏障，隔离出BFC的内部和外部，内部和外部区域的渲染相互之间互不影响。BFC有自己的一套内部子元素的渲染规则，不影响外部渲染，也不受外部渲染影响。</li><li>BFC的区域不会和外部浮动盒子的外边距区域发生叠加。也就是说，外部任何浮动元素区域和BFC区域是泾渭分明的，不可能重叠。</li><li>BFC在计算高度的时候，内部浮动元素的高度也是要计算在内的。也就是说，内部只有一个浮动元素也是不发生坍塌，高度始终大于等于浮动元素的高度的。</li><li>HTML结构中，当构建BFC区域的元素紧接着一个浮动盒子时，即，是该浮动盒子的兄弟节点，BFC区域会首先尝试在浮动元素旁边渲染，如果宽度不够，就在浮动元素的下边渲染。</li></ul><p>形成BFC的条件：</p><ul><li>根元素或者包含根元素</li><li>绝对定位元素：position为absolute或fixed</li><li>行内块元素:display:inline-block</li><li>表格单元格：display:teble-cell,html表格表单默认为该值</li><li>表格标题：元素的display为table-caption,html表格标题默认为该值</li><li>overflow:不为visible</li></ul><h5 id="5、手写一个抽奖展示页面"><a href="#5、手写一个抽奖展示页面" class="headerlink" title="5、手写一个抽奖展示页面"></a>5、手写一个抽奖展示页面</h5><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>抽奖展示页<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><br><span class="css">        <span class="hljs-selector-id">#demo</span> &#123;</span><br>            list-style: none;<br>            height: 65px;<br>            overflow: hidden;<br>        &#125;<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>最近通知<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">ul</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&#x27;demo&#x27;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>恭喜罗X获得特等奖 别墅一套<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>恭喜张4获得一等奖 跑车一辆<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>恭喜张5获得二等奖 华为手机一部<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>恭喜张6获得二等奖 华为手机一部<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>恭喜张7获得三等奖 小米手机一部<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>恭喜张8获得三等奖 小米手机一部<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>恭喜张9获得三等奖 小米手机一部<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br><span class="javascript">    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sroll</span>(<span class="hljs-params">id, delay = <span class="hljs-number">500</span></span>)</span>&#123;</span><br><span class="javascript">        <span class="hljs-keyword">if</span> (!id) &#123;</span><br><span class="javascript">            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">&quot;选择器不存在&quot;</span>);</span><br>        &#125;<br><span class="javascript">        <span class="hljs-keyword">let</span> timer = <span class="hljs-literal">null</span>;</span><br><span class="javascript">        <span class="hljs-keyword">let</span> ele = <span class="hljs-built_in">document</span>.getElementById(id);</span><br><span class="javascript">        <span class="hljs-keyword">let</span> c = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;</span><br><span class="javascript">            <span class="hljs-comment">// if (timer) &#123;</span></span><br><span class="javascript">            <span class="hljs-comment">//     clearInterval(timer)</span></span><br><span class="javascript">            <span class="hljs-comment">// &#125;</span></span><br><span class="javascript">            ele.onmouseover = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;</span><br><span class="javascript">                <span class="hljs-built_in">clearInterval</span>(timer);</span><br>            &#125;<br><span class="javascript">            ele.onmouseout = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;</span><br>                c();<br>            &#125;<br>            /*<br>                scrollHeigh、只读、文档内容的实际高度，包括超出视窗的溢出部分<br>                scrollTop滚动条滚动距离<br>                clientHeight窗口可视范围高度，包含padding,但不包含border、水平滚动条、margin元素的高度<br><span class="javascript">                offsetHeight<span class="hljs-string">`只读`</span>是包含padding、border、水平滚动条，但不包括margin</span><br><br>            */    <br><br><span class="javascript">            <span class="hljs-keyword">if</span> (ele.scrollHeight &gt;= ele.offsetHeight) &#123;</span><br><span class="javascript">                timer = <span class="hljs-built_in">setInterval</span>(<span class="hljs-function">() =&gt;</span> &#123;</span><br><span class="javascript">                    <span class="hljs-keyword">if</span> (ele.scrollTop &gt;= ele.scrollHeight) &#123;</span><br>                        ele.scrollTop = 0;<br><span class="javascript">                    &#125; <span class="hljs-keyword">else</span> &#123;</span><br><span class="javascript">                        <span class="hljs-keyword">if</span> (ele.scrollTop &gt;= ele.children[<span class="hljs-number">0</span>].offsetHeight) &#123;</span><br>                            ele.append(ele.children[0]);<br>                        &#125;<br>                        ele.scrollTop++;<br>                    &#125;<br>                &#125;, delay);<br>            &#125;<br>        &#125;<br><span class="javascript">            <span class="hljs-keyword">return</span> c;</span><br><br>    &#125;<br><span class="javascript">    <span class="hljs-keyword">let</span> callback = sroll(<span class="hljs-string">&#x27;demo&#x27;</span>)</span><br>    callback();<br><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><h5 id="6、阻止事件冒泡"><a href="#6、阻止事件冒泡" class="headerlink" title="6、阻止事件冒泡"></a>6、阻止事件冒泡</h5><ul><li>在W3C中，使用event.stopPropagation()方法</li><li>在IE下设置event.cancelBubble = true;</li></ul><h5 id="7、使得p变得可编辑"><a href="#7、使得p变得可编辑" class="headerlink" title="7、使得p变得可编辑"></a>7、使得p变得可编辑</h5><p>可以使用<code>contenteditable = true</code>,</p><p>如果还需要复制粘贴字段长度正常，可以把值修改成”plaintext-only”</p><h5 id="8、readyState几个数字的含义"><a href="#8、readyState几个数字的含义" class="headerlink" title="8、readyState几个数字的含义"></a>8、readyState几个数字的含义</h5><table><thead><tr><th>数字</th><th>含义</th></tr></thead><tbody><tr><td>0</td><td>代表未初始化，还没有调用open方法</td></tr><tr><td>1</td><td>代表正在加载。open方法已被调用，但send方法还没有被调用</td></tr><tr><td>2</td><td>代表方法已经加载完毕。send已被调用，请求已经开始，但当前的状态和http的请求头未知。</td></tr><tr><td>3</td><td>代表交互中。服务器正在发送相应。已经接受到了部分数据，因为响应及http的头不全，这时通过responseBody和responseText获取部分数据会出现错误。</td></tr><tr><td>4</td><td>代表完成。响应发送完毕。</td></tr></tbody></table><h5 id="9、解决0-1-02-0-3问题的几种方法"><a href="#9、解决0-1-02-0-3问题的几种方法" class="headerlink" title="9、解决0.1+02==0.3问题的几种方法"></a>9、解决0.1+02==0.3问题的几种方法</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">numbersequal</span>(<span class="hljs-params">a,b</span>)</span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">Math</span>.abs(a-b)&lt;<span class="hljs-built_in">Number</span>.EPSILON;<br>&#125; <br><span class="hljs-keyword">var</span> a=<span class="hljs-number">0.1</span>+<span class="hljs-number">0.2</span>， b=<span class="hljs-number">0.3</span>;<br><span class="hljs-built_in">console</span>.log(numbersequal(a,b)); <span class="hljs-comment">//true</span><br><br><br><span class="hljs-built_in">Number</span>.EPSILON=(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;   <span class="hljs-comment">//解决兼容性问题</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">Number</span>.EPSILON?<span class="hljs-built_in">Number</span>.EPSILON:<span class="hljs-built_in">Math</span>.pow(<span class="hljs-number">2</span>,-<span class="hljs-number">52</span>);<br>      &#125;)();<br><span class="hljs-comment">//上面是一个自调用函数，当JS文件刚加载到内存中，就会去判断并返回一个结果，相比if(!Number.EPSILON)&#123;</span><br>  <span class="hljs-comment">//   Number.EPSILON=Math.pow(2,-52);</span><br>  <span class="hljs-comment">//&#125;这种代码更节约性能，也更美观</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>快手一面面试</title>
    <link href="/2021/01/14/%E5%BF%AB%E6%89%8B%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/"/>
    <url>/2021/01/14/%E5%BF%AB%E6%89%8B%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<p>今天主要是面快手的一面，小哥哥人超好，也给了我很多指导，接下来不要说感情了，梳理一下任务，在编码的时候，被推荐了ESlint、prettier去做编码规范的工作。Eslint用过了，立马增加插件prettier。前辈和我说有问题要深入，深入的了解一些优缺点和好处。(虚拟滚动)</p><h5 id="下述有关css属性position的属性值的描述，说法错误的是？"><a href="#下述有关css属性position的属性值的描述，说法错误的是？" class="headerlink" title="下述有关css属性position的属性值的描述，说法错误的是？"></a>下述有关css属性position的属性值的描述，说法错误的是？</h5><p>CSS中Position属性有四个可选值，它们分别是：static、absolute、fixed、relative。</p><p>◆position:static　无定位</p><p>该属性值是所有元素定位的默认情况，在一般情况下，我们不需要特别的去声明它，但有时候遇到继承的情况，我们不愿意见到元素所继承的属性影响本身，从而可以用position:static取消继承，即还原元素定位的默认值。</p><p>◆position:absolute　绝对定位</p><p>使用position:absolute，能够很准确的将元素移动到你想要的位置，</p><p>◆position:fixed　相对于窗口的固定定位</p><p>这个定位属性值是什么意思呢？元素的定位方式同absolute类似，但它的包含块是视区本身。在屏幕媒体如WEB浏览器中，元素在文档滚动时不会在浏览器视察中移动。例如，它允许框架样式布局。在页式媒体如打印输出中，一个固定元素会出现于第一页的相同位置。这一点可用于生成流动标题或脚注。我们也见过相似的效果，但大都数效果不是通过CSS来实现了，而是应用了JS脚本。</p><p>请特别注意，IE6不支持CSS中的position:fixed属性。真的非常遗憾，要不然我们就可以试试这种酷酷的效果了。</p><p>◆position:relative　相对定位</p><p>所谓相对定位到底是什么意思呢，是基于哪里的相对呢？我们需要明确一个概念，相对定位是相对于元素默认的位置的定位。既然是相对的，我们就需要设置不同的值来声明定位在哪里，top、bottom、left、right四个数值配合，来明确元素的位置。</p><h3 id="1、promise和async-await-优缺点好处"><a href="#1、promise和async-await-优缺点好处" class="headerlink" title="1、promise和async/await 优缺点好处"></a>1、promise和async/await 优缺点好处</h3><h4 id="优点"><a href="#优点" class="headerlink" title="优点:"></a><code>优点</code>:</h4><ul><li>async/await 做到了真正的串行同步的写法，代码阅读相对容易。</li></ul><p>但是javascript的90%都是在异步的场合都是ajax,ajax就一定要考虑异常，很可能需要try…catch来处理异常。</p><ul><li>对于条件语句和其他流程的语句比较好，可以直接写在判断条件里。而且await a()没有出错的可能性，还可以省掉try…catch</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">a</span>(<span class="hljs-params"></span>)</span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> preomise(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span>&#123;<br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span>&#123;<br>resolve(<span class="hljs-number">222</span>)<br>&#125;,<span class="hljs-number">1000</span>)<br>&#125;)<br>&#125;;<br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params"></span>)</span>&#123; <br><span class="hljs-keyword">try</span> &#123;<br><span class="hljs-keyword">if</span>( <span class="hljs-keyword">await</span> a() === <span class="hljs-number">222</span>)&#123;<br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;yes, it is!&#x27;</span>)<br>&#125;<br>&#125; <span class="hljs-keyword">catch</span>(err)&#123;<br><span class="hljs-comment">//...</span><br>&#125;<br>&#125;<br><br>f();<br></code></pre></td></tr></table></figure><ul><li>在处理复杂流程时，在代码清晰度方面有优势</li></ul><p>如果有这样一个业务场景：一个数组变量，如果它的length大于0，就遍历它进行下一步操作，如果length等于0，说明没有经历过ajax请求，则先ajax请求并赋值内容，然后再遍历它进行下一把操作；如果ajax的结果依旧为空，则显示toast，并中断流程。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> arr = [];<br><br><span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve</span>) =&gt;</span> &#123;<br><span class="hljs-keyword">if</span>(arr.length) &#123;<br>resolve();<br>&#125;<span class="hljs-keyword">else</span> &#123;<br>ajax().then(<span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span>&#123;<br><span class="hljs-keyword">if</span>( res.data.length)&#123;<br>arr = res.data;<br>resolve();<br>&#125;<span class="hljs-keyword">else</span> &#123;<br>showToast(<span class="hljs-string">&quot;数据为空&quot;</span>)<br>&#125;<br>&#125;)<br>&#125;<br>&#125;).then(<span class="hljs-function">() =&gt;</span> &#123;<br>    arr.forEach(<span class="hljs-function">()=&gt;</span>&#123;&#125;);<br>&#125;)<br><br></code></pre></td></tr></table></figure><p>如果我换成async/await呢？</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> arr = [];<br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params"></span>)</span>&#123;<br><span class="hljs-keyword">if</span>(!arr.length)&#123;<br><span class="hljs-keyword">const</span> res = <span class="hljs-keyword">await</span> ajax();<br><span class="hljs-keyword">if</span>(res.data.length) &#123;<br>arr = res.data;<br>&#125;<span class="hljs-keyword">else</span> &#123;<br>showToast(<span class="hljs-string">&quot;数据为空&quot;</span>)<br>&#125;<br>&#125;<br>arr.forEach(<span class="hljs-function">()=&gt;</span>&#123;&#125;)<br>&#125;<br><br>fn()<br></code></pre></td></tr></table></figure><p>Promise写法，必须有<code>if(arr.length)&#123;resolve();&#125;</code>,而async/await不必考虑这个分支。</p><p>Promise写法的代码不仅冗长，而且这还是在省略了一部分代码的前提下，<code>showToast(&#39;数据为空&#39;)</code>这个分支永远是pending状态，可能会带来一些问题。</p><h4 id="特点一：async-await无所谓优缺点的特点一：无法处理promise返回的reject对象，要借助try…catch…"><a href="#特点一：async-await无所谓优缺点的特点一：无法处理promise返回的reject对象，要借助try…catch…" class="headerlink" title="特点一：async/await无所谓优缺点的特点一：无法处理promise返回的reject对象，要借助try…catch…"></a><code>特点一：</code>async/await无所谓优缺点的特点一：无法处理promise返回的reject对象，要借助try…catch…</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">g</span>(<span class="hljs-params"></span>)</span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>) =&gt;</span> &#123;<br>        <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">()=&gt;</span>&#123;<br>            reject(<span class="hljs-number">222</span>)<br>        &#125;,<span class="hljs-number">1000</span>)<br>    &#125;)<br>&#125;;<br><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params"></span>)</span>&#123;<br>    <span class="hljs-keyword">const</span> y = <span class="hljs-keyword">await</span> g();<br>    <span class="hljs-built_in">console</span>.log(y);<br>&#125;<br>f();<br></code></pre></td></tr></table></figure><p>则<code>await g()</code>会直接报错，必须使用try…catch…捕获。</p><p>那么假定有3个ajax串行请求，Promise模式与async/await的对比如下：</p><p>1、允许统一处理reject的话：</p><p>Promise(伪代码)：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js">ajax1().then(<span class="hljs-function">() =&gt;</span> &#123;<br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;ajax1 sucess&#x27;</span>)<br><span class="hljs-keyword">return</span> ajax2();<br>&#125;).then(<span class="hljs-function">() =&gt;</span> &#123;<br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;ajax2 sucess&#x27;</span>)<br><span class="hljs-keyword">return</span> ajax3();<br>&#125;).then(<span class="hljs-function">()=&gt;</span> &#123;<br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;ajax suncess&#x27;</span>)<br>&#125;).catch(err) =&gt; &#123;<br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;可能打印ajax1或2或3的fail&#x27;</span>,err);<br>&#125;<br></code></pre></td></tr></table></figure><p>async/await(伪代码)：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">a</span>(<span class="hljs-params"></span>)</span>&#123;<br><span class="hljs-keyword">try</span>&#123;<br><span class="hljs-keyword">await</span> ajax1();<br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;ajax1 success&#x27;</span>)<br><span class="hljs-keyword">await</span> ajax2();<br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;ajax2 success&#x27;</span>)<br><span class="hljs-keyword">await</span> ajax3();<br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;ajax3 success&#x27;</span>)<br>&#125;.catch(err) &#123;<br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;可能打印ajax1或2或3的reject&#x27;</span>,err);<br>&#125;<br>&#125;<br>a(s)<br></code></pre></td></tr></table></figure><p>对比结果：从代码量上说，大同小异，就看你是否用的惯try…catch….。</p><p>为什么说用的惯呢，看这段代码，这段代码在上文粘贴过，想象一下，假如<code>if ( await a () === 222)</code> ,<code>&#123;&#125;</code>里的内容有20行，会怎样——你会发现，<code>try</code>和<code>catch</code>相距22行，很远，很难阅读，并且，内容体里面如果还有try…catch…怎么办？这就成了try…catch…的嵌套圣诞树，更加难以阅读，最终解决办法只能是：如果if的内容体太长，尤其是try…catch…的嵌套圣诞树，就放弃<code>if(await a() === 222)</code>这种优雅的写法，改成<code>const res == await a()</code>;这种写法，然后把这句单独做try…catch…。</p><h4 id="特点二：Promise可以轻松做到并行："><a href="#特点二：Promise可以轻松做到并行：" class="headerlink" title="特点二：Promise可以轻松做到并行："></a><code>特点二</code>：Promise可以轻松做到并行：</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs javascript">ajax1();<br>ajax2();<br><br><span class="hljs-built_in">Promise</span>.all([ajax1(),ajax()])<br></code></pre></td></tr></table></figure><p>但是await做不到，它一定是阻塞的。await甚至可以阻塞for循环：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params"></span>)</span>&#123;<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>;i &lt; <span class="hljs-number">10</span>;i++)&#123;<br><span class="hljs-keyword">const</span> y = <span class="hljs-keyword">await</span> g();<br><span class="hljs-built_in">console</span>.log(y);<br>&#125;<br>&#125;<br>f();<br></code></pre></td></tr></table></figure><p><code>注意:</code>await做不到并行，不代表async就不能并行。只要await不在同一个async的函数里就可以并行。</p><p>比如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span>(<span class="hljs-params"></span>) </span>&#123;<br>[<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>].forEach(<span class="hljs-keyword">async</span> (v)=&gt;&#123;<br><span class="hljs-keyword">const</span> y = <span class="hljs-keyword">await</span> g();<br><span class="hljs-built_in">console</span>.log(y);<br>&#125;)<br>&#125;<br><br>f();<br></code></pre></td></tr></table></figure><h4 id="特点三-async-await全局捕获错误必须用window-onerror-不像Promise可以专用window-addEventLister-39-unhandledrejection-39-function-而window-onerror会捕获各种稀奇古怪的错误，造成系统浪费。"><a href="#特点三-async-await全局捕获错误必须用window-onerror-不像Promise可以专用window-addEventLister-39-unhandledrejection-39-function-而window-onerror会捕获各种稀奇古怪的错误，造成系统浪费。" class="headerlink" title="特点三:async/await全局捕获错误必须用window.onerror,不像Promise可以专用window.addEventLister(&#39;unhandledrejection&#39; , function),而window.onerror会捕获各种稀奇古怪的错误，造成系统浪费。"></a><code>特点三:</code>async/await全局捕获错误必须用window.onerror,不像Promise可以专用<code>window.addEventLister(&#39;unhandledrejection&#39; , function)</code>,而window.onerror会捕获各种稀奇古怪的错误，造成系统浪费。</h4><p>尽管window.onerror的开销大，但是一个成熟的系统是一定要利用window.onerror做错误监控系统，所以，无所谓了。</p><h4 id="async缺点一：try…catch内部的变量无法传递给下一个try…catch"><a href="#async缺点一：try…catch内部的变量无法传递给下一个try…catch" class="headerlink" title="async缺点一：try…catch内部的变量无法传递给下一个try…catch"></a><code>async缺点一：</code>try…catch内部的变量无法传递给下一个try…catch</h4><p>Promise和then/catch内部定义的变量，能通过then链条的参数传递到下一个then/catch,但是async/await的try内部的变量，如果用<code>let</code>和<code>const</code>定义则无法传递到下一个try…catch,只能在外层作用域先定义好。</p><h4 id="async缺点二：async-await无法简单实现Promise的各种原生方法，比如-race-之类"><a href="#async缺点二：async-await无法简单实现Promise的各种原生方法，比如-race-之类" class="headerlink" title="async缺点二：async/await无法简单实现Promise的各种原生方法，比如.race()之类"></a><code>async缺点二：</code>async/await无法简单实现Promise的各种原生方法，比如.race()之类</h4><p>如果真的要编写一些工具库，确实可以实现Promise的各种原生方法，但是放着Promise原生方法不用，却要写工具库，完全没有必要。</p><h3 id="什么时候用什么呢？"><a href="#什么时候用什么呢？" class="headerlink" title="什么时候用什么呢？"></a>什么时候用什么呢？</h3><p>1.需要用到promise各种便捷的方法（比如。race()之类）的时候，一定用Promise</p><p>2、并行的请求最好用Promise</p><p>3、不需要并行的场合，如果要传递参数，最好用Primise</p><p>4、其他ajax场合，看你喜好决定try…catch,还是.catch()</p><h3 id="额外讨论：ajax异常全部用拦截器处理，是否可以避免使用try…catch"><a href="#额外讨论：ajax异常全部用拦截器处理，是否可以避免使用try…catch" class="headerlink" title="额外讨论：ajax异常全部用拦截器处理，是否可以避免使用try…catch?"></a>额外讨论：ajax异常全部用拦截器处理，是否可以避免使用try…catch?</h3><p>拦截器对于后端业务代码错误，例如500错误，应当怎么处理呢？</p><p>如果：拦截器把200和500都归类为resolve</p><p><code>优点：</code>共同的好处是只需要考虑200的状态，所以确实不需要写try…catch，也不需要<code>.catch()</code></p><p><code>缺点:</code> 对两个方案都有缺点，500归为resolve的话，语义比较拧巴，而且业务代码永远需要这种代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">if</span>(res.code === <span class="hljs-number">200</span>)&#123;<br><span class="hljs-comment">//</span><br>&#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(code === <span class="hljs-number">500</span>)<br></code></pre></td></tr></table></figure><p>如果：拦截器只将500错误归为reject,而200依然属于resolve</p><p><code>优点：</code>共同的好处是不用一遍遍的写<code>if(res.code ===XXX)</code>,因为try里面是200的处理代码，catch里面是500的处理代码，天然就分开了。而且，500错误归为reject，从语义上说不拧巴。</p><p><code>缺点：</code>对两个方案都有缺点，必须用try…catch或<code>.catch()</code>捕获reject，不能省略。</p><h3 id="2、数组的浅复制可以如何做？有哪些方法？"><a href="#2、数组的浅复制可以如何做？有哪些方法？" class="headerlink" title="2、数组的浅复制可以如何做？有哪些方法？"></a>2、数组的浅复制可以如何做？有哪些方法？</h3><p>给我谈了几个array的方法</p><h3 id="3、项目的优化方面，提了个建议：使用虚拟滚动来优化文件树"><a href="#3、项目的优化方面，提了个建议：使用虚拟滚动来优化文件树" class="headerlink" title="3、项目的优化方面，提了个建议：使用虚拟滚动来优化文件树"></a>3、项目的优化方面，提了个建议：使用虚拟滚动来优化文件树</h3><h3 id="4、拍平对象"><a href="#4、拍平对象" class="headerlink" title="4、拍平对象"></a>4、拍平对象</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> data = [<br>  &#123;<br>    value: <span class="hljs-string">&#x27;1&#x27;</span>,<br>    children: [<br>      &#123;<br>        value: <span class="hljs-string">&#x27;1-1&#x27;</span><br>      &#125;,<br>      &#123;<br>        value: <span class="hljs-string">&#x27;1-2&#x27;</span>,<br>        children: [<br>          &#123;<br>            value: <span class="hljs-string">&#x27;1-2-1&#x27;</span><br>          &#125;<br>        ]<br>      &#125;<br>    ]<br>  &#125;,<br>  &#123; <span class="hljs-attr">value</span>: <span class="hljs-string">&#x27;2&#x27;</span> &#125;<br>];<br><br><span class="hljs-comment">// 返回</span><br><span class="hljs-keyword">const</span> res = [<br>  &#123; <span class="hljs-attr">value</span>: <span class="hljs-string">&#x27;1&#x27;</span> &#125;,<br>  &#123; <span class="hljs-attr">value</span>: <span class="hljs-string">&#x27;1-1&#x27;</span> &#125;,<br>  &#123; <span class="hljs-attr">value</span>: <span class="hljs-string">&#x27;1-2&#x27;</span> &#125;,<br>  &#123; <span class="hljs-attr">value</span>: <span class="hljs-string">&#x27;1-2-1&#x27;</span> &#125;,<br>  &#123; <span class="hljs-attr">value</span>: <span class="hljs-string">&#x27;2&#x27;</span> &#125;<br>];<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params">res</span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> arr = [];<br>  res.forEach(<span class="hljs-function">(<span class="hljs-params">item</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span> (item.children) &#123;<br>        arr.push(newobj(item))<br>        arr = arr.concat(foo(item.children));<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      arr.push(item);<br>    &#125;;<br>  &#125;)<br>  <span class="hljs-keyword">return</span> arr;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">newobj</span>(<span class="hljs-params">item</span>)</span>&#123;<br>  <span class="hljs-keyword">return</span> &#123;<span class="hljs-attr">value</span>: item.value&#125;<br>&#125;<br><br><span class="hljs-built_in">console</span>.log(foo(data))<br></code></pre></td></tr></table></figure><p>补充数组扁平化：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, [<span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>], <span class="hljs-number">9</span>], <span class="hljs-number">10</span>, [<span class="hljs-number">11</span>, <span class="hljs-number">12</span>]];<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn</span>(<span class="hljs-params">arr</span>) </span>&#123;<br>    <span class="hljs-keyword">let</span> arr1 = []<br>    arr.forEach(<span class="hljs-function">(<span class="hljs-params">val</span>) =&gt;</span> &#123;<br>        <span class="hljs-keyword">if</span> (val <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Array</span>) &#123;<br>            arr1 = arr1.concat(fn(val))<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            arr1.push(val)<br>        &#125;<br>    &#125;)<br>    <span class="hljs-keyword">return</span> arr1<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params">arr</span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> arr.toString().split(<span class="hljs-string">&#x27;,&#x27;</span>).map(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> +item);<br>&#125;<br><span class="hljs-built_in">console</span>.log(foo(arr))<br></code></pre></td></tr></table></figure><h3 id="5、数组浅拷贝的方法"><a href="#5、数组浅拷贝的方法" class="headerlink" title="5、数组浅拷贝的方法"></a>5、数组浅拷贝的方法</h3><table><thead><tr><th>序号</th><th>方式</th><th>例子</th><th>说明</th></tr></thead><tbody><tr><td>1</td><td>concat</td><td>let res = arr.concat();</td><td>连接数组返回一个新数组</td></tr><tr><td>2</td><td>slice</td><td>let res = arr.slice();</td><td>返回选定的元素默认从0开始到结尾</td></tr><tr><td>3</td><td>解构</td><td>let res = […arr];</td><td>创建了一个新的数组赋值为当前数组的值</td></tr><tr><td>4</td><td>装x写法</td><td>let […res] = arr;</td><td>同上</td></tr><tr><td>5</td><td>map</td><td>let res = arr.map(i=&gt;i);</td><td>遍历数组逐个返回元素给res</td></tr><tr><td>6</td><td>Array.of</td><td>let res = Array.of(…arr);</td><td>该方式将一堆数字转化成数组返回</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Salient Object Detection ： A Survey</title>
    <link href="/2021/01/06/%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1%E9%A2%98%E7%9B%AE%E8%AE%BE%E6%83%B3/"/>
    <url>/2021/01/06/%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1%E9%A2%98%E7%9B%AE%E8%AE%BE%E6%83%B3/</url>
    
    <content type="html"><![CDATA[<p>显著性目标检测</p><a id="more"></a><p>今天和导师谈了一下毕业设计的方向，导师给我谈到最近在和腾讯做的一个课题合作，关于广告的一个分类，内容主要是：有一个可能是关于包的一个广告，但是在广告中占的篇幅比较小，需要你通过某些算法，去将视频给推荐给有需要的人，或者是以图搜图，来将图片的要点提取出来。要点就是，在没有先验的情况下去提取要点。一般情况下，需要的东西可能不是主体目标</p><p>接下来做个综述的翻译吧，听说这个综述的风评不错。</p><p>摘要：<br>自然场景中显著物体的检测和分割，通常被称为显著物体检测，已经引起了计算机视觉领域的广泛关注。虽然已经提出了许多模型，并出现了一些应用，但对所取得的成就和存在的问题还缺乏深入的了解。我们的目标是全面回顾显著目标检测的最新进展，并将该领域与其他密切相关的领域，如通用场景分割、目标建议生成和注视预测的显著性进行比较。包括228种出版物，我们调查了i)根源、关键概念和任务，ii)核心技术和主要建模趋势，以及iii)显著对象检测中的数据集和评估度量。我们还讨论了模型性能中的评价指标和数据集偏差等问题，并提出了未来的研究方向。<br>显著目标检测：自下而上显著性；显性显著性；视觉注意；感兴趣区域。</p><h3 id="1引言"><a href="#1引言" class="headerlink" title="1引言"></a>1引言</h3><p>人类能够毫不费力且快速地检测到视觉上独特的所谓显著的场景区域(即，前注意阶段)。然后，这些过滤区域被感知并以更精细的细节进行处理，以提取更丰富的高级信息(即，注意力阶段)。认知科学家对这种能力的研究由来已久，最近在计算机视觉领域引起了人们的极大兴趣，主要是因为它有助于找到物体有效表示场景的区域，从而解决复杂的视觉问题，如场景理解。与视觉显著性密切或远程相关的一些主题包括：显著对象检测[41]、注视预测[33、34]、对象重要性[17、157、182]、可记忆性[78]、场景杂乱[169]、视频趣味性[50、69、90、96]、惊奇[80]、图像质量评估[208、209、228]、场景典型性[52、198]、美学[50]和属性[54]。由于篇幅所限，本文不能完全探讨上述所有研究方向。相反，我们只关注显著目标检测，这是一个在过去20年特别是自2007年以来得到很大发展的研究领域[135]。</p><h4 id="1-1什么是显著物体检测"><a href="#1-1什么是显著物体检测" class="headerlink" title="1.1什么是显著物体检测"></a>1.1什么是显著物体检测</h4><p>“显著对象检测”或“显著对象分割”在计算机视觉中通常被解释为包括两个阶段的过程：1)检测最显著的对象和2)分割该对象的准确区域。然而，很少有模型明确区分这两个阶段(几乎没有例外，如[20,131,154])。遵循Itti等人的开创性工作[81]和刘等人[139]模型采用显著性概念，将两个阶段同时进行。这些阶段没有单独评估的事实证明了这一点。此外，大多数基于区域的分数已被用于模型评估(例如，精确召回)。第一阶段不必仅限于一个对象。然而，现有的大多数模型都试图分割最显著的对象，尽管它们的预测图可以用来查找场景中的几个对象。第二个阶段属于计算机视觉中的经典分割问题，但不同的是，这里的精度只由最突出的对象决定。<br>一般而言，一致认为，对于良好的显著性检测，模型应至少满足以下三个标准：1)良好的检测：遗漏真实显著区域并将背景错误地标记为显著区域的概率应该较低，2)高分辨率：显著图应具有高或全分辨率，以准确定位显著对象并保留原始图像信息；3)计算效率：作为其他复杂过程的前端，这些模型应快速检测显著区域。</p><h4 id="1-2定位显著目标检测"><a href="#1-2定位显著目标检测" class="headerlink" title="1.2定位显著目标检测"></a>1.2定位显著目标检测</h4><p>显著对象检测模型通常旨在仅检测场景中最显著的对象，并分割这些对象的整个范围。另一方面，注视预测模型通常试图预测人类注视的位置，即一小组注视点[27，30]。由于这两种类型的方法输出单个连续值显著图，其中该图中的较高值指示更有可能关注相应的图像像素，因此它们可以互换使用。<br>在注视位置和显著对象之间存在很强的相关性。此外，当被要求选择场景中最显著的对象[20，29，131]时，人类通常会同意彼此中的哪一个。这些如图1所示。<br>与显著对象检测和固定预测模型不同，对象建议模型旨在产生一小组(通常为几百或数千个)重叠的候选对象边界框或区域建议[72]。对象建议生成和显著对象检测是高度相关的。显著性估计在客观性方法中被明确用作线索[10,181]。<br>图像分割，也称为语义场景标注或语义分割，是计算机视觉中研究得很好的领域之一(例如[40])。与输出为二进制地图的显著对象检测不同，这些模型旨在为每个图像像素分配一个标签，该标签是几个类别(如天空、道路和建筑)中的一个。<br>图2说明了这些研究主题之间的差异。</p><h4 id="1-3显著物体检测历史"><a href="#1-3显著物体检测历史" class="headerlink" title="1.3显著物体检测历史"></a>1.3显著物体检测历史</h4><p>最早的显著性模型之一，由Itti等人提出。[81]，引发了包括认知心理学、神经科学和计算机视觉在内的多个学科的第一波兴趣。该模型是早期基于中心-环绕机制的一般计算框架和自下而上注意心理学理论(如Treisman和Gelade[192]的特征整合理论，Wolfe等人的引导式搜索模型)的实现。[211]以及Koch和Ullman的计算注意体系结构[105])。在[81]中Itti展示一些他们的模型能够检测场景中空间间断的示例。随后的行为调查(例如，[162])和计算调查(例如，[32])使用注视作为验证显著性假设和比较模型的手段。<br>第二波兴趣随着刘等人的作品而激增。[139,140]和Achanta等人。[5]世卫组织将显著性检测定义为二进制分割问题。这些作者的灵感来自于一些早期努力检测显著区域或原型对象的模型(例如，Ma和Zhang[146]，Liu和Gleicher[133]，以及Walther等人[199])。从那时起，出现了过多的显著性模型。然而，该新定义如何与诸如图像分割(例如，[13,151])、与类别无关的对象建议生成(例如，[10，46，53])、注视预测(例如，[19，26，32，74，93])和对象检测(例如，[55,197])等其他已建立的计算机视觉领域相关的还不太清楚。<br>第三波兴趣最近随着卷积神经网络(CNNs)的复兴而出现[112]，特别是随着完全卷积神经网络的引入[142]。与大多数基于对比线索的经典方法不同[41]，基于CNN的方法消除了对手工特征的需要，减轻了对中心偏向知识的依赖，因此被许多研究人员采用。一个基于CNN的模型通常包含数十万个可调参数和具有可变接受野大小的神经元。具有大<code>感受野</code>的神经元提供了全局信息，可以帮助更好地识别图像中最突出的区域。而具有小感受场的神经元提供可被用于完善顶层生成的显著性图的局部信息。这允许突出显示区域并细化其边界。与手工制作的基于特征的模型相比，这些理想的特性使基于CNN的模型能够获得前所未有的性能。CNN模型正逐渐成为显著目标检测的主流方向。</p><h3 id="2最新技术状况调查"><a href="#2最新技术状况调查" class="headerlink" title="2最新技术状况调查"></a>2最新技术状况调查</h3><p>在这一部分中，我们回顾了3个类别的相关工作，包括：1)显著目标检测模型，2)应用，3)数据集。由于一些模型之间的相似性，有时很难在它们之间划出清晰的界限，这里我们主要关注那些对编年史上的主要“浪潮”做出贡献的模型如图3所示。</p><h4 id="2-1旧约：经典模式"><a href="#2-1旧约：经典模式" class="headerlink" title="2.1旧约：经典模式"></a>2.1旧约：经典模式</h4><p>在过去的二十年里，已经提出了大量的方法来检测图像中的显著目标。除了少数试图分割感兴趣对象的模型(例如，[11，76，104])外，大多数这些方法的目标是首先从图像中识别显著子集1(即，计算显著图)，然后将其集成以分割整个显著对象。<br>通常，根据它们所利用的类型、操作或属性，可以用两种不同的方式对经典方法进行分类。<br>1)基于块的分析与基于区域的分析。已经利用两种类型的可视子集：块和区域2来检测显著对象。块主要被早期的方法采用，而区域随着超像素算法的引入而变得流行起来。<br>2)内在线索VS外在线索。检测显著物体的一个关键步骤是将它们与干扰物区分开来。为此，一些方法提出仅从输入图像本身提取各种线索来突出目标并抑制干扰(即内在线索)。然而，其他方法认为，内在线索通常不足以区分目标和干扰物，特别是当它们具有共同的视觉属性时。为了解决这个问题，它们结合了外部提示，如用户注释、深度地图或相似图像的统计信息，以便于检测图像中的显著对象。<br>因此，从上面的模型分类来看，有四种组合是可能的。为了更好地组织模型，我们将模型分成三大类：1)具有内在线索的基于块的模型，2)具有内在线索的基于区域的模型，以及3)具有外部线索的模型(包括基于块和基于区域)。在“其他经典模型”子组中将讨论一些可能不太适合这些子组的方法。已查看的型号列在选项卡中。表4(固有模型)，选项卡。表5(外部模型)和Tab.6(其他经典型号)。</p><h4 id="2-1-1具有内在线索的基于块的模型"><a href="#2-1-1具有内在线索的基于块的模型" class="headerlink" title="2.1.1具有内在线索的基于块的模型"></a>2.1.1具有内在线索的基于块的模型</h4><p>在这一小节中，我们主要回顾利用从块中提取的内在线索的显著目标检测模型。在Itti等人的开创性工作之后。[81]显著目标检测被广泛定义为捕获场景中的唯一性、独特性或稀有性。<br>在早期的工作[5,133,146]中，唯一性通常是以像素为单位的中心环绕对比度来计算的。Hu等人[75]使用其特征的极变换在2D空间中表示输入图像。然后将图像中的每个区域映射到一维线性子空间。然后，在不实际分割图像的情况下，使用广义主成分分析(GPCA)[196]来估计线性子空间。最后，通过测量区域的特征对比度和几何属性来选择显著区域。Rosin[170]提出了一种检测显著对象的有效方法。他的方法是无参数的，只需要非常简单的像素级操作，如边缘检测、阈值分解和矩保持<br>二值化。Valenti等人[195]提出了一种基于等光线的框架，其中通过线性组合根据曲线度、颜色提升和等中心聚类计算的显著图来估计显著图。<br>在一项有影响力的研究中，Achanta等人。[6]采用调频方法计算全分辨率显著图。像素x的显著性计算如下：<br><img src="https://img-blog.csdnimg.cn/20200608185932722.png" alt="在这里插入图片描述"><br>其中Iµ是图像的平均像素值(例如，rgb/Lab特征)，IωHCI是输入图像的高斯模糊版本(例如，使用5×5内核)。<br>在没有任何关于显著对象大小的先验知识的情况下，出于稳健性目的经常采用多尺度对比度[133，139]。首先构造L层高斯金字塔(如[133,139])。在该金字塔的第l级的图像上的像素x的显著分数(表示为i(L))被定义为：<br><img src="https://img-blog.csdnimg.cn/20200608190005968.png" alt="在这里插入图片描述"><br>其中N(X)是以x为中心的相邻窗口(例如，9×9像素)。即使在这种多尺度增强的情况下，在像素级导出的内在线索通常也太差而不能支持对象分割。为了解决这一问题，一些工作(例如，[5，102，128，139])将对比分析扩展到补丁级别(即，将补丁与其邻居进行比较)。<br>后来在[102]中，Klein和Frtrop提出了一种信息论方法，利用强度、颜色和方向等特征分布之间的Kullback-Leibler散度来计算中心环绕对比度。Li等人[128]将中心-周围对比度表示为对成本敏感的最大边距分类问题。中心补片被标记为阳性样本，而周围的补片都被用作阴性样本。然后，基于训练的代价敏感支持向量机(SVM)，根据中心补丁与周围补丁的可分离性来确定中心补丁的显著性。<br>一些工作将补丁的唯一性定义为它与其他补丁的全局对比[66]。直观地说，如果一个补丁与其最相似的补丁明显不同，那么它就被认为是显著的，而它们的空间距离也被考虑在内。同样，Borji和Itti计算了RGB和LAB颜色空间中的局部和全局斑块稀有度，并将其融合以预测固定位置[26]。在最近的工作[149]中，Margolinet al。基于高维空间中不同的斑块比不明显的斑块更分散的观察结果，提出通过测量斑块到平均斑块的距离来定义斑块的唯一性。为了进一步合并补丁分布，通过将其到平均补丁的路径投影到图像的主分量来测量补丁的唯一性。<br>综上所述，2.1.1部分目标是基于像素或斑块检测仅利用固有线索的显著对象。这些方法通常有两个缺点：i)高对比度边缘通常比显著对象突出，ii)显著对象的边界没有得到很好的保护(特别是在使用大块时)。为了克服这些问题，一些方法提出了基于区域的显著性计算方法。这提供了两个主要优势。首先，区域的数量远远少于块的数量，这意味着开发高效和快速算法的潜力。其次，可以从区域中提取更多的信息特征，从而获得更好的性能。这些基于区域的方法将在下一小节中讨论。</p><h4 id="2-1-2具有内在线索的基于区域的模型"><a href="#2-1-2具有内在线索的基于区域的模型" class="headerlink" title="2.1.2具有内在线索的基于区域的模型"></a>2.1.2具有内在线索的基于区域的模型</h4><p>第二子组中的显著性模型采用从使用诸如基于图形的分割[56]、均值漂移[48]、SLIC[7]或Turbopixels[115]等方法生成的图像区域中提取的内在线索。与基于块的模型不同，基于区域的模型通常先将输入图像分割成与亮度边缘对齐的区域，然后再计算区域显著图。<br>作为早期的尝试，在[133]中，区域显著性分数被定义为其所包含像素的平均显著性分数，根据多尺度对比度定义。余等人[220]根据背景和显著区域的观察结果，提出一套规则来确定每个区域的背景分数。显着性被定义为全球区域对比的独特性，有许多方法被广泛研究[43，44，91,175,216]。在[43]中，通过测量目标区域相对于所有其他图像区域之间的全局对比度，引入了基于区域的显著性算法。简而言之，首先将图像分割成N个区域{ri}Ni=1。区域Rii的显著性被测量为：<br><img src="https://img-blog.csdnimg.cn/2020060819014182.png" alt="在这里插入图片描述"><br>其中DR(ri，Rj)捕捉两个区域之间的外观对比度。较高的显著性得分被分配给具有较大全局对比度的区域。Wij是区域Ri和Rj之间的权重项，包含空间距离和区域大小。Perazzi等人[164]证明了如果DR(ri，Rj)被定义为Ri和Rj之间的颜色的欧几里得距离，则可以使用基于有效滤波的技术来计算全局对比度[9]。<br>除了颜色唯一性之外，还考虑了诸如纹理[175]和结构[179]之类的互补线索的显著性用于显著目标检测。Margolin等人[149]建议将区域独特性和斑块显著性，形成显著图。文[44]提出了一种软抽象方法，利用直方图量化和高斯混合模型(GMM)生成一组大规模的感知上均匀的区域，而不是维护每个像素的硬区域索引。通过避免超像素的硬判决边界，这种软抽象提供了更大的空间支持，从而导致更均匀的显著区域。<br>在[86]中，JIiang提出了一种基于多尺度局部区域对比度的方法，该方法计算多个分割的显著值以达到鲁棒性目的，并将这些区域显著值组合以获得像素级的显著图。在[129,216]中采用了使用多层次分割来估计区域显著性的类似想法。Li等人[128]通过构建由超像素的非参数多尺度聚类构建的超图来扩展成对局部对比度，以捕捉区域的内部一致性和外部分离。然后，显著对象检测被演绎为在超图中寻找显著顶点和超边。<br>就唯一性而言，显著对象还可以被定义为特定特征空间中的稀疏噪声，其中输入图像被表示为低秩矩阵[163,177,233]。基本假设是非显著区域(即背景)可以用低秩矩阵来解释，而显著区域可以用稀疏噪声来表示基于这样一个通用的低秩矩阵恢复框架，沈和吴[177]提出了一种统一的方法，将传统的低级特征与高级指导相结合，例如中心优先、人脸优先和颜色优先，以基于学习的特征变换来检测显著对象。相反，邹等人[233]提出利用自下而上分段作为低秩矩阵恢复的指导线索，以达到鲁棒性目的。类似于[177]，在[163]中也采用了高级先验，其中引入了树形结构的稀疏诱导范数正则化来分层描述图像结构，以便均匀地突出整个显著对象。<br>在获取唯一性的同时，越来越多的先验被提出用于显著目标检测。在[139]之前的空间分布意味着越宽的颜色分布在图像中，显著对象包含此颜色的可能性越小。使用高斯模糊核也可以在线性时间内有效地评估超像素的空间分布，这与在Eq中计算全局区域对比度的方式类似。(3)在文献[179]中也考虑了这样的空间分布先验，并根据颜色和结构线索进行了评估。<br>中心优先假设更有可能在图像中心附近找到显著对象。换句话说，背景往往远离图像中心。为此，假设图像的窄边界是背景区域，即伪背景，则对显著对象检测[85、129、210、218]采用背景先验。以此伪背景为参考，区域显著性可以计算为区域与“背景”的对比度。[218]在文[218]中，提出了一个基于无向加权图上流形排序的两阶段显著性计算框架。在第一阶段，基于给予伪背景查询的每一侧的相关性来计算区域显著性得分。在第二阶段，基于给予初始前景的相关性来细化显著性分数。在[129]中，显著性计算被表示为密集和稀疏重建误差假背景。基于背景模板的主成分分析(PCA)基来计算每个区域的密集重建误差，而稀疏重建误差定义为基于背景模板的稀疏表示的残差。这两种类型的重建误差被传播到多个分割上的像素，这些像素将被融合以形成最终的显著图。蒋等人[85]提出了基于吸收马尔可夫链的显著性检测方法，其中瞬时节点和吸收节点分别是图像中心和边缘附近的超像素。每个超像素的显著性被计算为瞬时节点到马尔可夫链的吸收节点的吸收时间。<br>除了这些方法之外，通用对象性优先级4还用于通过利用对象建议来促进显著对象检测[10]。Chang等人[35]通过将客观性和区域显著性融合到图形模型中，提出了一个计算框架。通过迭代最小化编码它们相互作用的能量函数来联合估计这两个项。[89]将区域目标度定义为其包含像素的平均目标值，并将其纳入区域显著性计算。Jia和han[84]根据客观性，通过将每个区域与“软”前景和背景进行比较来计算每个区域的优先显著性。<br>依赖于伪背景假设的显著对象检测有时可能失败，特别是当对象触及图像边界时。为此，在[43，231]中利用了边界连通性先验。直观地说，与背景中的对象相比，显著对象与图像边界的连接要少得多。因此，区域的边界连通性分数可以根据其沿图像边界的长度与该区域的跨越面积之间的比率来估计[231]，该比率可以分别基于该区域到伪背景和其他区域的测地线距离来计算。然后，将这样的边界连通性分数集成到二次目标函数中，以获得最终的优化显著图。值得注意的是，类似的边界连通性先验概念也在[233]中作为分割先验和在[226]中作为环境进行了研究。<br>在[89,126]中已经研究了焦点先验，即突出的对象通常被拍摄在焦点中以吸引更多注意力的事实。蒋等人[89]根据焦点模糊程度计算聚焦度。通过将消焦模糊建模为锐化图像与点扩散函数的卷积，并用高斯核进行近似，通过尺度空间分析，将像素级聚焦投射为估计高斯核的标准差。通过在边界和内部边缘像素传播聚焦和/或清晰度来计算区域聚焦分数。突出度分数最终从唯一性(全局对比度)、客观性和聚焦度分数的非线性组合中导出。<br>基于区域的显著目标检测性能可能会受到分割参数的影响。除了基于多尺度区域[86，128，216]的其他方法外，通过解决[91]中的设施选址问题来提取单尺度潜在显著区域。首先将输入图像表示为超像素上的无向图，然后通过凝聚聚类生成较小的候选区域中心集。在这个集合上，构建了一个子模目标函数来最大化相似度。通过应用贪婪算法，可以迭代优化目标函数以将超像素分组为区域，这些区域的显著值通过区域全局对比度和空间分布进一步测量。<br>贝叶斯框架被用于显著性计算[167,214]，其被表示为在给定输入图像I的情况下估计像素x是前景的后验概率。为了估计显著性先验，首先在检测到的兴趣点周围估计凸包H。将图像I分成内部区域RI和外部区域RO的凸壳H提供了粗略的前景和背景的估计，可以用于似然计算。刘等人[138]采用基于优化的框架来检测显著对象。类似于[214]，凸壳被粗略地估计为将图像划分为纯背景和潜在前景。然后，从图像中学习显著种子，同时从背景区域以及人类先验知识中学习引导图。利用这些线索，引入一个具有Dirichlet边界的一般线性椭圆系统来模拟种子向其他区域的扩散，从而生成显著图。<br>在这一小节回顾的所有模型中，主要有三种类型的区域用于显著性计算。可以使用基于图形的分割算法[56]、均值漂移算法[48]或聚类(量化)来生成大小不同的不规则区域。另一方面，随着超像素算法的最新进展，使用SLIC算法[7]、Turbopixel算法[115]等，大小相当的紧凑区域也成为流行的选择。这两类区域之间的主要区别在于是否应该考虑区域大小的影响。此外，还考虑用于显著性分析的软区域，其中每个像素保持属于所有区域(分量)中的每一个的概率，而不仅仅是硬区域标签(例如，由GMM拟合)。为了进一步增强分割的鲁棒性，可以基于多个分割或以分层的方式生成区域。一般来说，单尺度分割速度较快，而多尺度分割可以提高整体性能。<br>为了衡量地区的显著性，唯一性仍然是最常用的特征，通常以全球和局部地区对比的形式出现。此外，为了提高整体性能，如背景、客观性、焦点和边界连通性，对区域显著性的互补先验进行了越来越多的研究。与基于块的显著性模型相比，这些先验的扩展也是基于区域的显著性模型的主要优势。此外，区域提供更复杂的线索(例如，颜色直方图)以更好地捕捉场景的显著对象，而不是像素和补丁。使用区域定义显著性的另一个好处与效率有关。由于图像中的区域数目远远少于像素数，在区域级别计算显著性可以在生成全分辨率显著图的同时显著降低计算成本。<br>请注意，本小节中讨论的方法仅使用内在线索。在下一个小节中，我们将回顾如何结合外部线索来促进显著对象的检测。</p><h3 id="2-1-3具有外在提示的模型"><a href="#2-1-3具有外在提示的模型" class="headerlink" title="2.1.3具有外在提示的模型"></a>2.1.3具有外在提示的模型</h3><p>第三个子组中的模型采用外部线索来辅助图像和视频中显著目标的检测。除了从单个输入图像观察到的视觉提示之外，外部提示还可以从训练图像、相似图像、视频序列、包含共同显著对象的一组输入图像、深度图或光场图像的基本事实注释中导出。在本节中，我们将根据使用的外部线索的类型来回顾这些模型。制表符。5列出具有外部提示的所有模型，其中每个方法都用几个预定义的属性突出显示。<br>具有相似图像的显著目标检测。近年来，随着网络上越来越多的视觉内容的可获得性，通过利用与输入图像视觉上相似的图像来检测显著目标已经被研究。通常，给定输入图像I，首先从大量图像C中检索K个相似图像CI={Ik}Kk=1，可以通过检查这些相似图像来辅助对输入I的显著对象检测。<br>在一些研究中，假设C的显著注释是可用的。例如，Marchesotti等人[148]提出通过一对描述符(f+Ik，f−Ik)来描述每个索引图像Ik，其中f+Ik和f−Ik分别表示根据显著性注释的显著区域和非显著区域的特征描述符(费舍尔向量)。为了计算显著图，输入图像的每个面片px由费舍尔矢量fx描述。根据其与前景和背景区域特征的对比度来计算斑块的显著性{(f+Ik，f−Ik)}Kk=1。<br>或者，基于不同特征对每个图像上的显著性分析的贡献不同的观察，Mai等人[147]建议学习图像特定权重而不是通用权重来融合在不同特征通道上计算的显著图。为此，显著性图的CRF聚合模型仅针对检索到的相似图像进行训练，以说明聚合对单个图像的依赖性5。<br>如果有大规模的图像集合可用，则基于相似图像的显著性效果很好。然而，在这样的集合上，显著性注释是耗时、乏味的，甚至是难以处理的。为了缓解这一问题，一些方法利用未注释的相似图像。对于网络规模的图像集C，Wang等人[204]提出了一种简单有效的显著性估计算法。按像素方向的显著性贴图计算如下：<br><img src="https://img-blog.csdnimg.cn/20200608190651717.png" alt="在这里插入图片描述"><br>其中˜Ik是具有参考I的Ik的几何扭曲版本。主要的洞察力是相似的图像提供对背景区域的良好近似，而显著区域可能不能很好地近似。<br>Siva等人[181]作为抽样问题，提出显著性计算的概率公式。如果从图像CI∪I采样的概率较低，则认为补丁Px是显著的。换言之，如果Px在从相似图像提取的一包补丁中是唯一的，则给予Px较高的显著性分数。<br>共显著目标检测。共显著对象检测算法不是集中在单个图像上计算显著性，而是集中于发现由多个输入图像{ii}Mi=1共享的共同显著对象，即这样的对象可以是具有不同视点的相同对象，也可以是具有相似视觉外观的相同类别的对象。值得注意的是，共显著目标检测算法的关键特征是它们的输入是一组图像，而经典的显著目标检测模型只需要一幅输入图像。<br>共同显著性检测与图像共同分割的概念密切相关，图像共同分割的目的是从多个图像中分割相似对象[16，172]。如[61]所述，共显著和共分段之间存在三个主要区别。首先，共显著检测算法仅关注于检测共同的显著对象，而在共分割方法中也可以分割出相似但不显著的背景[98,158]。其次，一些共分割方法，例如[16]，需要用户输入来指导歧义情况下的分割过程。第三，显著对象检测通常用作预处理步骤，因此比共同分割算法更有效的算法是优选的，尤其是在大量图像上。<br>Li和Ngan[121]提出了一种计算具有某些公共对象的图像对的共显着性的方法。共显着性定义为图像间的对应关系，即对不同区域赋予低显着性值。与文献[36]类似，Chang et al.。建议通过利用跨多个图像的附加重复性属性来计算共显着性。具体地说，像素的共显性分数被定义为传统显着性分数的乘积[66]及其在输入图像上的重复性似然。Fu等人[61]利用单一图像上成熟的全局对比度和空间分布概念，提出了一种基于聚类的共显性检测算法。此外，引入了多个图像上的对应线索来解释显著共现。</p><h4 id="2-1-4其他经典模型"><a href="#2-1-4其他经典模型" class="headerlink" title="2.1.4其他经典模型"></a>2.1.4其他经典模型</h4><p>在本节中，我们回顾了旨在通过边界框直接分割或定位显著对象的算法，以及与显著性检测密切相关的算法。一些小节提供了一些不同的分类前面部分涵盖的模型(例如，有监督与无监督)。参见图6。<br>本地化模式。刘等人[139]将二值分割图转换为边界框。最终输出是围绕显著对象的一组矩形。冯等人[57]使用剩余的图像部分将滑动窗口的显著性定义为其合成成本。基于图像的过分割，假设可以在所有滑动窗口中以暴力方式有效地找到的局部最大值对应于显著对象。<br>在许多以前的方法中，基本假设是在输入图像中存在至少一个显著对象。这可能不总是成立的，因为一些背景图像根本不包含显著对象。[205]在[205]中，Wang研究缩略图上显著对象的定位和预测问题。具体地说，通过在多个通道中提取的一组特征来描述每个图像。显著对象的存在被表示为一个二进制分类问题。对于定位，使用训练样本上的随机森林回归器来学习回归函数，以直接输出显著对象的位置。<br>细分模型。显著物体的分割与图形-背景问题密切相关，图形-背景问题本质上是一个试图将显著物体从背景中分离出来的二进制分类问题。余等人。[219]利用由不同的基于对比度的显著性模型生成的不完美显著图的互补特性。具体地说，首先为每个图像生成两个互补的显著图，包括草图状地图和包络状地图。草图状地图可以精确定位最显著对象的部分(即高精度的骨架)，而信封状地图可以大致覆盖整个显著对象(即召回率高的信封)。利用这两个映射图，可以首先从每幅图像中检测出可靠的前景和背景区域，以训练像素分类器。通过使用该分类器对所有其他像素进行标记，可以将显著对象作为一个整体进行检测。该方法在[190]中通过学习互补显著图来进行扩展，以达到显著对象分割的目的。<br>卢等人[144]利用先验的凸性(凹性)进行显著对象分割。该先验假设曲线边界的凸侧上的区域倾向于属于前景。基于这一假设，凹弧首先出现在超像素的轮廓上。对于凹圆弧，其凸性上下文被定义为紧靠圆弧的窗口。然后在具有凹弧的超像素上构建无向权重图，其中顶点之间的权重由图像分层分割中不同尺度上的凹度上下文的总和来确定。最后，执行归一化剪切算法[178]以将显著对象从背景中分离出来。<br>为了更有效地利用上下文线索，王等人。[203]提出将自动上下文分类器[193]集成到迭代能量最小化框架中以自动分割显著对象。自动上下文模型是针对每个像素及其周围环境的多层增强分类器，用于预测其是否与目标概念相关联。后续层构建在前一层的分类基础上。因此，通过分层学习过程，自动利用空间上下文来更准确地分割显著对象。<br>监督模型与非监督模型的对比。现有的基于学习的显著性检测工作大多集中在有监督的场景下，即在给定一组带有基本事实注释的训练样本的情况下学习显著对象检测器。这里的目的是将显著元素与背景元素分开。<br>输入图像中的每个元素(例如，像素或区域)由特征向量f∈rd表示，其中D是特征维度。然后，基于所学习的线性或非线性映射函数f：rd∈R+，将这样的特征向量映射到显著性分数的→R+。<br>可以假设映射函数f是线性的，即，s=wtf，其中w表示特征向量中所有分量的组合权重。刘等人。[139]提出用条件随机场(CRF)模型对显著对象的矩形标注进行训练来学习权重。在最近的工作[143]中，采用大边际框架来学习权重w。<br>然而，由于显著性机制的高度非线性本质，线性映射可能不能很好地捕捉显著性特征。为此，在[97]中扩展了这样的线性积分，其中采用线性支持向量机(SVM)的混合来将特征空间划分成使用分而治之策略线性可分的一组子区域。在每个区域中，学习线性支持向量机、其混合权重和显著性特征的组合参数，以便更好地估计显著性。可替换地，也利用其他非线性分类器，诸如增强型决策树(BDT)[99,153]和随机森林(RF)[87]。<br>一般来说，与启发式方法相比，有监督的方法允许对元素进行更丰富的表示。在有监督的显著目标检测的开创性工作中，刘等人[139]提出了一套包括局部多尺度对比度、区域中心-周围直方图距离和全局颜色空间分布的特征。与仅具有内在线索的模型类似，由于可以在区域级别提取更复杂的描述符，因此用于显著目标检测的基于区域的表示已变得越来越流行。Mehrani和V Eksler[153]通过考虑在图像分类等其他应用中广泛使用的通用区域属性，例如颜色和形状，展示了令人振奋的结果。蒋等人[87]提出了包含区域局部对比度、区域背景和区域类属属性的区域显著性描述符。在[99,143]中，每个区域由一组特征描述，例如局部和全局对比度、背景、空间分布和中心优先。在[143]中也考虑了预先注意的特征。<br>通常，更丰富的表示导致具有更高维度的特征向量，例如，在[87]中D=93，在[99]中D=75。在有大量训练样本的情况下，学习的分类器能够对最具区分性的样本进行分类(自动集成如此丰富的功能并进行提取)。因此，与启发式方法相比，可以期望更好的性能。<br>一些模型使用了非监督技术。[181]在概率框架中，显著性计算被表示为抽样问题。每个图像块的显著程度与其来自所有块的采样概率成正比，所有块都是从输入图像和从未标记图像语料库检索到的相似图像中提取的。[166]利用元胞自动机进行无监督显著目标检测。<br>聚合和优化模型。给定来自不同显著对象检测模型或输入图像的分层分割的M个显著图{Si}Mi=1，聚集模型试图形成更准确的显著图。设Si(X)表示第i个显著图的像素x的显著值。在[22]中，Borji et al.。提出一种标准的显著性聚合方法，具体如下：<br><img src="https://img-blog.csdnimg.cn/2020060819262669.png" alt="在这里插入图片描述"><br>其中Fx=(S1(X)，S2(X)，SM(X))是像素x的显著性得分，并且Sx=1指示x被标记为显著。ζ(·)是实值函数，可以采用以下形式：<br><img src="https://img-blog.csdnimg.cn/20200608192655171.png" alt="在这里插入图片描述"><br>受到[22]中聚集模型的启发，Mai等人[147]提出两种聚合解决方案。第一种方案采用像素聚合：<br><img src="https://img-blog.csdnimg.cn/202006081927276.png" alt="在这里插入图片描述"><br>其中λ={λi|i=1，。。。，M+1}是模型参数集，σ(Z)=1/(1+EXP(−z))。然而，要注意的是，这种直接聚集的一个潜在问题是它忽略了相邻像素之间的交互。受[140]的启发，他们提出了第二种解决方案，通过使用CRF聚合多种方法的显著图来捕捉相邻像素之间的关系。在训练数据的基础上，对CRF聚合模型的参数进行了优化。每个像素的显著性是被训练的CRF标记为显著的后验概率。<br>或者，严某等人提出了另一种观点。[216]将在图像的分层分割上计算的显著性图集成到树结构图形模型中，其中每个节点对应于每个分层中的一个区域。由于该树结构，可以使用信任传播来有效地进行显著性推理。实际上，求解三层分层模型相当于对所有单层地图应用加权平均。与朴素的多层融合不同，该分层推理算法可以为每个区域选择最优权重，而不是全局加权。<br>Li等人[123]提出对图像中所有超像素的显著度值进行优化，以同时满足视觉稀有性、中心偏倚和相互关联等几个显著标准。基于区域对之间的相关性(相似度得分)，当考虑所有其他超像素的影响时，用二次规划来优化每个超像素的显著度值。假设表示两个区域rii和rj之间的相关性，则显著值{si}ni=1(表示为s(Ri)，简称Sii)可以通过求解来优化：<br><img src="https://img-blog.csdnimg.cn/20200608192815760.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTg3NTE5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>其中DDIS是图像对角线长度的一半。DIJAND分别表示到RITO RJ和图像中心的空间距离。在优化过程中，考虑所有其他超像素的影响，采用二次规划的方法对每个超像素的显著度值进行优化。朱等人[231]还采用了类似的基于优化的框架以集成多个前景/背景线索以及平滑项，以自动推断最佳显著性值。<br>采用贝叶斯框架来更有效地整合互补的密集重建误差和稀疏重建误差[129]。在每对区域之间构造完全连接的高斯马尔可夫随机场以加强显著区域之间的一致性[84]，这导致了最终区域显著性得分的有效计算。<br>活动模型。受交互式分割模型(例如，[132,171])的启发，最近通过将SEC中提到的显著性检测的两个阶段显式解耦而出现了一种新的趋势。1.1：a)检测最显著的对象，b)分割它。一些研究提出利用固定预测和分割模型的优点进行主动分割。例如，Mishra等人。[154]组合多个提示(例如，颜色、强度、纹理、立体声和/或运动)以预测注视。然后，在极空间中分割固定点周围的显著对象的“最佳”闭合轮廓。Li等人[131]提出一个由两个部分组成的模型：提出候选区域的分割器和给每个区域一个显著分数的选择器(使用注视预测模型)。类似地，Borji[20]建议首先粗略地定位注视图(或其使用注视预测模型的估计)的峰值处的显著对象，然后使用超像素分割对象。后两种算法采用注释法确定分割性能的上界，提出场景中包含多个对象的数据集，并对注视预测和显著对象分割的内在联系提供了新的见解。<br>视频上的显著对象检测。除了空间信息之外，视频序列还提供时间提示，例如便于显著对象检测的运动。翟和沙[222]首先估计两个连续帧之间的关键点对应关系。运动对比度是基于图像之间的平面运动(单应)计算的，这是通过对点对应应用RANSAC来估计的。刘等人[141]将它们的空间显著特征[139]扩展到由光流算法产生的运动场。以彩色运动场为输入图像，计算局部多尺度对比度、区域中心-周围距离和全局空间分布，并进行线性积分。Rahtu等人[167]通过考虑时间相干性约束，将空间显著性整合到能量最小化框架中。Li等人[18]将基于区域对比度的显著性扩展到时空域。在给定视频序列的帧的过分割的情况下，基于每两个连续帧之间的颜色、纹理和运动特征在无向未加权匹配图上以交互方式估计它们之间的空间和时间区域匹配。不仅在当前帧中，而且在时域中，通过计算区域与周围区域的局部对比度来确定区域的显着性。<br>具有深度的显著目标检测。我们生活在真实的3D环境中，立体内容为引导视觉注意力和理解周围环境提供了额外的深度线索。这一点得到了Lang等人的进一步验证。[111]通过实验分析深度线索对眼睛注视预测的重要性。最近，研究人员已经开始研究如何利用深度线索来检测显著对象[49,160]，其可以间接地从立体图像中捕获或者直接使用深度照相机(例如，Kinect)来捕获。<br>最直接的扩展是采用SEC中引入的广泛使用的假设。2.1.1和2.1.2到深度通道，例如深度图[49,160]上的全局对比度。此外，Niu[160]演示如何利用立体摄影的领域知识来计算显著图。首先将输入图像分割成区域{ri}。在实践中，参加会议的地区通常被分配到小的或零的差异，以最大限度地减少收敛-适应冲突。因此，基于差异的第一种区域显著性被定义为：<br><img src="https://img-blog.csdnimg.cn/20200608193001363.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTg3NTE5OQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>光场上的显著目标检测。文献[126]提出了利用光场进行显著性检测的思想。使用专门设计的相机(例如Lytro)捕获的光场实质上是由观看场景的相机网格拍摄的图像阵列。光场数据为显著目标检测提供了两个好处：1)它允许合成一堆聚焦在不同深度的图像，2)它提供场景深度和遮挡的近似值。<br>有了这些额外的信息，Li等人[126]首先利用聚焦度和客观性先验信息稳健地选择背景和前景候选。具体地说，使用具有估计的背景似然分数的图层来估计背景区域。从Mean-Shift算法中选取前景似然分数高的区域作为显著目标候选。最后，利用估计的背景和前景在全聚焦图像上计算基于对比度的显著图。<br>最近在[227]中引入了一个新的具有挑战性的用于光场显著性分析的基准数据集，称为HFUT-Lytro。</p><h3 id="2-2新约：基于深度学习的模型"><a href="#2-2新约：基于深度学习的模型" class="headerlink" title="2.2新约：基于深度学习的模型"></a>2.2新约：基于深度学习的模型</h3><p>到目前为止，我们已经回顾的所有方法都旨在使用启发式算法来检测显著目标。虽然手工制作的功能允许实时检测性能，但它们存在几个缺点，这些缺点限制了它们在具有挑战性的场景中捕获显著对象的能力。<br>卷积神经网络(CNNs)[112]作为机器学习中最流行的工具之一，已经被应用于许多视觉问题，如目标识别[108]、语义分割[142]和边缘检测[213]。最近，已经表明当将CNNs[71,118]应用于显著目标检测时，CNNs也是非常有效的。由于其多层次和多尺度的特征，CNN能够在不使用任何先验知识(例如，段级信息)的情况下准确地捕获最显著的区域。此外，多层特征允许CNN更好地定位检测到的显著区域的边界，即使在存在阴影或反射的情况下也是如此。利用CNN强大的特征学习能力，提出了一系列从海量数据中学习显著性表示的算法。这些基于CNN的模型不断刷新几乎所有现有数据集的记录，并正在成为主流解决方案。这一小节的其余部分将致力于审查基于CNN的模型。<br>基于深度学习的显著目标检测模型基本上可以分为两大类。第一类包括使用多层感知器(MLP)进行显著性检测的模型。在这些模型中，输入图像通常被过度分割成单尺度或多尺度的小区域。然后，使用CNN来提取高层特征，然后将这些特征馈送到MLP来确定小区域的显著值。虽然高层特征是从CNN中提取的，但与完全卷积网络(FCNs)不同的是，由于使用了MLP，CNN特征中的空间信息不能被保留。为了突出这些方法与基于FCN的方法之间的区别，我们将它们称为“基于卷积网络的经典方法”(CCN-based)。第二类包括基于“完全卷积网络”(基于FCN)的模型。Long等人的开创性工作。[142]属于这一范畴，旨在解决语义切分问题。由于显著目标检测本质上是一项分割任务，许多研究人员采用了基于FCN的体系结构，因为它们具有保留空间信息的能力。<br>图7显示了基于CNN的显著性模型列表。</p><h4 id="2-2-1基于CCN的模型"><a href="#2-2-1基于CCN的模型" class="headerlink" title="2.2.1基于CCN的模型"></a>2.2.1基于CCN的模型</h4><p>基于一维(1D)卷积的方法。作为早期的尝试，等人[71]采用基于区域的方法学习超像素的特征表示。与像素级CNN相比，他们的方法大大降低了计算代价，同时考虑了全局上下文。但是，用平均颜色表示超像素并不能提供足够的信息。此外，使用1D卷积和汇集操作很难完全恢复图像的空间结构，导致预测混乱，特别是当输入图像是复杂场景时。<br>利用本地和全球环境。Wang等人考虑局部和全局信息以更好地检测显著区域[202]。为此，设计了两个子网络，分别用于局部估计和全局搜索。首先使用深度神经网络(DNN-L)学习局部面片特征以确定每个像素的显著性值，然后进行细化操作以捕捉高层客观性。对于全局搜索，他们训练另一个深度神经网络(DNN-G)，使用各种全局对比度特征(如几何信息、全局对比度特征等)来预测每个显著区域的显著值。利用前K个候选区域使用加权和来计算最终的显著图。<br>在[229]与大多数经典的显著目标检测方法类似，在构建多上下文深度学习框架时，同时考虑了局部上下文和全局上下文。输入图像首先被馈送到全局上下文分支以提取全局对比度信息。同时，将作为超像素中心窗口的每个图像块馈送到局部上下文分支以获取局部信息。最后使用二进制分类器通过最小化预测值和地面真实标签之间的统一软最大损失来确定显著性值。采用特定于任务的预训练方案对设计的多上下文模型进行联合优化。<br>Lee等人[63]利用两个子网分别对低级和高级特征进行编码。它们首先提取每个超像素的若干特征，并将它们馈送到由1×1核大小的卷积层堆栈组成的子网络中。然后，使用标准的VGGNet[180]来捕获高级特征。低-和高层次特征被扁平化、拼接，最后馈送到一个两层的MLP中，以判断每个查询区域的显著性。<br>基于边界框的方法。[232]在[232]中，邹某等人提出了一种层次关联的丰富特征(HARF)提取器。为此，首先构建二叉分割树，用于提取分层图像区域并分析所有区域对之间的关系。然后，使用两种不同的方法来计算二叉分割树的叶节点处的区域的两种特征(HARF1和HARF2)。它们利用从RCNN[64]中提取的所有中间特征来捕捉每个图像区域的各种特征。利用这些高维基本特征，计算每个基本特征类型的局部区域对比度和边界区域对比度，以构建更紧凑的表示。最后，采用AdaBoost算法逐步组装弱决策树，构造复合强回归器。<br>Kim等人[100]设计了一种两分支CNN结构，分别获得粗级和细级斑块的粗细表示。选择性搜索[194]方法被用来生成多个区域候选，这些区域候选被视为双区域CNN的输入。将两个分支的特征表示的连接馈送到最终的完全连接层允许预测粗略的连续地图。为了进一步细化粗预测图，采用分层分割的方法来锐化边界，提高空间一致性。<br>[207]在[207]中，Wang 采用Fast R-CNN[64]框架解决显著目标检测问题。首先使用过分割和边缘保持方法将输入图像分割成多尺度区域。对于每个区域，使用外部边界框并将封闭区域馈送到Fast R-CNN。将由多个完全连通的层组成的小网络连接到ROI汇聚层，以确定每个区域的显著性值。最后，提出了一种基于边缘的传播方法来抑制背景区域，使得到的显著图更加均匀。<br>Kim等人[101]训练CNN以预测每个图像块的显著形状。选择性搜索法首先用来定位一堆图像块，每个图像块都作为CNN的输入。在预测每个面片的形状之后，通过累加预测形状类别的掩码与相应概率的乘积并平均所有区域建议来计算中间掩码MiI。为了进一步细化粗略预测图，采用了基于形状类的分层分割显著性检测算法(SCSD-HS)来融合更多的全局信息，这是显著性检测经常需要的。<br>Li等人[120]利用CNN中的高级特征和基于手工方法提取的低级特征。为了增强CNN的泛化能力和学习能力，通过在前两层加入局部响应归一化(LRN)对原R-CNN进行了重新设计。利用选择性搜索方法[194]来生成一堆正方形的补丁作为网络的输入。高层特征和低层特征都被馈送到L1铰链损失的支持向量机中，以帮助判断每个平方区域的显著性。<br>具有多比例输入的模型。Li等人[118]利用预先训练好的CNN作为特征提取器。给出一幅输入图像，他们首先将其分解成一系列不重叠的区域，然后将它们输入到具有三个不同比例输入的CNN中。然后使用三个子网来捕获不同规模的高级功能。<br>从三个尺度上的斑块获得的特征被连接起来，然后馈送到只有两个完全连通的层作为回归变量的小MLP中，以输出在二进制显著性标签上的分布。为了解决过分割不完善的问题，采用了一种基于超像素的显著性细化方法。<br>图8展示了许多流行的基于FCN的体系结构。图9列出了这些体系结构利用的不同类型的信息。<br>讨论。可以看出，上述基于MLP的作品主要依赖于段级信息(例如，图像补丁)和分类网络。这些图像块通常被调整到固定大小，然后被馈送到用于确定每个块的显著性的分类网络。某些模型使用多比例输入来提取多个比例的要素。然而，这样的学习框架不能充分利用高层语义信息。此外，空间信息不能传播到最后完全连通的层，从而导致全局信息丢失。</p><h4 id="2-2-2基于FCN的模型"><a href="#2-2-2基于FCN的模型" class="headerlink" title="2.2.2基于FCN的模型"></a>2.2.2基于FCN的模型</h4><p>与运行在补丁级别的基于CCN的模型不同，完全卷积网络(FCN)[142]考虑像素级操作来克服完全连通层造成的问题，例如显著对象边界附近的模糊和不准确的预测。由于模糊神经网络具有良好的性能，近年来出现了大量基于模糊神经网络的显著目标检测模型。<br>Li等人[119]设计具有两个互补分支的CNN：像素级全卷积流(FCS)和分段空间池流(SPS)。FCS在每一级的最后一卷积层之后引入一系列跳跃层，然后将这些跳跃层融合在一起作为FCS的输出。请注意，CNN的一个阶段由共享相同分辨率的所有层组成。SPS利用数据段级别信息进行空间池。最后，FCS和SPS的输出被融合在一起，随后是一个平衡的S形交叉熵损失层，如[213]中所做的那样。<br>刘[137]提出了两个子网络，以从粗到精和从全局到局部的方式生成预测地图。第一子网络可以被认为是编码器，其目标是生成粗略的全局预测。然后，使用由一系列递归卷积层组成的精化子网络将粗预测图从粗尺度细化到细尺度。<br>[187]在[187]中，Don同时考虑区域级显著性估计和像素级显著性预测。对于像素级预测，两条边路径连接到VGGNet的最后两个阶段，然后级联以学习多尺度特征。对于区域级别的估计，首先将每个给定图像过分割成多个超像素，然后使用Clarifai模型[221]进行预测每个超像素的显著程度。将原始图像和两个预测图作为输入到一个小的CNN，生成一个更有说服力的显著图作为最终输出。<br>Tang等人[188]以深度监督网络[113]为例，采用与整体嵌套边缘检测器[213]中类似的架构。与HED不同的是，它们将VGGNet中的原始卷积层替换为递归卷积层，以学习局部、全局和上下文信息。<br>在[110]中，Kuen 提出了一种利用空间变换和递归网络单元的两级CNN。首先使用卷积-反卷积网络来产生初始的粗显着图。空间变换网络[82]用于从原始图像中提取多个子区域，随后是一系列递归网络单元以逐步改进这些子区域的预测。<br>Kruthiventi等人[109]在统一的网络中考虑注视预测和显著目标检测两者。为了捕获多尺度语义信息，引入了四个初始模块[186]，它们分别连接到第二、第四、第五和第六阶段的输出。为了减少上采样的混叠效应，将这四个旁路连接在一起，并通过由两个卷积层组成的小网络。最后，利用S型交叉熵损失对模型进行优化。<br>Li等人[130]考虑联合语义分割和显著对象检测。与FCN工作[142]类似，用卷积层代替VGGNet[180]中原有的两个全连通的层，利用SLIC[8]超像素在空间和特征维度上对超像素之间的拓扑关系进行建模，以克服CNN下采样操作造成的目标边界模糊问题。最后，利用图的拉普拉斯正则化非线性回归将CNN和超像素图的预测组合由粗级变为细级。<br>张某等人[225]使用由CNN提取的显著线索和多级融合机制来检测显著对象。Deeplab[37]架构首先用于捕获高级功能。为了解决Deeplab中步长过大的问题，采用了多尺度二值像素标记方法来改善空间一致性，类似于[118]。<br>Li等人的MSRNet[117]。同时考虑显著对象检测和实例级显著对象分割。多尺度CNN用于同时检测显著区域和轮廓。对于每个比例，上层的要素将与下层的要素合并以逐渐优化结果。为了生成等高线图，使用MCG[14]方法提取少量候选边界框和分割良好的区域，以帮助生成显著的对象实例分割。最后，使用完全连接的CRF模型[107]来精炼空间相干性。<br>侯等人[73]设计基于HED架构的自上而下模型[213]。与将独立的侧路连接到每一级的最后卷积层不同，引入了一系列短连接来在每对侧路之间建立牢固的关系。因此，具有强语义信息的上层特征被传播到下层，帮助它们精确定位显著对象的准确位置。同时，来自较低层的丰富的详细信息使得来自较深层的不规则预测图得以细化。利用一种特殊的融合机制来更好地组合由不同旁路预测的显著图。<br>讨论。上述方法都是基于完全卷积网络的，这使得点对点学习和端到端训练策略成为可能。与基于CCN的模型相比，这些方法更好地利用了卷积运算，大大降低了时间开销。更重要的是，最近利用CNN特征的基于FCN的方法[73,117]远远优于那些使用段级信息的方法。<br>综上所述，利用基于FCN的模型进行显著性检测具有以下3个优点。<br>1)本地与全局。正如中2.2.1提到的。较早的基于CNN的模型显式地(嵌入在单独的网络[118,201,229]中)或隐式地(使用端到端框架)合并了本地和全局上下文信息。这确实与前面几节回顾的许多手工制作的线索背后的设计原则是一致的。然而，基于FCN的方法能够在内部学习局部和全局信息。较低的层倾向于编码更详细的信息，如边缘和精细组件，而较深的层倾向于全局的和语义上有意义的信息。这些特性使基于FCN的网络的性能大大优于传统方法。<br>2)预训微调。精调预先训练的网络的有效性已经在许多不同的应用中得到了证明。该网络通常预先训练在ImageNet数据集[173]上用于图像分类。通过简单的微调，可以将学习到的知识应用于几个不同的目标任务(例如，对象检测[64]、对象定位[161])。在显著对象检测[119,229]中已经采用了类似的策略，并且与从头开始的训练相比已经产生了更好的性能。更重要的是，所学习的特征能够捕获关于对象类别的高级语义知识，因为所使用的网络是针对场景进行预训练和目标分类任务。<br>3)多种多样的体系结构。CNN体系结构由一堆不同的层组成，这些层通过可微函数将输入图像转换为输出地图。FCN的多样性使设计者可以设计适合它们的不同结构。<br>尽管取得了巨大的成功，但基于FCN的模型在几种情况下仍然失败。典型的示例包括具有透明对象的场景、前景和背景之间的低对比度以及复杂的背景，如[73]所示。这就要求在未来开发更强大的体系结构。<br>图10提供了经典模型和基于CNN的模型生成的地图的可视比较。</p><h3 id="3-突出目标检测的三个应用"><a href="#3-突出目标检测的三个应用" class="headerlink" title="3.突出目标检测的三个应用"></a>3.突出目标检测的三个应用</h3><p>显著目标检测模型的价值在于其在计算机视觉、图形学和机器人学的许多领域中的应用。显著对象检测模型已被用于若干应用，例如对象检测和识别[21，25，94，155，168，174，176]，图像和视频压缩[68，79]，视频摘要[83，114，145]，照片拼贴/媒体重定向/剪切/缩略图[65，77，200]，图像质量评估[116，134，159]，图像分割[51，92，127，165]，基于内容的图像检索和图像集合浏览[38，58，125，185]。60、62、103、122、183、223]、对象发现[59、95]和人-机器人交互[152、184]。图11显示了示例应用程序。</p><h3 id="4-数据集和评估度量"><a href="#4-数据集和评估度量" class="headerlink" title="4.数据集和评估度量"></a>4.数据集和评估度量</h3><h4 id="4-1显著对象检测数据集"><a href="#4-1显著对象检测数据集" class="headerlink" title="4.1显著对象检测数据集"></a>4.1显著对象检测数据集</h4><p>随着越来越多的模型在文献中被提出，更多的数据集被引入来进一步挑战显著性检测模型。早期的尝试旨在收集具有用边界框注释的显著对象(例如，MSRA-A和MSRA-B[139])的图像，而稍后的努力用像素方式的二进制掩码(例如，ASD[6]和DUT-OMRON[218])注释这些显著对象。通常，可以使用精确蒙版进行注释的图像只包含有限的对象(通常是一个)和简单的背景区域。相反，最近已经尝试在复杂和杂乱的背景中收集具有多个对象的数据集(例如，[20，29,131])。正如我们在简介部分中提到的，当同一场景中存在多个候选对象时，需要更复杂的机制来确定最突出的对象。例如，Borji[20]和Li等人[131]使用人体注视图的峰值来确定哪个物体是最突出的物体(即，人类看得最多的物体；参见第1.2节)。<br>Tab中示出了22个显著对象数据集的列表，其中包括20个图像数据集和2个视频数据集。12.请注意，这些数据集中的所有图像或视频帧都用二进制掩码或矩形进行注释。经常要求对象用一个对象来标记图像中的显著对象(例如，[139])，或者注释几个候选对象中最显著的一个(例如，[29])。一些图像数据集还提供在自由观看任务期间收集的每个图像的固定数据。</p><h4 id="4-2评估办法"><a href="#4-2评估办法" class="headerlink" title="4.2评估办法"></a>4.2评估办法</h4><p>下面描述用于评估显著对象检测模型的五个普遍同意的、标准的和易于计算的度量。为简单起见，我们使用S来表示归一化到[0,255]的预测显著图，G是显著对象的地面真实二值掩码。对于二进制掩码，我们使用|·|来表示掩码中非零条目的数量。<br>精度召回(PR)A显著图S首先被转换成二进制掩码M，然后通过将M与地面真相G进行比较来计算P个累加和召回：<br><img src="https://img-blog.csdnimg.cn/20200608194639937.png" alt="在这里插入图片描述"><br>S的二值化是评价的关键步骤。执行二进制化有三种流行的方法。在第一个解决方案中，Achanta等人。[6]提出了图像相关的自适应阈值对S进行二值化，该阈值的计算是S的平均显著性的两倍：</p><p><img src="https://img-blog.csdnimg.cn/20200608194659978.png" alt="在这里插入图片描述"><br>其中W和H分别是显著图S的宽度和高度。<br>对S进行二进制化的第二种方法是使用从0到255的阈值。对于每个阈值，对于每一个(Precision, Recall)分数被计算并用于绘制精确度-召回(PR)曲线。<br>执行二值化的第三种方式是使用类似GrabCut的算法(例如，如[43]中所示)。这里，首先计算PR曲线，并选择导致95%召回率的阈值。利用该阈值，生成初始二进制掩码，该初始二进制掩码可用于初始化迭代GrabCut分割[171]。经过几次迭代之后，可以逐渐细化二进制掩码。<br>F度量通常情况下，无论是P累进还是回忆都不能完全评估显著图的质量。为此，建议将F-测度作为具有非负权重β2的P重现和回忆的加权调和平均值：<br><img src="https://img-blog.csdnimg.cn/20200608194829912.png" alt="在这里插入图片描述"><br>正如许多显著目标检测工作(例如，[6])中所建议的那样，β2通常被设置为0.3以更多地加权P个累积量。原因是召回率不如精确度重要(另见[140])。例如，通过将整个地图设置为前景，可以很容易地实现100%的召回。<br>接收器操作特征(ROC)曲线如上所述，当用一组固定阈值将显著图二值化时，可以计算出假阳性(F P R)和真阳性率(T P R)：<br><img src="https://img-blog.csdnimg.cn/20200608194858366.png" alt="在这里插入图片描述"><br>其中M和G分别表示二进制掩码M和地面真值G的反面。ROC曲线是通过测试所有可能的阈值绘制的T-P-R与F-P-R的曲线图。<br>ROC曲线(AUC)下的区域虽然ROC是模型性能的2D表示，但AUC将这些信息提取到单个标量中。顾名思义，它被计算为ROC曲线下的面积。完美模型的AUC得分为1，而随机猜测的AUC得分约为0.5。<br>平均绝对误差(MAE)上面介绍的基于重叠的评估措施没有考虑真正的负显著分配，即，正确地标记为不显著的像素。他们倾向于成功地将高显着性分配给显着性像素，但未能检测到非显着性区域的方法。此外，对于某些应用[15]，加权连续显著图的质量可能比二进制掩码更令人关注。为了进行更全面的比较，建议评估连续显著图S和二进制地面实况G之间的平均绝对误差(MAE)，两者都在[0，1]范围内归一化。MAE分数定义为：<br><img src="https://img-blog.csdnimg.cn/20200608194948864.png" alt="在这里插入图片描述"></p><h3 id="5-讨论"><a href="#5-讨论" class="headerlink" title="5.讨论"></a>5.讨论</h3><h4 id="5-1设计选择"><a href="#5-1设计选择" class="headerlink" title="5.1设计选择"></a>5.1设计选择</h4><p>在过去的二十年里，人们已经提出了数百种基于经典和深度学习的方法来检测和分割场景中的显著目标，并探索了大量的设计选择。虽然最近取得了很大的成绩，但还有很大的改进空间。我们详细的方法总结(见图4和图5)确实发出了一些关于常用设计选择的明确信息，这对未来算法的设计是有价值的。接下来将讨论它们。</p><h4 id="5-1-1启发式与从数据中学习"><a href="#5-1-1启发式与从数据中学习" class="headerlink" title="5.1.1启发式与从数据中学习"></a>5.1.1启发式与从数据中学习</h4><p>早期的方法主要基于启发式(局部或全局)线索来检测显著对象[6，43,164,218]。最近，基于学习算法的显著性模型已经被证明是非常有效的(参见表4和Tab5)。在这些模型中，基于深度学习的方法由于能够从大数据集中学习大量的外部线索而大大优于传统的启发式方法。用于显著对象检测的数据驱动方法似乎具有令人惊讶的良好的泛化能力。然而，一个新出现的问题是，用于显著对象检测的数据驱动的想法是否与这些模型的易用性相冲突。大多数基于学习的方法只在MSRA5K数据集的一小部分上进行训练，并且在所有其他具有相当大差异的数据集上的性能仍然一致地优于其他方法。这表明，在不丧失简单性和易用性优势的情况下，尤其是从应用程序的角度来看，值得进一步探索数据驱动的显著对象检测。</p><h4 id="5-1-2手工制作的功能与基于CNN的功能"><a href="#5-1-2手工制作的功能与基于CNN的功能" class="headerlink" title="5.1.2手工制作的功能与基于CNN的功能"></a>5.1.2手工制作的功能与基于CNN的功能</h4><p>第一代基于学习的方法基于许多手工制作的功能。这些方法的一个明显缺点是泛化能力，特别是当应用于复杂的杂乱场景时。此外，这些方法主要依赖过度分割算法，如SLIC[8]，导致大多数具有高对比度分量的显著对象的不完备性。基于CNN的模型在一定程度上解决了这些问题，即使在考虑复杂场景的情况下也是如此。由于CNN具有学习多层特征的能力，因此很容易精确定位显著目标的位置。诸如边缘的低级特征使得能够锐化显著对象的边界，而高级特征允许结合语义信息来标识显著对象。</p><h4 id="5-1-3基于CNN的显著性检测的最新进展"><a href="#5-1-3基于CNN的显著性检测的最新进展" class="headerlink" title="5.1.3基于CNN的显著性检测的最新进展"></a>5.1.3基于CNN的显著性检测的最新进展</h4><p>最近提出了各种基于CNN的架构。在这些方法中，有几个有希望的选择可以在未来进一步探索。第一个是对模特进行深度监督。如[73]所示，深度监督网络增强了不同层功能的力量。第二种选择是编解码器体系结构，该体系结构已被许多分割相关任务所采用。这些类型的方法逐渐将高层特征反向传播到较低层，从而允许多层特征的有效融合。另一种选择是利用更强大的基线模型，例如使用非常深的ResNet[70]而不是VGGNet[180]。</p><h3 id="5-2数据集偏差"><a href="#5-2数据集偏差" class="headerlink" title="5.2数据集偏差"></a>5.2数据集偏差</h3><p>数据集在显著性检测的快速发展中起着重要作用。一方面，它们提供了大规模的训练数据，并能够比较竞争算法的性能。另一方面，每个数据集都是不受限制的应用程序域的唯一采样，并且包含一定程度的偏差。<br>到目前为止，似乎对数据集的底层结构中存在偏差(即偏度)达成了一致的一致意见。因此，一些研究已经解决了图像数据集中偏差的影响。例如，Torralba和Efros在计算机视觉数据集中识别了三种偏差，即：选择偏差、捕获偏差和负集偏差[191]。选择偏差是由于在数据采集过程中对特定类型图像的偏好造成的。它会在数据集中产生定性上相似的图像。最常用的显著对象基准数据集[6]中的强烈颜色对比度(见[43,131])证明了这一点。因此，优选数据集构建中的两种实践：i)具有独立的图像选择和注释过程[131]，以及ii)首先检测最显著的对象，然后对其进行分割。负集偏差是缺乏丰富、公正的负集的结果，也就是说，人们应该避免将注意力集中在感兴趣的特定图像上，而数据集应该代表整个世界。通过将注释者的个人偏好融入到某些对象类型中，负集偏差可能会影响地面实况。因此，在构建良好的数据集时，鼓励包含各种图像。捕捉偏差传达图像合成对数据集的影响。这种偏向最普遍的一种是在图像的中心区域合成对象的倾向，即中心偏向。数据集中存在的偏差使得定量比较非常具有挑战性，有时甚至具有误导性。例如，由高斯斑点组成的平凡显著性模型在图像中心，得分通常高于许多注视预测模型[28，93,189]。</p><h3 id="5-3未来方向"><a href="#5-3未来方向" class="headerlink" title="5.3未来方向"></a>5.3未来方向</h3><p>讨论了构建更有效的模型和基准的几个有前途的研究方向。</p><h4 id="5-3-1超越处理单个图像"><a href="#5-3-1超越处理单个图像" class="headerlink" title="5.3.1超越处理单个图像"></a>5.3.1超越处理单个图像</h4><p>本研究中讨论的大多数基准和显著性模型都处理单个图像。不幸的是，较少探索多个输入图像上的显著对象检测，例如，视频序列上的显著对象检测、共显著对象检测、以及深度和光场图像上的显著对象检测。这背后的一个原因是关于这些问题的基准数据集的可获得性有限。例如，如SEC中所述。4、只有两个公开可用的视频显著性基准数据集(主要是卡通和新闻)。对于这些视频，仅为关键帧提供边界框以粗略定位显著对象。多模式数据正变得越来越容易获得和负担得起。集成诸如时空一致性和深度等附加线索将有利于有效的显著目标检测。</p><h4 id="5-3-2实例级醒目对象检测"><a href="#5-3-2实例级醒目对象检测" class="headerlink" title="5.3.2实例级醒目对象检测"></a>5.3.2实例级醒目对象检测</h4><p>现有的显著模型是对象不可知的(即，它们不将显著区域分割成对象)。然而，人类拥有在实例级别检测显著对象的能力。实例级显著性在多个应用程序中非常有用，例如图像编辑和视频压缩.<br>用于实例级显著性检测的两种可能的方法如下。第一种涉及使用对象检测或对象建议方法(例如，FastRCNN[64])来提取候选对象边界框的堆栈，然后分割其中的显著对象。第二种方法最初在[117]中提出，它利用边缘信息来区分不同的显著对象。</p><h4 id="5-3-3-多功能网络架构"><a href="#5-3-3-多功能网络架构" class="headerlink" title="5.3.3 多功能网络架构"></a>5.3.3 多功能网络架构</h4><p>随着人们对CNNs认识的加深，越来越多有趣的网络结构被开发出来。已经表明，使用高级基线模型和网络体系结构[119]可以显著提高性能。一方面，更深层次的网络确实有助于更好地捕获显著对象，因为它们具有提取高级语义信息的能力。另一方面，除了高层信息外，还应考虑低层特征[73,117]来构建高分辨率显著图。</p><h4 id="5-3-4未回答的问题"><a href="#5-3-4未回答的问题" class="headerlink" title="5.3.4未回答的问题"></a>5.3.4未回答的问题</h4><p>剩下的一些问题包括：必须有多少(显著的)对象来表示场景？地图平滑是否会影响分数和模型排名？显著目标检测与其他领域有何不同？在模型评估中解决中心偏差的最好方法是什么？模型和人类之间剩下的差距是什么？与其他相关领域(如注视预测的显著性、场景标记和分类、语义分割、对象检测和对象识别)的协作参与可以帮助回答这些问题，更好地定位该领域，并确定未来的方向。</p><h3 id="6总结和结论"><a href="#6总结和结论" class="headerlink" title="6总结和结论"></a>6总结和结论</h3><p>在这篇文章中，我们详尽地回顾了与其密切相关的重要目标检测方面的文献。检测和分割显著对象是非常有用的。图像中的对象自动比背景中的东西(如草、树和天空)吸引更多的注意力。因此，如果我们能够先检测到显著或重要的物体，那么我们就可以在下一阶段进行详细的推理和场景理解。与传统的专用目标检测器相比，显著性模型是通用的，通常速度很快，并且不需要大量的注释。这些属性允许以低成本处理大量图像。<br>探索显著目标检测和注视预测模型之间的联系有助于提高这两种模型的性能。在这一点上，同时提供对人类的显著对象判断和眼睛运动的数据集是非常理想的。进行行为研究，以了解人类如何感知场景中的对象并确定其优先顺序，以及这一概念与语言、场景描述和字幕、视觉问题回答、属性等之间的关系，可以提供无价的洞察力。此外，将更多的注意力放在评估和比较重要的对象模型上，以衡量未来的进展，这一点至关重要。解决数据集偏差，如中心偏差和选择偏差，并转向更具挑战性的图像是很重要的。<br>虽然近几年显著目标检测和分割方法取得了长足的进步，但是对于几乎所有图像都能产生高质量结果的非常健壮的显著目标检测算法仍然缺乏。即使对人类来说，图像中最突出的物体是什么，有时也是一个相当模棱两可的问题。为此，我们有一个一般性的建议：<br>不要问细分市场能为你做什么，而要问你能为细分市场做些什么。-吉滕德拉·马利克(Jitendra Malik)<br>对于构建健壮的算法尤为重要。例如，当处理有噪声的互联网图像时，尽管显著对象检测和分割方法不能保证对单个图像的稳健性能，但是它们的效率和简单性使得能够自动地处理大量的图像。这允许出于可靠性和准确性的目的对图像进行过滤，稳健地运行应用程序[38，42，43，47，77,136]，以及无监督学习[230]。</p>]]></content>
    
    
    <categories>
      
      <category>机器学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>机器学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>事件循环机制</title>
    <link href="/2021/01/06/%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E6%9C%BA%E5%88%B6/"/>
    <url>/2021/01/06/%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%E6%9C%BA%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<p>在看到面试的时候的高频问题，今天我们就来深入的了解事件循环机制，因为之前总是看到，总是会忘记，今天就认真的总结出一篇专栏。</p><a id="more"></a><p>Js是单线程的解释性语言，在执行任务的过程中。但是在执行任务的时候会有<code>同步任务</code>和<code>异步任务</code>之分。</p><ul><li>所有的同步任务会在主线程上先执行。</li><li>并且异步的任务会被放在<code>even table</code>中被注册，注册之后会函数被移入到<code>event queue</code></li><li>当主线程完成完毕之后，会把event queue里读取对应的函数进入主线程进行执行。</li><li>上述过程不断重复就是常说的事件循环机制。</li></ul><p>如果又有异步的事件，会继续分发到对应的队列中，继续执行。其中就出现了<code>宏任务</code>和<code>微任务</code>的区分。但是我自己的理解是，<code>宏任务</code>和<code>微任务</code>的交替才构成了事件循环。</p><p>下文是从网上一篇文章中摘录的例子，看到评论区对于一些细节的争执，本着实践出真知的原则，我去拿来实践了一下。</p><p>原文链接：<a href="https://www.jianshu.com/p/12b9f73c5a4f/">https://www.jianshu.com/p/12b9f73c5a4f/</a></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;golb1&#x27;</span>);<span class="hljs-comment">//同步任务，第一个被执行</span><br><br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<span class="hljs-comment">//setTimeout作为任务分发器，将任务分发到了宏任务队列</span><br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;timeout1&#x27;</span>);<span class="hljs-comment">//第一轮的循环结束，第二轮的开始，将timeout1输出</span><br>    process.nextTick(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<span class="hljs-comment">//第二轮，将对于的nextTick输出到对应的微任务队列中</span><br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;timeout1_nextTick&#x27;</span>);<br>    &#125;)<br>    <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">resolve</span>) </span>&#123; <span class="hljs-comment">//输出timeout1_promise,promise也进微任务</span><br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;timeout1_promise&#x27;</span>);<br>        resolve();<br>    &#125;).then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;timeout1_then&#x27;</span>)<br>    &#125;)<br>&#125;)<br><br>setImmediate(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<span class="hljs-comment">//同样存在宏任务中</span><br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;immediate1&#x27;</span>);<br>    process.nextTick(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;immediate1_nextTick&#x27;</span>);<br>    &#125;)<br>    <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">resolve</span>) </span>&#123;<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;immediate1_promise&#x27;</span>);<br>        resolve();<br>    &#125;).then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;immediate1_then&#x27;</span>)<br>    &#125;)<br>&#125;)<br><br>process.nextTick(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<span class="hljs-comment">//被存放在微任务队列</span><br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;glob1_nextTick&#x27;</span>);<br>&#125;)<br><span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">resolve</span>) </span>&#123;<span class="hljs-comment">//new的promise的实例化过程中，还是属于同步的</span><br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;glob1_promise&#x27;</span>);<span class="hljs-comment">//第二个输出了glob1_promise</span><br>    resolve();<span class="hljs-comment">//改变状态，将then推入微任务队列</span><br>&#125;).then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<span class="hljs-comment">//很快啊，马上在这个宏任务结束后，就立马执行了微任务</span><br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;glob1_then&#x27;</span>)<br>&#125;)<br><br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<span class="hljs-comment">//被存放在了微任务队列</span><br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;timeout2&#x27;</span>);<br>    process.nextTick(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;timeout2_nextTick&#x27;</span>);<br>    &#125;)<br><span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">resolve</span>) </span>&#123;<span class="hljs-comment">//这里是实例化如同上面的原理</span><br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;timeout2_promise&#x27;</span>);<span class="hljs-comment">//这里输出了glob1_promise</span><br>        resolve();<br>    &#125;).then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<span class="hljs-comment">//将then推入微任务队列</span><br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;timeout2_then&#x27;</span>)<br>    &#125;)<br>&#125;)<br><br>process.nextTick(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<span class="hljs-comment">//存放在了微任务队列</span><br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;glob2_nextTick&#x27;</span>);<br>&#125;)<br><span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">resolve</span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;glob2_promise&#x27;</span>);<br>    resolve();<br>&#125;).then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;glob2_then&#x27;</span>)<br>&#125;)<br><br>setImmediate(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<span class="hljs-comment">//放在了宏任务队列中</span><br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;immediate2&#x27;</span>);<br>    process.nextTick(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;immediate2_nextTick&#x27;</span>);<br>    &#125;)<br>    <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">resolve</span>) </span>&#123;<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;immediate2_promise&#x27;</span>);<br>        resolve();<br>    &#125;).then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;immediate2_then&#x27;</span>)<br>    &#125;)<br>&#125;)<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">(node.js v12.16.2的结果)</span><br><span class="hljs-comment">输出结果：</span><br><span class="hljs-comment">golb1</span><br><span class="hljs-comment">同步任务，先输出得到glob1没有问题</span><br><span class="hljs-comment">glob1_promise</span><br><span class="hljs-comment">promise在实例化的过程中，他会被执行。然后输出到glob1_promise</span><br><span class="hljs-comment">glob2_promise</span><br><span class="hljs-comment">这里的输出和上面的原理一致。</span><br><span class="hljs-comment">glob1_nextTick</span><br><span class="hljs-comment">到这里为止，此时的微任务队列中既有nextTick又有Promise，其中的nextTick队列是会被优先执行，这里是我从网上看到的，然后实践的时候，我有这样的思考，因为我的nextTick和promise是交替出现的，但是到微任务的处理时候，是两个nextTick先执行了，那么说，每个异步任务有他自己的一个任务队列存在的。这样才会存在同时输出了nextTick，同时也能印证nextTick队列的优先级别是比Promise.then队列高的。</span><br><span class="hljs-comment">glob2_nextTick</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">glob1_then</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">glob2_then</span><br><span class="hljs-comment">至此为止，当前的可执行的微任务执行完毕了，这一轮的循环也结束了。下一轮的循环从宏任务开始执行。</span><br><span class="hljs-comment">timeout1</span><br><span class="hljs-comment">第二轮循环的时候，将timeout1输出</span><br><span class="hljs-comment">timeout1_promise</span><br><span class="hljs-comment">此处的promise和上面一样</span><br><span class="hljs-comment">timeout1_nextTick</span><br><span class="hljs-comment">此时的结果，让我们印证了一个想法，那就是宏任务的队列是不会执行完，再去执行微任务的，他是在宏任务完成一个是时候，此时会先坚持微任务的队列，如果微任务的队列不空的话，立刻去执行微任务队列。</span><br><span class="hljs-comment">timeout1_then</span><br><span class="hljs-comment">顺序的nextTick会比Promise.then优先级高，不奇怪，剩下的也顺理成章了。同时在试验过程中。我还尝试着调换了位置，比如nextTick和promise的位置，以及timeout和immediate的位置，结果并没有发生改变，说明了这几种的优先顺序是timeout&gt;immediate的。</span><br><span class="hljs-comment">timeout</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">timeout2_promise</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">timeout2_nextTick</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">timeout2_then</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">immediate1</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">immediate1_promise</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">immediate1_nextTick</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">immediate1_then</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">immediate2</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">immediate2_promise</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">immediate2_nextTick</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">immediate2_then</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><p>下面给一个链接，链接里的图画的比较符合实际：</p><p><a href="https://www.cnblogs.com/amiezhang/p/11349450.html">https://www.cnblogs.com/amiezhang/p/11349450.html</a></p>]]></content>
    
    
    <categories>
      
      <category>javascript</category>
      
    </categories>
    
    
    <tags>
      
      <tag>javascript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>拼多多笔试、面试</title>
    <link href="/2021/01/05/%E6%8B%BC%E5%A4%9A%E5%A4%9A%E7%AC%94%E8%AF%95/"/>
    <url>/2021/01/05/%E6%8B%BC%E5%A4%9A%E5%A4%9A%E7%AC%94%E8%AF%95/</url>
    
    <content type="html"><![CDATA[<a id="more"></a><h5 id="1、我想想考察了啥，好像是排序算法的时间复杂度和稳定性"><a href="#1、我想想考察了啥，好像是排序算法的时间复杂度和稳定性" class="headerlink" title="1、我想想考察了啥，好像是排序算法的时间复杂度和稳定性"></a>1、我想想考察了啥，好像是排序算法的时间复杂度和稳定性</h5><table><thead><tr><th>排序算法</th><th>平均时间复杂度</th><th>最坏时间复杂度</th><th>空间复杂度</th><th>是否稳定</th></tr></thead><tbody><tr><td>冒泡排序</td><td>O（n2）</td><td>O（n2）</td><td>O（1）</td><td>是</td></tr><tr><td>选择排序</td><td>O（n2）</td><td>O（n2）</td><td>O（1）</td><td>不是</td></tr><tr><td>直接插入排序</td><td>O（n2）</td><td>O（n2）</td><td>O（1）</td><td>是</td></tr><tr><td>归并排序</td><td>O(nlogn)</td><td>O(nlogn)</td><td>O（n）</td><td>是</td></tr><tr><td>快速排序</td><td>O(nlogn)</td><td>O（n2）</td><td>O（logn）</td><td>不是</td></tr><tr><td>堆排序</td><td>O(nlogn)</td><td>O(nlogn）</td><td>O（1）</td><td>不是</td></tr><tr><td>希尔排序</td><td>O(nlogn)</td><td>O（ns）</td><td>O（1）</td><td>不是</td></tr><tr><td>计数排序</td><td>O(n+k)</td><td>O(n+k)</td><td>O(n+k)</td><td>是</td></tr><tr><td>基数排序</td><td>O(N∗M）</td><td>O(N∗M)</td><td>O(M)</td><td>是</td></tr></tbody></table><h5 id="2、还考察了手写promise-all"><a href="#2、还考察了手写promise-all" class="headerlink" title="2、还考察了手写promise.all()"></a>2、还考察了手写promise.all()</h5><p>首先promise.all()会异promise数组的形式传入一组promise,把Promise实例包装成一个新的Promise，同时，成功和失败的返回值是不一样的，成功的时候返回的是一个结果数组，而失败的时候返回最先被reject的失败状态的值。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 手写一个promise.all()</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;Promise&#125;</span> </span>promises </span><br><span class="hljs-comment"> */</span><br><span class="hljs-built_in">Promise</span>.myall = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">promises</span>)</span>&#123;<br>    <span class="hljs-keyword">const</span> values = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(promises.length)<br>    <span class="hljs-keyword">var</span> resolvedCount = <span class="hljs-number">0</span>;<span class="hljs-comment">//计状态为resolved的promise的数量</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>) =&gt;</span>&#123;<br>        promises.foreach(<span class="hljs-function">(<span class="hljs-params">p,index</span>)=&gt;</span>&#123;<br>            promises.resolve(p).then(<br>                value =&gt;&#123;<br>                    <span class="hljs-comment">//p的状态为resolved，将值保存起来</span><br>                    values[index] = value<br>                    resolvedCount++;<br>                    <span class="hljs-comment">//如果状态全部都为resolved状态，return的promise的状态为resolve</span><br>                    <span class="hljs-keyword">if</span>(resolvedCount === promises.length)&#123;<br>                        resolve(values)<br>                    &#125;<br>                &#125;,<br>                reason =&gt;&#123;<br>                    reject(reason);<br>                &#125;)<br>        &#125;)<br>    &#125;)<br>&#125;<br><br><span class="hljs-comment">//写法二</span><br><span class="hljs-built_in">Promise</span>.all = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">arrPromise</span>)</span>&#123;<br>    <span class="hljs-keyword">let</span> list = [];<br>    <span class="hljs-keyword">let</span> len = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">let</span> hasErr = <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>) =&gt;</span>&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>;i &lt; arrPromise.length;i++)&#123;<br>            arrPromise[i].then(<span class="hljs-function"><span class="hljs-params">data</span>=&gt;</span>&#123;<br>                list[i] = data<br>                len++<br>                <span class="hljs-keyword">if</span>(len === arrPromise.length)<br>                resolve(list)<br>            &#125;,<span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span>&#123;<br>                <span class="hljs-keyword">if</span>(!hasErr)<br>                reject(error)<br>                hasErr = <span class="hljs-literal">true</span>;<br>            &#125;)<br>        &#125;<br>    &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><p>扩展：那咱们再手写一个promise.race()</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">Promise</span>.all = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">arrPromise</span>)</span>&#123;<br>    <span class="hljs-keyword">let</span> list = [];<br>    <span class="hljs-keyword">let</span> len = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">let</span> hasErr = <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>) =&gt;</span>&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>;i &lt; arrPromise.length;i++)&#123;<br>            arrPromise[i].then(<span class="hljs-function"><span class="hljs-params">data</span>=&gt;</span>&#123;<br>                list[i] = data<br>                len++<br>                <span class="hljs-keyword">if</span>(len === arrPromise.length)<br>                resolve(list)<br>            &#125;,<span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span>&#123;<br>                <span class="hljs-keyword">if</span>(!hasErr)<br>                reject(error)<br>                hasErr = <span class="hljs-literal">true</span>;<br>            &#125;)<br>        &#125;<br>    &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="3、判断程序输出"><a href="#3、判断程序输出" class="headerlink" title="3、判断程序输出"></a>3、判断程序输出</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params"></span>)</span>&#123;<br>    <span class="hljs-keyword">return</span><span class="hljs-function">()=&gt;</span>&#123;<br>        <span class="hljs-keyword">return</span><span class="hljs-function">() =&gt;</span>&#123;<br>            <span class="hljs-keyword">return</span><span class="hljs-function">()=&gt;</span>&#123;<br>                <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;id: &quot;</span>,<span class="hljs-built_in">this</span>.id);<br>            &#125;;<br>        &#125;;<br>    &#125;;<br>&#125;<br><span class="hljs-keyword">var</span> f = foo.call(&#123;<span class="hljs-attr">id</span>: <span class="hljs-number">1</span>&#125;);<br><span class="hljs-keyword">var</span> t1 = f.call(&#123;<span class="hljs-attr">id</span>: <span class="hljs-number">2</span>&#125;)()();<br><span class="hljs-keyword">var</span> t2 = f().call(&#123;<span class="hljs-attr">id</span>:<span class="hljs-number">3</span>&#125;)();<br><span class="hljs-keyword">var</span> t3 = f()().call(&#123;<span class="hljs-attr">id</span>:<span class="hljs-number">4</span>&#125;);<br><br>输出：<br>id:<span class="hljs-number">1</span><br>id:<span class="hljs-number">1</span><br>id:<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><h5 id="4、依然是程序判断题"><a href="#4、依然是程序判断题" class="headerlink" title="4、依然是程序判断题"></a>4、依然是程序判断题</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> promiseA = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span>&#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">&#x27;A&#x27;</span>);<br>&#125;)<br><span class="hljs-keyword">const</span> promiseB = promiseA.then(<br>    value =&gt; &#123;<br>        <span class="hljs-built_in">console</span>.log(value);<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(value);<br>    &#125;,<br>    error =&gt;&#123;<br>        <span class="hljs-built_in">console</span>.log(error.message);<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">Promise</span>.resolve(<span class="hljs-string">&#x27;B&#x27;</span>);<br>    &#125;<br>);<br><span class="hljs-keyword">const</span> promiseC = promiseB.then(<br>    value =&gt;&#123;<br>        <span class="hljs-built_in">console</span>.log(value);<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">Promise</span>.reject(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">&#x27;C&#x27;</span>));<br>    &#125;,<span class="hljs-function"><span class="hljs-params">error</span>=&gt;</span>&#123;<br>        <span class="hljs-built_in">console</span>.log(error.message);<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">&#x27;D&#x27;</span>);<br>    &#125;<br>).catch(<span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(error.message));<br><br>输出：<br>A<br>B<br>C<br></code></pre></td></tr></table></figure><h5 id="5、让你写一个dumpEsception，来处理未被处理的promise和throw的异常"><a href="#5、让你写一个dumpEsception，来处理未被处理的promise和throw的异常" class="headerlink" title="5、让你写一个dumpEsception，来处理未被处理的promise和throw的异常"></a>5、让你写一个dumpEsception，来处理未被处理的promise和throw的异常</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">dumpException</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <br>    <span class="hljs-built_in">window</span>.addEventListener(<span class="hljs-string">&#x27;unhandledrejection&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">event</span>)</span>&#123;<br>        <span class="hljs-built_in">console</span>.log(event.reason);<br>        event.preventDefault();<br>    &#125;)<br>    <span class="hljs-built_in">window</span>.addEventListener(<span class="hljs-string">&#x27;uncatchException&#x27;</span>,<span class="hljs-function">(<span class="hljs-params">error</span>)=&gt;</span>&#123;<br>        <span class="hljs-built_in">console</span>.log(error);<br>    &#125;)<br>    <br>&#125;<br>dumpException();<br><span class="hljs-built_in">Promise</span>.reject(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">&#x27;rejection&#x27;</span>));<br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">&#x27;error&#x27;</span>);<br></code></pre></td></tr></table></figure><p>我查了查应该是这个事件是可以的吧，但是devtool不给我面子，跑不通。剩下的我记不得了。</p><h5 id="6、读代码写结果，模仿babel将ES6的代码降级成ES5"><a href="#6、读代码写结果，模仿babel将ES6的代码降级成ES5" class="headerlink" title="6、读代码写结果，模仿babel将ES6的代码降级成ES5"></a>6、读代码写结果，模仿babel将ES6的代码降级成ES5</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++) &#123;<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-built_in">console</span>.log(i);<br>    &#125;, <span class="hljs-number">100</span>)<br>&#125;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++) &#123;<br>    <span class="hljs-built_in">console</span>.log(i)<br>&#125;<br><br><span class="hljs-comment">//结果：0 1 2 0 1 2</span><br><span class="hljs-comment">//降级代码：</span><br><span class="hljs-keyword">var</span> _loop = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">_loop</span>(<span class="hljs-params">i</span>) </span>&#123;<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>        <span class="hljs-built_in">console</span>.log(i);<br>    &#125;, <span class="hljs-number">100</span>);<br>&#125;;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++) &#123;<br>    _loop(i);<br>&#125;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> _i = <span class="hljs-number">0</span>; _i &lt; <span class="hljs-number">3</span>; _i++) &#123;<br>    <span class="hljs-built_in">console</span>.log(_i);<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="7、url编码的处理"><a href="#7、url编码的处理" class="headerlink" title="7、url编码的处理"></a>7、url编码的处理</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">encodeUrl</span>(<span class="hljs-params">url</span>) </span>&#123;<br>    <span class="hljs-keyword">let</span> used = url.split(<span class="hljs-string">&#x27;#&#x27;</span>);<br>    <span class="hljs-comment">//console.log(used)</span><br>    <span class="hljs-keyword">let</span> value = used[<span class="hljs-number">0</span>].split(<span class="hljs-string">&#x27;?&#x27;</span>);<br>    <span class="hljs-keyword">let</span> vars = value[<span class="hljs-number">1</span>].split(<span class="hljs-string">&quot;&amp;&quot;</span>);<br>    <span class="hljs-keyword">let</span> res = &#123;&#125;;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; vars.length; i++) &#123;<br>        <span class="hljs-keyword">let</span>  pair = vars[i].split(<span class="hljs-string">&#x27;=&#x27;</span>);<br>        res = <span class="hljs-built_in">Object</span>.assign(res,creatObj(pair[<span class="hljs-number">0</span>],<span class="hljs-built_in">decodeURIComponent</span>(pair[<span class="hljs-number">1</span>])))<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">creatObj</span>(<span class="hljs-params">key,value</span>)</span>&#123;<br>    <span class="hljs-keyword">let</span> obj = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Object</span>();<br>    obj[key] = value;<br>    <span class="hljs-keyword">return</span> obj;<br>&#125;<br><br><br><br><span class="hljs-built_in">console</span>.log(encodeUrl(<span class="hljs-string">&#x27;https://www.baidu.com/s?ie=utf-8&amp;f=8&amp;rsv_bp=1&amp;tn=baidu&amp;wd=js%E5%AF%B9%E8%B1%A1%E6%96%B9%E6%B3%95&amp;oq=js%25E7%25BB%2599obj%25E6%25B7%25BB%25E5%258A%25A0%25E5%25AF%25B9%25E8%25B1%25A1&amp;rsv_pq=b6616c0000003a39&amp;rsv_t=da168FLxcPPmRvkVnkbjbEIEOOWISKbi39vRSrnPFfYg8vEgbz4rj4BnZCI&amp;rqlang=cn&amp;rsv_enter=1&amp;rsv_dl=tb&amp;rsv_btype=t&amp;inputT=5931&amp;rsv_sug3=36&amp;rsv_sug1=22&amp;rsv_sug7=100&amp;rsv_sug2=0&amp;rsv_sug4=6205&#x27;</span>));<br></code></pre></td></tr></table></figure><h5 id="8、为什么要划分宏任务和微任务"><a href="#8、为什么要划分宏任务和微任务" class="headerlink" title="8、为什么要划分宏任务和微任务"></a>8、为什么要划分宏任务和微任务</h5><p>回到问题本身，其实就是如何处理回调的问题。总结起来有三种方式:</p><ol><li>使用同步回调，直到异步任务进行完，再进行后面的任务。</li><li>使用异步回调，将回调函数放在进行<code>宏任务队列</code>的队尾。</li><li>使用异步回调，将回调函数放到<code>当前宏任务中</code>的最后面。</li></ol><p>因为同步的问题非常明显，会让整个脚本阻塞住，当前任务等待，后面的任务都无法得到执行，而这部分等待的时间是可以拿来完成其他事情的，导致CPU的利用率非常低，而且还有另一个致命的问题，就是无法实现延迟绑定的效果。</p><p>如果执行的回调的世纪应该是在前面所有的宏任务之前，倘若现在的任务队列非常长，那么回调迟迟得不到执行，造成应用卡顿。</p><p>为了解决上述方案的问题，另外也考虑到延迟绑定的需求，Promise采用第三种方式，即引入微任务，即把resolve（reject）回调的执行放在当前<code>宏任务的末尾</code>。</p><p>这样，利用微任务解决了两大痛点：</p><ol><li>采用异步回调替代同步回调解决了浪费CPU性能的问题</li><li>放到当前宏任务最后执行，解决了回调执行的实时性问题。</li></ol><h5 id="9、事件捕获和事件冒泡"><a href="#9、事件捕获和事件冒泡" class="headerlink" title="9、事件捕获和事件冒泡"></a>9、事件捕获和事件冒泡</h5><ul><li><p>事件冒泡：IE的事件流叫做事件冒泡，即事件开始时由具体的元素（文档中嵌套层次最深的那个节点）接收，然后逐级向上传播到较为不具体的节点。（element(div)-&gt;element(body)-&gt;element(html)-&gt;document</p></li><li><p>事件捕获：Netscape Communicatior团队提出另一种事件流叫做事件捕获。事件捕获的思想是不太具体的节点应该更早的接收到事件，那么如果单机click，那么先触发的顺序会是（document-&gt;html-&gt;body-element）</p></li></ul><p>DOM事件流：DOM2级事件流包含三个阶段:事件捕获阶段、处于目标阶段和事件冒泡阶段。首先发生的是事件捕获（document-&gt;element）,为截获事件提供机会。然后是实际的目标接收到事件。最后一个阶段是冒泡阶段，可以在这个阶段对事件做出响应。</p><p>在DOM事件流中，实际的目标（<code>&lt;div&gt;</code>元素）在<code>捕获阶段</code>不会接收到事件。这意味着在捕获阶段，事件从document到<code>&lt;html&gt;</code>再到<code>&lt;body&gt;</code>后就停止了。下一阶段是<code>处于目标</code>阶段，于是事件在<code>&lt;div&gt;</code>上发生，并在事件处理（后面将会讨论这个概念）中被看成冒泡阶段的一部分。</p><p>多数支持DOM事件流的浏览器都实现了一种特定的行为；即使“DOM2级事件”规范种明确要求捕获阶段不会涉及事件目标，但IE9、Safari、Chrome、Firefox、Opera9.5及更高版本都会在捕获阶段触发事件对象上的事件。结果，就是有两个机会在目标对象上面操作事件。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">element.addEventLister(<span class="hljs-string">&quot;click&quot;</span>,func()=&#123;&#125;,fasle) <span class="hljs-comment">//false表示在冒泡阶段来执行。</span><br></code></pre></td></tr></table></figure><h5 id="10、回流和重绘"><a href="#10、回流和重绘" class="headerlink" title="10、回流和重绘"></a>10、回流和重绘</h5><p>队列化修改并批量执行来优化重排过程。浏览器会将修改操作放入到队列里，直到过了一段时间或者操作达到了一个阈值，才清空队列。但是！<strong>当你获取布局信息的操作的时候，会强制队列刷新</strong>，比如当你访问以下属性或者使用以下方法：</p><ul><li>offsetTop、offsetLeft、offsetWidth、offsetHeight</li><li>scrollTop、scrollLeft、scrollWidth、scrollHeight</li><li>clientTop、clientLeft、clientWidth、clientHeight</li><li>getComputedStyle()</li><li>getBoundingClientRect</li><li>具体可以访问这个网站：<a href="https://gist.github.com/paulirish/5d52fb081b3570c81e3a">gist.github.com/paulirish/5…</a></li></ul><p>以上属性和方法都需要返回最新的布局信息，因此浏览器不得不清空队列，触发回流重绘来返回正确的值。因此，我们在修改样式的时候，<strong>最好避免使用上面列出的属性，他们都会刷新渲染队列。</strong>如果要使用它们，最好将值缓存起来。</p><p>原文链接：<a href="https://juejin.cn/post/6844903734951018504">https://juejin.cn/post/6844903734951018504</a></p><h5 id="11、强缓存和协商缓存"><a href="#11、强缓存和协商缓存" class="headerlink" title="11、强缓存和协商缓存"></a>11、强缓存和协商缓存</h5><p>相关的header字段</p><ul><li><p>expires:一个未来时间，代表请求有效期，没有过期之前都使用当前请求。</p></li><li><p>Pragma:Pragma是旧产物，已经逐渐抛弃，有些网站为了向下兼容，还保留了这两个字段。如果报文中同时出现Pragma和Cache-Control时，以Pragma为准。同时出现Cache-Control和Expires时，以Cache-Control为准。（优先级：Pragma-&gt;Cache-Control-&gt;Expires）</p></li><li><p>cache-control：</p><ul><li>请求时候的Cache-Control时</li></ul><table><thead><tr><th>字段名称</th><th>说明</th></tr></thead><tbody><tr><td>no-cache</td><td>告知（代理）服务器不直接使用缓存，要求向原服务器发起请求</td></tr><tr><td>no-store</td><td>所有内容都不会被保存到缓存或者Internet临时文件中</td></tr><tr><td>max-age=delta-seconds</td><td>告知服务器客户端希望接收一个缓存时间（Age）不大于delta-seconds秒的资源，若没有则为任意超出的时间。</td></tr><tr><td>max-stale [=delta-seconds]</td><td>告知代理服务器客户端愿意接收一个超过缓存时间的资源，若有定义delta-seconds则为delta-seconds秒，若没有则为任意超出的时间。</td></tr><tr><td>no-transform</td><td>告知（代理服务器客户端希望获取实体数据没有被转换（比如压缩）过的资源）</td></tr><tr><td>only-if-cached</td><td>告知（代理）服务器客户端希望获取缓存的内容（若有），而不用向原服务器去发请求</td></tr><tr><td>min-fresh=delta-seconds</td><td>告知（代理）服务器客户端希望接收一个在小于delta-seconds内被更新过的资源</td></tr><tr><td>cache-extension</td><td>自定义扩展值，若服务器不识别该值将被忽略掉</td></tr></tbody></table><ul><li>响应时候的Cache-Control时</li></ul><table><thead><tr><th>字段名称</th><th>说明</th></tr></thead><tbody><tr><td>public</td><td>表明任何情况下都得缓存该资源（即使是需要HTTP认证的资源）</td></tr><tr><td>private [=”field-name”]</td><td>表明返回报文中全部或部分（若指定了field-name则为field-name的字段数据）仅开放给某些用户（服务器指定的share-user，如代理服务器）做缓存使用，其他用户则不能缓存这些数据</td></tr><tr><td>no-cache</td><td>不直接使用缓存，要求向服务器发起（新鲜度校验）请求</td></tr><tr><td>no-store</td><td>所有内容都不会被保存到缓存或Internet临时文件中</td></tr><tr><td>no-transform</td><td>告知客户端缓存文件时不得对实体数据做任何改变</td></tr><tr><td>only-if-cached</td><td>告知（代理）服务器客户端希望获取缓存的内容（若有），则不用向原服务器发去请求</td></tr><tr><td>must-revalidate</td><td>当前资源一定是向原服务器发去验证请求的，若请求失败会返回504（而非代理服务器上的缓存）</td></tr><tr><td>proxy-revalidate</td><td>与must-revalidate类似，但仅能应用于共享缓存（如代理）</td></tr><tr><td>max-age=delta-seconds</td><td>告知客户端资源在delta-secondsm秒内是新鲜的，无需向服务器发送请求</td></tr><tr><td>s-maxage=delta-seconds</td><td>同max-age，但仅应用于共享缓存（如代理）</td></tr><tr><td>cache-extension</td><td>自定义扩展值，若服务器不识别该值将被忽略掉</td></tr></tbody></table><p>可以多个值组合，但是no-store的优先级最高，本地不保存，每次都需要服务器发送资源。</p><p>public和private的选择。如果你使用了CDN，你需要关注一下这个值。CDN厂家一般会要求cache-control的值为public,提升缓存命中率。如果你的缓存命中率很低，而访问量很大的话，可以看下是不是设置了private，no-cache这类的值。如果定义了max-age,可以不用再定义public，他们的意义是一样的。</p></li><li><p>Last-Modified</p><p>在缓存中，我们需要一个机制来验证缓存是否有效。比如服务器的资源更新了，客户端要及时更新缓存；又或者客户端的资源过了有效期，但服务器上的资源还是旧的，此时并不需要重新发送。缓存校验就是用来解决这些问题的，在http1.1中，我们主要关注下Last-Modified和etag这两个字段。</p><p>服务端在返回资源时，会将该资源的最后更改时间通过<code>Last-Modified</code>字段返回给客户端。客户端下次请求时通过<code>If-Modified-Since</code>或者<code>If-Unmodified-Since</code>带上<code>Last-Modified</code>,服务端检测该时间是否与服务器的最后修改时间一致：如果一致，则返回<code>304状态码</code>，不返回资源；如果不一致则返回<code>200和修改后的资源</code>，并带上新的时间.</p></li><li><p>If-Modified-Since和If-Unmodified-Since的区别是：<br><strong>If-Modified-Since</strong>：告诉服务器如果时间一致，返回状态码304<br><strong>If-Unmodified-Since</strong>：告诉服务器如果时间不一致，返回状态码412</p></li><li><p>etag</p><p>单纯的以修改时间来判断还是有缺陷,比如文件的最后修改时间变了,但内容没变.对于这样的情况,我们可以使用etag来处理.</p><p>etag的方式是这样的:服务器通过某个算法对资源进行计算,取得一串值(类似于文件的md5值),之后将该值通过etag返回给客户端,客户端下次请求时通过<code>If-None-Match</code>或者<code>if-Match</code>带上该值,服务器对该值进行对比校验:如果一致则不要返回资源.</p></li><li><p>If-None-Match和If-Match的区别是：<br><strong>If-None-Match</strong>：告诉服务器如果一致，返回状态码304，不一致则返回资源<br><strong>If-Match</strong>：告诉服务器如果不一致，返回状态码412</p></li></ul><p>参考链接:<a href="https://blog.csdn.net/u012375924/article/details/82806617">https://blog.csdn.net/u012375924/article/details/82806617</a></p><h5 id="12、手写订阅发布者模式"><a href="#12、手写订阅发布者模式" class="headerlink" title="12、手写订阅发布者模式"></a>12、手写订阅发布者模式</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 手写发布订阅模式 EventEmitter</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EventEmitter</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params"></span>)</span> &#123;<br>      <span class="hljs-built_in">this</span>.events = &#123;&#125;;<br>    &#125;<br>    <span class="hljs-comment">// 实现订阅</span><br>    <span class="hljs-function"><span class="hljs-title">on</span>(<span class="hljs-params">type, callBack</span>)</span> &#123;<br>      <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">this</span>.events) <span class="hljs-built_in">this</span>.events = <span class="hljs-built_in">Object</span>.create(<span class="hljs-literal">null</span>);<br><br>      <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">this</span>.events[type]) &#123;<br>        <span class="hljs-built_in">this</span>.events[type] = [callBack];<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-built_in">this</span>.events[type].push(callBack);<br>      &#125;<br>    &#125;<br>    <span class="hljs-comment">// 删除订阅</span><br>    <span class="hljs-function"><span class="hljs-title">off</span>(<span class="hljs-params">type, callBack</span>)</span> &#123;<br>      <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">this</span>.events[type]) <span class="hljs-keyword">return</span>;<br>      <span class="hljs-built_in">this</span>.events[type] = <span class="hljs-built_in">this</span>.events[type].filter(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> &#123;<br>        <span class="hljs-keyword">return</span> item !== callBack;<br>      &#125;);<br>    &#125;<br>    <span class="hljs-comment">// 只执行一次订阅事件</span><br>    <span class="hljs-function"><span class="hljs-title">once</span>(<span class="hljs-params">type, callBack</span>)</span> &#123;<br>      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn</span>(<span class="hljs-params"></span>) </span>&#123;<br>        callBack();<br>        <span class="hljs-built_in">this</span>.off(type, fn);<br>      &#125;<br>      <span class="hljs-built_in">this</span>.on(type, fn);<br>    &#125;<br>    <span class="hljs-comment">// 触发事件</span><br>    <span class="hljs-function"><span class="hljs-title">emit</span>(<span class="hljs-params">type, ...rest</span>)</span> &#123;<br>      <span class="hljs-built_in">this</span>.events[type] &amp;&amp;<br>        <span class="hljs-built_in">this</span>.events[type].forEach(<span class="hljs-function"><span class="hljs-params">fn</span> =&gt;</span> fn.apply(<span class="hljs-built_in">this</span>, rest));<br>    &#125;<br>  &#125;<br><span class="hljs-comment">// 使用如下</span><br>  <span class="hljs-keyword">const</span> event = <span class="hljs-keyword">new</span> EventEmitter();<br><br>  <span class="hljs-keyword">const</span> handle = <span class="hljs-function">(<span class="hljs-params">...rest</span>) =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(rest);<br>  &#125;;<br><br>  event.on(<span class="hljs-string">&quot;click&quot;</span>, handle);<br><br>  event.emit(<span class="hljs-string">&quot;click&quot;</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>);<br><br>  event.off(<span class="hljs-string">&quot;click&quot;</span>, handle);<br><br>  event.emit(<span class="hljs-string">&quot;click&quot;</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>);<br><br>  event.once(<span class="hljs-string">&quot;dbClick&quot;</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-number">123456</span>);<br>  &#125;);<br>  event.emit(<span class="hljs-string">&quot;dbClick&quot;</span>);<br>  event.emit(<span class="hljs-string">&quot;dbClick&quot;</span>);<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>笔试总结</category>
      
    </categories>
    
    
    <tags>
      
      <tag>笔试总结</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>为字节准备</title>
    <link href="/2021/01/03/%E5%AD%97%E8%8A%82%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87day3/"/>
    <url>/2021/01/03/%E5%AD%97%E8%8A%82%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87day3/</url>
    
    <content type="html"><![CDATA[<a id="more"></a><h5 id="1、Flex布局，实现两个子元素垂直，并一个靠右一个靠左"><a href="#1、Flex布局，实现两个子元素垂直，并一个靠右一个靠左" class="headerlink" title="1、Flex布局，实现两个子元素垂直，并一个靠右一个靠左"></a>1、Flex布局，实现两个子元素垂直，并一个靠右一个靠左</h5><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;parent&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;left&quot;</span>&gt;</span>左子垂直分布<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;right&quot;</span>&gt;</span>右子垂直分布<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><br><span class="css"><span class="hljs-selector-class">.parent</span> &#123;</span><br>    display: flex;<br>    align-items: center;<br>    justify-content: space-between;<br><span class="css">    <span class="hljs-selector-tag">height</span><span class="hljs-selector-pseudo">:400px</span>;</span><br><span class="css">    <span class="hljs-selector-tag">border</span><span class="hljs-selector-pseudo">:1px</span> <span class="hljs-selector-tag">black</span> <span class="hljs-selector-tag">solid</span>;</span><br>&#125;<br><span class="css"><span class="hljs-selector-class">.left</span> &#123;</span><br><span class="css">    <span class="hljs-selector-tag">width</span><span class="hljs-selector-pseudo">:100px</span>;</span><br><span class="css">    <span class="hljs-selector-tag">height</span><span class="hljs-selector-pseudo">:150px</span>;</span><br><span class="css">    <span class="hljs-selector-tag">border</span><span class="hljs-selector-pseudo">:1px</span> <span class="hljs-selector-tag">red</span> <span class="hljs-selector-tag">solid</span>;</span><br>&#125;<br><span class="css"><span class="hljs-selector-class">.right</span> &#123;</span><br><span class="css">    <span class="hljs-selector-tag">width</span><span class="hljs-selector-pseudo">:100px</span>;</span><br><span class="css">    <span class="hljs-selector-tag">height</span><span class="hljs-selector-pseudo">:150px</span>;</span><br><span class="css">    <span class="hljs-selector-tag">border</span><span class="hljs-selector-pseudo">:1px</span> <span class="hljs-selector-tag">green</span> <span class="hljs-selector-tag">solid</span>;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>触类旁通，来练习一手经典居中，实现了其中的四种，剩下的等我有空继续补上，先睡觉惹！</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><span class="hljs-comment">&lt;!-- </span><br><span class="hljs-comment">     垂直居中的组合方式</span><br><span class="hljs-comment">    方法一:display:flex    这个也不错</span><br><span class="hljs-comment">    方法二:绝对定位和负边距   感觉这个方法不错</span><br><span class="hljs-comment">    方法三:绝对定位和为0    和上面的方法殊途同归</span><br><span class="hljs-comment">    方法四：transform</span><br><span class="hljs-comment">--&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Document<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;initial&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;center4&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;center2&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>        <span class="hljs-comment">&lt;!-- &lt;div class=&quot;left&quot;&gt;左子垂直分布&lt;/div&gt; --&gt;</span><br>        <span class="hljs-comment">&lt;!-- &lt;div class=&quot;right&quot;&gt;右子垂直分布&lt;/div&gt; --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;center1&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;center3&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>        <br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><br><span class="css">    <span class="hljs-selector-class">.parent</span> &#123;</span><br>        display: flex;<br>        align-items: center;<br>        justify-content: space-between;<br>        height: 400px;<br>        border: 1px black solid;<br>    &#125;<br><br><span class="css">    <span class="hljs-selector-class">.parentCenter1</span>&#123;</span><br>        display: flex;<br>        align-items: center;<br>        justify-content: center;<br>        height: 400px;<br>        border: 1px black solid;<br>    &#125;<br><br><span class="css">    <span class="hljs-selector-class">.initial</span> &#123;</span><br>        position: absolute;<br>        width: 400px;<br>        height: 400px;<br>        border: 1px black solid;<br>    &#125;<br><br><span class="css">    <span class="hljs-selector-class">.left</span> &#123;</span><br>        width: 100px;<br>        height: 150px;<br>        border: 1px red solid;<br>    &#125;<br><br><span class="css">    <span class="hljs-selector-class">.right</span> &#123;</span><br>        width: 100px;<br>        height: 150px;<br>        border: 1px green solid;<br>    &#125;<br><br><span class="css">    <span class="hljs-selector-class">.center1</span> &#123;</span><br>        position: relative;<br>        margin: -75px auto;<br><span class="css">        <span class="hljs-comment">/* margin: -75px auto 0 auto; */</span></span><br>        top: 50%;<br>        height: 150px;<br>        border: 1px green solid;<br>        width: 100px;<br>    &#125;<br><br><span class="css">    <span class="hljs-selector-class">.center2</span> &#123;</span><br>        opacity: 0.5;<br>        position: absolute;<br>        height: 200px;<br>        width: 200px;<br>        background-color: brown;<br>        top: 50%;<br>        left: 50%;<br>        margin: -100px 0 0 -100px;<br>    &#125;<br><br><span class="css">    <span class="hljs-selector-class">.center3</span> &#123;</span><br>        opacity: 0.3;<br>        position: absolute;<br>        width: 25%;<br>        height: 25%;<br><span class="css">        <span class="hljs-selector-tag">background</span>: <span class="hljs-selector-id">#000</span>;</span><br>        margin: auto;<br>        top: 0;<br>        left: 0;<br>        bottom: 0;<br>        right: 0;<br>    &#125;<br><span class="css">    <span class="hljs-selector-class">.center4</span>&#123;</span><br>        opacity: 0.9;<br>        position: absolute;<br><span class="css">        <span class="hljs-selector-tag">top</span><span class="hljs-selector-pseudo">:50</span>%;</span><br><span class="css">        <span class="hljs-selector-tag">left</span><span class="hljs-selector-pseudo">:50</span>%;</span><br><span class="css">        <span class="hljs-selector-tag">height</span><span class="hljs-selector-pseudo">:30</span>%;</span><br><span class="css">        <span class="hljs-selector-tag">width</span><span class="hljs-selector-pseudo">:30</span>%;</span><br><span class="css">        <span class="hljs-selector-tag">transform</span><span class="hljs-selector-pseudo">:translate(-50</span>%,<span class="hljs-selector-tag">-50</span>%);</span><br><span class="css">        <span class="hljs-selector-tag">background-color</span><span class="hljs-selector-pseudo">:blueviolet</span>;</span><br>    &#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p>参考链接：<a href="https://www.cnblogs.com/mokeycode/p/10635912.html">https://www.cnblogs.com/mokeycode/p/10635912.html</a></p><h5 id="2、链表的倒数第K个元素删除"><a href="#2、链表的倒数第K个元素删除" class="headerlink" title="2、链表的倒数第K个元素删除"></a>2、链表的倒数第K个元素删除</h5><p>看到一个笔试题，返回链表的倒数第K个元素。那么随便搭建一个链表吧。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">element</span>)</span> &#123;<br>        <span class="hljs-built_in">this</span>.element = element;<br>        <span class="hljs-built_in">this</span>.next = <span class="hljs-literal">null</span>;<br>    &#125;<br>    element = <span class="hljs-literal">null</span>;<br>    next = <span class="hljs-literal">null</span>;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LinkedList</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">elements = []</span>)</span> &#123;<br>        <span class="hljs-built_in">this</span>.head = <span class="hljs-literal">null</span>;<br>        <span class="hljs-built_in">this</span>.size = elements.length;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> _ <span class="hljs-keyword">of</span> elements) &#123;<br>            <span class="hljs-built_in">this</span>.Insert(_);<br>        &#125;<br>    &#125;<br>    head = <span class="hljs-literal">null</span>;<br>    size = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 向链表添加元素</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number&#125;</span> </span>newElement 新插入的元素</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-title">Insert</span>(<span class="hljs-params">newElement</span>)</span> &#123;<br>        <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">this</span>.head) <span class="hljs-built_in">this</span>.head = <span class="hljs-keyword">new</span> Node(newElement);<br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">var</span> newNode = <span class="hljs-keyword">new</span> Node(newElement);<br>            <span class="hljs-keyword">var</span> currNode = <span class="hljs-built_in">this</span>.Findtail();<br>            currNode.next = newNode;<br>        &#125;<br>        <span class="hljs-built_in">this</span>.size++;<br>    &#125;;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * sssssss</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param <span class="hljs-type">&#123;Node&#125;</span> </span>curHead 现在的节点</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-title">Findtail</span>(<span class="hljs-params">curHead = <span class="hljs-built_in">this</span>.head</span>)</span> &#123;<br>        <span class="hljs-keyword">if</span> (!curHead) <span class="hljs-keyword">throw</span> <span class="hljs-string">&quot;Error: empty tail&quot;</span>;<br>        <span class="hljs-keyword">if</span> (curHead.next)<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.Findtail(curHead.next);<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> curHead;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-title">Display</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">this</span>.head) <span class="hljs-keyword">return</span>;<br>        <span class="hljs-keyword">let</span> curhead = <span class="hljs-built_in">this</span>.head;<br>        <span class="hljs-keyword">let</span> message = curhead.element;<br>        <span class="hljs-keyword">while</span> (curhead.next) &#123;<br>            message += <span class="hljs-string">&quot;-&gt;&quot;</span> + curhead.next.element<br>            curhead = curhead.next;<br>        &#125;<br>        <span class="hljs-built_in">console</span>.log(message)<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-title">IsEmpty</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.head)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-title">Size</span>(<span class="hljs-params"></span>)</span> &#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.size &#125;<br>    <span class="hljs-function"><span class="hljs-title">Delete</span>(<span class="hljs-params">index</span>)</span> &#123;<br>        <span class="hljs-keyword">let</span> pre = <span class="hljs-built_in">this</span>.Find(index);<br>        <span class="hljs-keyword">let</span> cur = pre.next;<br>        pre.next = cur.next;<br>    &#125;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * </span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param <span class="hljs-type">&#123;Number&#125;</span> </span>index </span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-title">Find</span>(<span class="hljs-params">index</span>)</span> &#123;<br>        <span class="hljs-keyword">if</span> (index &gt; <span class="hljs-built_in">this</span>.size) <span class="hljs-keyword">throw</span> <span class="hljs-string">&quot;the index lager than the size&quot;</span><br>        <span class="hljs-keyword">let</span> curHead = <span class="hljs-built_in">this</span>.head;<br>        <span class="hljs-keyword">while</span> (index-- &amp;&amp; curHead.next) &#123;<br>            curHead = curHead.next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> curHead;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">deleteK</span>(<span class="hljs-params">List,k</span>)</span>&#123;<br>    <span class="hljs-keyword">let</span> cur = List.head;<br>    <span class="hljs-keyword">let</span> index = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">let</span> K_ele = List.Find(k); <br>    <span class="hljs-keyword">while</span>(K_ele.next)&#123;<br>        K_ele = K_ele.next;<br>        cur = cur.next;<br>        index++;<br>    &#125;<br>    List.Delete(index);<br>&#125;<br><br><span class="hljs-keyword">let</span> list = <span class="hljs-keyword">new</span> LinkedList([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>, <span class="hljs-number">10</span>, <span class="hljs-number">11</span>, <span class="hljs-number">12</span>, <span class="hljs-number">13</span>, <span class="hljs-number">14</span>]);<br>deleteK(list,<span class="hljs-number">2</span>);<br>list.Display();<br><br><br><br></code></pre></td></tr></table></figure><h5 id="3、宽度自适应的搜索框"><a href="#3、宽度自适应的搜索框" class="headerlink" title="3、宽度自适应的搜索框"></a>3、宽度自适应的搜索框</h5><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs html">css:<br>form &#123;<br>            display: flex;<br>            align-items: stretch;<br>        &#125;<br>        input &#123;<br>            flex-grow: 1;<br>        &#125;<br><br>html:<br>        <span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">action</span>=<span class="hljs-string">&quot;#&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">placeholder</span>=<span class="hljs-string">&quot;Enter your email&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br></code></pre></td></tr></table></figure><!--more--><h5 id="4、快速排序"><a href="#4、快速排序" class="headerlink" title="4、快速排序"></a>4、快速排序</h5><p>怎么说手写算法都得来，那咱们来练两道算法题，先练个快排，经典操作要娴熟</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">quickSort</span>(<span class="hljs-params">arr, i, j</span>) </span>&#123;<br>    <span class="hljs-keyword">if</span> (i &lt; j) &#123;<br>        <span class="hljs-keyword">let</span> left = i;<br>        <span class="hljs-keyword">let</span> right = j;<br>        <span class="hljs-keyword">let</span> pivot = arr[left];<br>        <span class="hljs-keyword">while</span> (i &lt; j) &#123;<br>            <span class="hljs-keyword">while</span> (arr[j] &gt;= pivot &amp;&amp; i &lt; j) &#123;      <span class="hljs-comment">//从后往前找比基数小的数</span><br>                j--;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(i &lt; j)&#123;<br>                arr[i++] = arr[j];<br>            &#125;<br>            <span class="hljs-keyword">while</span> (arr[i] &lt;= pivot &amp;&amp; i &lt; j) &#123;<br>                i++;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (i &lt; j) &#123;<br>                arr[j--] = arr[i];<br>            &#125;<br>        &#125;<br>        arr[i] = pivot;<br>        quickSort(arr, left, i - <span class="hljs-number">1</span>);<br>        quickSort(arr, i + <span class="hljs-number">1</span>, right);<br>        <span class="hljs-keyword">return</span> arr;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>居然写错了两次才改过来，看来手写真的很有必要，不要纸上谈兵了(此处骂自己)。</p><p>第一次采用c++的习惯思路写错， 改过来了。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">quickSort</span>(<span class="hljs-params">arr, i, j</span>) </span>&#123;<br>    <span class="hljs-keyword">if</span> (i &lt; j) &#123;<br>        <span class="hljs-keyword">let</span> left = i;<br>        <span class="hljs-keyword">let</span> right = j;<br>        <span class="hljs-keyword">let</span> pivot = arr[left];<br>        <span class="hljs-keyword">while</span> (i &lt; j) &#123;<br>            <span class="hljs-keyword">while</span> (arr[j] &gt;= pivot &amp;&amp; i &lt; j) &#123;      <span class="hljs-comment">//从后往前找比基数小的数</span><br>                j--;<br>            &#125;<br>            <span class="hljs-keyword">while</span> (arr[i] &lt;= pivot &amp;&amp; i &lt; j) &#123;      <span class="hljs-comment">//从前往后找比基数大的数</span><br>                i++;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(i&lt;j)&#123;<br>            <span class="hljs-keyword">let</span> temp = arr[i];<br>            arr[i] = arr[j];<br>            arr[j] = temp;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">let</span> temp = arr[left];<br>        arr[left] = arr[i];<br>        arr[i] = temp;<br>        quickSort(arr, left, i - <span class="hljs-number">1</span>);<br>        quickSort(arr, i + <span class="hljs-number">1</span>, right);<br>        <span class="hljs-keyword">return</span> arr;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">var</span> arr = [<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">36</span>,<span class="hljs-number">23</span>,<span class="hljs-number">6</span>,<span class="hljs-number">23</span>,<span class="hljs-number">64</span>,<span class="hljs-number">5</span>,<span class="hljs-number">7</span>,<span class="hljs-number">0</span>,<span class="hljs-number">2</span>,<span class="hljs-number">6</span>,<span class="hljs-number">24</span>]<br><span class="hljs-built_in">console</span>.log(quickSort(arr,<span class="hljs-number">0</span>,arr.length-<span class="hljs-number">1</span>))<br></code></pre></td></tr></table></figure><p>但是我搞明白后，更倾向于第一种方法，不许要借助额外空间，好像交换次数也少了一半。</p><h5 id="5、防抖和节流"><a href="#5、防抖和节流" class="headerlink" title="5、防抖和节流"></a>5、防抖和节流</h5><p>这也是前端面试过程中的高频问题。今天也切实的落实一遍，很基础，要会。在前端的查询请求的过程中，防抖的场景：就比如我们是在刷空间这样，他下面刷到底了，但是要加载下一页的时候，这时候用户因为网络啊一些问题，可能会下拉两次，那么在加载页面的时候，跳了很多页面就显得不合适，就需要使用防抖功能，在一段时间内，只执行一次操作。再次操作就重置时间计时。</p><p>节流操作的应用场景：就是类似百度的实时查询，当你在查询框里输入一个字，马上就会有一些东西弹出来了。但是用户有时候在打第一个字和第二个字之间，也打进去很多字符，但是对于这个查询的操作是没有意义的。这时候就没必要每次输入都请求服务器。这样会对给服务器较大的压力。因此这时候，就需要节流，来保证在一定时间内事件发生，只会响应一次。同时在实现的时候，移动端尽量去使用事件戳来做，设立定时器，对于性能的影响很大。</p><p>下面是手写的代码：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>防抖和节流<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><br><span class="css">        <span class="hljs-selector-class">.content</span>&#123;</span><br><span class="css">            <span class="hljs-selector-tag">height</span><span class="hljs-selector-pseudo">:200px</span>;</span><br><span class="css">            <span class="hljs-selector-tag">width</span><span class="hljs-selector-pseudo">:200px</span>;</span><br><span class="css">            <span class="hljs-selector-tag">border</span><span class="hljs-selector-pseudo">:1px</span> <span class="hljs-selector-tag">blue</span> <span class="hljs-selector-tag">solid</span>;</span><br>        &#125;<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;content&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;content&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span> <br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br><span class="javascript">    <span class="hljs-keyword">let</span> num = <span class="hljs-number">1</span>;</span><br><span class="javascript">    <span class="hljs-keyword">let</span> content = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&quot;content&quot;</span>);</span><br><span class="javascript">    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">count</span>(<span class="hljs-params"></span>)</span>&#123;</span><br>        content.innerHTML = num++;<br>    &#125;<br><span class="javascript">    <span class="hljs-comment">// content.onmousemove = debounce2(count,1000);         //这是用防毒的方式</span></span><br>        content.onmousemove = throttle(count,1000);<br><br><span class="javascript">    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">debounce</span>(<span class="hljs-params">func,wait</span>)</span>&#123;           <span class="hljs-comment">//这是指定时候后执行</span></span><br><span class="javascript">        <span class="hljs-keyword">let</span> timeout; <span class="hljs-comment">//定时器</span></span><br><span class="javascript">        <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;</span><br><span class="javascript">            <span class="hljs-keyword">if</span>(timeout) <span class="hljs-built_in">clearTimeout</span>(timeout);</span><br><span class="javascript">            timeout = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;</span><br><span class="javascript">                func.apply(<span class="hljs-built_in">this</span>); <span class="hljs-comment">//执行查询操作</span></span><br>            &#125;,wait)<br>        &#125;<br>    &#125;<br><span class="javascript">    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">debounce2</span>(<span class="hljs-params">func,wait</span>)</span>&#123;          <span class="hljs-comment">//这里是先执行，然后等时间</span></span><br><span class="javascript">        <span class="hljs-keyword">let</span> timeout;</span><br><span class="javascript">        <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;</span><br><span class="javascript">            <span class="hljs-keyword">if</span>(timeout) <span class="hljs-built_in">clearTimeout</span>(timeout);</span><br><span class="javascript">            <span class="hljs-keyword">let</span> callNow = !timeout;</span><br><span class="javascript">            timeout = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">()=&gt;</span>&#123;</span><br><span class="javascript">                timeout = <span class="hljs-literal">null</span>;</span><br>            &#125;,wait);<br><span class="javascript">            <span class="hljs-keyword">if</span>(callNow) func.apply(<span class="hljs-built_in">this</span>);</span><br>        &#125;<br>    &#125;<br><span class="javascript">    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">throttle</span>(<span class="hljs-params">func,wait</span>)</span>&#123;</span><br><span class="javascript">        <span class="hljs-keyword">let</span> timeout; <span class="hljs-comment">//定义计时器</span></span><br><span class="javascript">        <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;</span><br><span class="javascript">            <span class="hljs-keyword">if</span>(!timeout)&#123;</span><br><span class="javascript">                timeout = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">()=&gt;</span>&#123;</span><br><span class="javascript">                    timeout = <span class="hljs-literal">null</span>;</span><br><span class="javascript">                    func.apply(<span class="hljs-built_in">this</span>);</span><br>                &#125;,wait)<br>            &#125;<br>        &#125;<br>    &#125;<br><span class="javascript">    <span class="hljs-comment">//不能使用timeout的情况下，使用时间戳，性能更好</span></span><br><span class="javascript">    <span class="hljs-comment">//使用时间戳</span></span><br><span class="javascript">    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">throttle2</span>(<span class="hljs-params">func,wait</span>)</span>&#123;</span><br><span class="javascript">        <span class="hljs-keyword">let</span> prev = <span class="hljs-number">0</span>;</span><br><span class="javascript">        <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;</span><br><span class="javascript">            <span class="hljs-keyword">let</span> now = <span class="hljs-built_in">Date</span>.now();</span><br><span class="javascript">            <span class="hljs-keyword">if</span>(now - prev &gt; wait)&#123;</span><br><span class="javascript">                func.apply(<span class="hljs-built_in">this</span>)</span><br>                prev = now;<br>            &#125;<br>        &#125;<br>    &#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">Script</span>&gt;</span><br></code></pre></td></tr></table></figure><h5 id="6、并发控制"><a href="#6、并发控制" class="headerlink" title="6、并发控制"></a>6、并发控制</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@params </span>list &#123;Array&#125; - 要迭代的数组</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@params </span>limit &#123;Number&#125; - 并发数量控制数</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@params </span>asyncHandle &#123;Function&#125; - 对`list`的每一个项的处理函数，参数为当前处理项，必须 return 一个Promise来确定是否继续进行迭代</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;Promise&#125;</span> </span>- 返回一个 Promise 值来确认所有数据是否迭代完成</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">let</span> mapLimit = <span class="hljs-function">(<span class="hljs-params">list, limit, asyncHandle</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">let</span> recursion = <span class="hljs-function">(<span class="hljs-params">arr</span>) =&gt;</span> &#123;<br>        <span class="hljs-keyword">return</span> asyncHandle(arr.shift())<br>            .then(<span class="hljs-function">()=&gt;</span>&#123;<br>                <span class="hljs-keyword">if</span> (arr.length!==<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> recursion(arr)   <span class="hljs-comment">// 数组还未迭代完，递归继续进行迭代</span><br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;finish&#x27;</span>;<br>            &#125;)<br>    &#125;;<br>    <br>    <span class="hljs-keyword">let</span> listCopy = [].concat(list);<br>    <span class="hljs-keyword">let</span> asyncList = []; <span class="hljs-comment">// 正在进行的所有并发异步操作</span><br>    <span class="hljs-keyword">while</span>(limit--) &#123;<br>        asyncList.push( recursion(listCopy) ); <br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Promise</span>.all(asyncList);  <span class="hljs-comment">// 所有并发异步操作都完成后，本次并发控制迭代完成</span><br>&#125;<br><br><span class="hljs-keyword">var</span> dataLists = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3888</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>,<span class="hljs-number">11</span>,<span class="hljs-number">100</span>,<span class="hljs-number">123</span>];<br><span class="hljs-keyword">var</span> count = <span class="hljs-number">0</span>;<br>mapLimit(dataLists, <span class="hljs-number">3</span>, <span class="hljs-function">(<span class="hljs-params">curItem</span>)=&gt;</span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-params">resolve</span> =&gt;</span> &#123;<br>        count++<br>        <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">()=&gt;</span>&#123;<br>            <span class="hljs-built_in">console</span>.log(curItem, <span class="hljs-string">&#x27;当前并发量:&#x27;</span>, count--)<br>            resolve();<br>        &#125;, <span class="hljs-built_in">Math</span>.random() * <span class="hljs-number">5000</span>)  <br>    &#125;);<br>&#125;).then(<span class="hljs-function"><span class="hljs-params">response</span> =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;finish&#x27;</span>, response)<br>&#125;)<br></code></pre></td></tr></table></figure><h5 id="7、一个长页面如何懒加载，加视窗位置的确定"><a href="#7、一个长页面如何懒加载，加视窗位置的确定" class="headerlink" title="7、一个长页面如何懒加载，加视窗位置的确定"></a>7、一个长页面如何懒加载，加视窗位置的确定</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;!DOCTYPE html&gt;<br>&lt;html&gt;<br>&lt;head&gt;<br>    &lt;meta charset=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;<br>    &lt;title&gt;Document&lt;/title&gt;<br>    &lt;style&gt;<br>        img &#123;<br>            display: block;<br>            margin-bottom: 50px;<br>            width: 400px;<br>            height: 400px;<br>        &#125;<br>    &lt;/style&gt;<br>&lt;/head&gt;<br>&lt;body&gt;<br>    &lt;img src=<span class="hljs-string">&quot;&quot;</span> data-src=<span class="hljs-string">&quot;http://ww4.sinaimg.cn/large/006y8mN6gw1fa5obmqrmvj305k05k3yh.jpg&quot;</span> alt=<span class="hljs-string">&quot;&quot;</span>&gt;<br>&lt;/body&gt;<br> <br>&lt;script&gt;<br>    <span class="hljs-keyword">var</span> num = <span class="hljs-built_in">document</span>.getElementsByTagName(<span class="hljs-string">&#x27;img&#x27;</span>).length;<br>    <span class="hljs-keyword">var</span> img = <span class="hljs-built_in">document</span>.getElementsByTagName(<span class="hljs-string">&quot;img&quot;</span>);<br>    <span class="hljs-keyword">var</span> n = <span class="hljs-number">0</span>; <span class="hljs-comment">//存储图片加载到的位置，避免每次都从第一张图片开始遍历</span><br>    lazyload(); <span class="hljs-comment">//页面载入完毕加载可是区域内的图片</span><br>    <span class="hljs-comment">//window.onscroll = lazyload;</span><br>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">lazyload</span>(<span class="hljs-params"></span>) </span>&#123; <span class="hljs-comment">//监听页面滚动事件</span><br>        <span class="hljs-keyword">var</span> seeHeight = <span class="hljs-built_in">document</span>.documentElement.clientHeight; <span class="hljs-comment">//可见区域高度</span><br>        <span class="hljs-keyword">var</span> scrollTop = <span class="hljs-built_in">document</span>.documentElement.scrollTop || <span class="hljs-built_in">document</span>.body.scrollTop; <span class="hljs-comment">//滚动条距离顶部高度</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = n; i &lt; num; i++) &#123;<br>            <span class="hljs-keyword">if</span> (img[i].offsetTop &lt; seeHeight + scrollTop) &#123;<br>                <span class="hljs-keyword">if</span> (img[i].getAttribute(<span class="hljs-string">&quot;src&quot;</span>) == <span class="hljs-string">&quot;&quot;</span>) &#123;<br>                    img[i].src = img[i].getAttribute(<span class="hljs-string">&quot;data-src&quot;</span>);<br>                &#125;<br>                n = i + <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br><br><br><br><span class="hljs-comment">// 简单的节流函数</span><br><span class="hljs-comment">//fun 要执行的函数</span><br><span class="hljs-comment">//delay 延迟</span><br><span class="hljs-comment">//time  在time时间内必须执行一次</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">throttle</span>(<span class="hljs-params">fun, delay, time</span>) </span>&#123;<br>    <span class="hljs-keyword">var</span> timeout,<br>        startTime = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>        <span class="hljs-keyword">var</span> context = <span class="hljs-built_in">this</span>,<br>            args = <span class="hljs-built_in">arguments</span>,<br>            curTime = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>();<br>        <span class="hljs-built_in">clearTimeout</span>(timeout);<br>        <span class="hljs-comment">// 如果达到了规定的触发时间间隔，触发 handler</span><br>        <span class="hljs-keyword">if</span> (curTime - startTime &gt;= time) &#123;<br>            fun.apply(context, args);<br>            startTime = curTime;<br>            <span class="hljs-comment">// 没达到触发间隔，重新设定定时器</span><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            timeout = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br>            fun.apply(context, args);<br>            &#125;, delay);<br>        &#125;<br>    &#125;;<br>&#125;;<br><span class="hljs-comment">// 实际想绑定在 scroll 事件上的 handler</span><br><span class="hljs-comment">//function lazyload(event) &#123;&#125;</span><br><span class="hljs-comment">// 采用了节流函数</span><br><span class="hljs-built_in">window</span>.addEventListener(<span class="hljs-string">&#x27;scroll&#x27;</span>,throttle(lazyload,<span class="hljs-number">500</span>,<span class="hljs-number">1000</span>));<br> <br>&lt;/script&gt;<br>&lt;/html&gt;<br></code></pre></td></tr></table></figure><h5 id="8、设计通用组件要考虑哪些问题"><a href="#8、设计通用组件要考虑哪些问题" class="headerlink" title="8、设计通用组件要考虑哪些问题"></a>8、设计通用组件要考虑哪些问题</h5><ul><li><p><strong>细粒度考量</strong></p><p>我们在学习设计模式的时候会遇到很多种设计原则,其中一个设计原则就是<strong>单一职责原则</strong>,在组件库的开发中同样适用,我们原则上一个组件只专注一件事情,单一职责的组件的好处很明显,由于职责单一就可以最大可能性地复用组件,但是这也带来一个问题,过度单一职责的组件也可能会导致过度抽象,造成组件库的碎片化。</p><p>举个例子，一个自动完成组件(AutoComplete),他其实是由 Input 组件和 Select 组件组合而成的,因此我们完全可以复用之前的相关组件,就比如 Antd 的AutoComplete组件中就复用了Select组件,同时Calendar、 Form 等等一系列组件都复用了 Select 组件,那么Select 的细粒度就是合适的,因为 Select 保持的这种细粒度很容易被复用.</p></li><li><p><strong>组件通用性考量</strong><br> 组件设计之初是为了当时的页面设计进行封装设计的，那么之后的页面设计极大可能是与之前不同的，那么之前设计的组件就不能用了。</p><p>而一旦发生这样的情况，就说明我们之前所设计的组件是不通用的，需要重新设计了。就像Antd组件库那样，预留了dropdownRender进行组件渲染。</p><p>通用性的设计就代表着将放弃对DOM的操作权，暴露给开发者进行操作，组件开发者本身只负责底层逻辑和基本的DOM结构。这也是开发通用型组件的秘诀之一。</p></li></ul><h5 id="9、手写一个new方法"><a href="#9、手写一个new方法" class="headerlink" title="9、手写一个new方法"></a>9、手写一个new方法</h5><p>你都应该大概知道了new过程中会<strong>新建对象</strong>，此对象会继承<strong>构造器的原型与原型上的属性</strong>，最后它会被<strong>作为实例返回</strong>这样一个过程。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 构造器函数</span><br><span class="hljs-keyword">let</span> Parent = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">name, age</span>) </span>&#123;<br>    <span class="hljs-built_in">this</span>.name = name;<br>    <span class="hljs-built_in">this</span>.age = age;<br>&#125;;<br>Parent.prototype.sayName = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.name);<br>&#125;;<br><span class="hljs-comment">//自己定义的new方法</span><br><span class="hljs-keyword">let</span> newMethod = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">Parent, ...rest</span>) </span>&#123;<br>    <span class="hljs-comment">// 1.以构造器的prototype属性为原型，创建新对象；</span><br>    <span class="hljs-keyword">let</span> child = <span class="hljs-built_in">Object</span>.create(Parent.prototype);<br>    <span class="hljs-comment">// 2.将this和调用参数传给构造器执行</span><br>    <span class="hljs-keyword">let</span> result = Parent.apply(child, rest);<br>    <span class="hljs-comment">// 3.如果构造器没有手动返回对象，则返回第一步的对象</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">typeof</span> result  === <span class="hljs-string">&#x27;object&#x27;</span> ? result : child;<br>&#125;;<br><span class="hljs-comment">//创建实例，将构造函数Parent与形参作为参数传入</span><br><span class="hljs-keyword">const</span> child = newMethod(Parent, <span class="hljs-string">&#x27;echo&#x27;</span>, <span class="hljs-number">26</span>);<br>child.sayName() <span class="hljs-comment">//&#x27;echo&#x27;;</span><br><br><span class="hljs-comment">//最后检验，与使用new的效果相同</span><br>child <span class="hljs-keyword">instanceof</span> Parent<span class="hljs-comment">//true</span><br>child.hasOwnProperty(<span class="hljs-string">&#x27;name&#x27;</span>)<span class="hljs-comment">//true</span><br>child.hasOwnProperty(<span class="hljs-string">&#x27;age&#x27;</span>)<span class="hljs-comment">//true</span><br>child.hasOwnProperty(<span class="hljs-string">&#x27;sayName&#x27;</span>)<span class="hljs-comment">//false</span><br></code></pre></td></tr></table></figure><h5 id="10、闭包实现累加、柯里化实现累加"><a href="#10、闭包实现累加、柯里化实现累加" class="headerlink" title="10、闭包实现累加、柯里化实现累加"></a>10、闭包实现累加、柯里化实现累加</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">//闭包</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">add</span>(<span class="hljs-params">x</span>) </span>&#123;<br>    <span class="hljs-keyword">var</span> sum = x;<br>    <span class="hljs-keyword">var</span> tmp = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">y</span>) </span>&#123;<br>        <span class="hljs-keyword">if</span> (!y)<br>            <span class="hljs-keyword">return</span> tmp;<br>        <span class="hljs-keyword">else</span> &#123;<br>            sum = sum + y;<br>            <span class="hljs-keyword">return</span> tmp;<br>        &#125;<br>    &#125;;<br>    tmp.toString = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>        <span class="hljs-keyword">return</span> sum;<br>    &#125;;<br>    <span class="hljs-keyword">return</span> tmp;<br>&#125;<br><span class="hljs-built_in">console</span>.log(add(<span class="hljs-number">1</span>)(<span class="hljs-number">2</span>)(<span class="hljs-number">3</span>)()); <span class="hljs-comment">//6</span><br><span class="hljs-built_in">console</span>.log(add(<span class="hljs-number">1</span>)(<span class="hljs-number">2</span>)(<span class="hljs-number">3</span>)(<span class="hljs-number">4</span>)); <span class="hljs-comment">//10</span><br><span class="hljs-built_in">console</span>.log(add(<span class="hljs-number">1</span>)(<span class="hljs-number">2</span>)(<span class="hljs-number">3</span>)(<span class="hljs-number">4</span>)(<span class="hljs-number">5</span>));<span class="hljs-comment">//15</span><br><span class="hljs-built_in">console</span>.log(add(<span class="hljs-number">1</span>)(<span class="hljs-number">2</span>)(<span class="hljs-number">3</span>)(<span class="hljs-number">4</span>)(<span class="hljs-number">5</span>)(<span class="hljs-number">6</span>));<span class="hljs-comment">//21</span><br><br><span class="hljs-comment">//柯里化</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">add</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">var</span> args = <span class="hljs-built_in">Array</span>.prototype.slice.call(<span class="hljs-built_in">arguments</span>);<br>    <span class="hljs-keyword">var</span> fn = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;　　　　　<span class="hljs-comment">// 把参数都放在一个相当于全局变量的 args 里面　</span><br>      args.push(...arguments)<br>      <span class="hljs-keyword">return</span> fn;<br>    &#125;<br>    fn.toString = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> args.reduce(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">a, b</span>) </span>&#123;<br>        <span class="hljs-keyword">return</span> a + b;<br>      &#125;)<br>    &#125;<br>    <span class="hljs-keyword">return</span> fn;<br>  &#125;<br> <span class="hljs-built_in">console</span>.log(add(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>)) <span class="hljs-comment">// 3</span><br> <span class="hljs-built_in">console</span>.log(add(<span class="hljs-number">1</span>)(<span class="hljs-number">2</span>)) <span class="hljs-comment">// 3</span><br> <span class="hljs-built_in">console</span>.log(add(<span class="hljs-number">1</span>)(<span class="hljs-number">2</span>)(<span class="hljs-number">3</span>)) <span class="hljs-comment">// 6</span><br> <span class="hljs-built_in">console</span>.log(add(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>)(<span class="hljs-number">4</span>)) <span class="hljs-comment">// 10</span><br></code></pre></td></tr></table></figure><h5 id="11、画圆、画三角、画半圆、画圆角、0-5px边框"><a href="#11、画圆、画三角、画半圆、画圆角、0-5px边框" class="headerlink" title="11、画圆、画三角、画半圆、画圆角、0.5px边框"></a>11、画圆、画三角、画半圆、画圆角、0.5px边框</h5><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs css">.div1 &#123; //三角形<br>            <span class="hljs-selector-tag">width</span>: 0;<br>            <span class="hljs-selector-tag">height</span>: 0;<br>            <span class="hljs-selector-tag">border-top</span><span class="hljs-selector-pseudo">:40px</span> <span class="hljs-selector-tag">solid</span> <span class="hljs-selector-tag">transparent</span>;<br>            <span class="hljs-selector-tag">border-left</span><span class="hljs-selector-pseudo">:40px</span> <span class="hljs-selector-tag">solid</span> <span class="hljs-selector-tag">transparent</span>;<br>            <span class="hljs-selector-tag">border-right</span><span class="hljs-selector-pseudo">:40px</span> <span class="hljs-selector-tag">solid</span> <span class="hljs-selector-tag">transparent</span>;<br>            <span class="hljs-selector-tag">border-bottom</span><span class="hljs-selector-pseudo">:40px</span> <span class="hljs-selector-tag">solid</span> <span class="hljs-selector-id">#ff0000</span>;<br>        &#125;<br>        .div2&#123; //圆形<br>            <span class="hljs-selector-tag">width</span><span class="hljs-selector-pseudo">:40px</span>;<br>            <span class="hljs-selector-tag">height</span><span class="hljs-selector-pseudo">:40px</span>;<br>            <span class="hljs-selector-tag">background-color</span>: <span class="hljs-selector-tag">red</span>;<br>            <span class="hljs-selector-tag">border-radius</span>: 50%;<br>        &#125;<br>        .div3&#123; //圆角<br>            <span class="hljs-selector-tag">width</span><span class="hljs-selector-pseudo">:40px</span>;<br>            <span class="hljs-selector-tag">height</span>: 40<span class="hljs-selector-tag">px</span>;<br>            <span class="hljs-selector-tag">background-color</span>: <span class="hljs-selector-tag">green</span>;<br>            <span class="hljs-selector-tag">border-radius</span>: 10<span class="hljs-selector-tag">px</span>;<br>        &#125;<br>        .div4&#123; //半圆<br>        <span class="hljs-selector-tag">width</span><span class="hljs-selector-pseudo">:40px</span>;<br>        <span class="hljs-selector-tag">height</span><span class="hljs-selector-pseudo">:20px</span>;<br>        <span class="hljs-selector-tag">background-color</span><span class="hljs-selector-pseudo">:red</span>;<br>        <span class="hljs-selector-tag">border-radius</span><span class="hljs-selector-pseudo">:20px</span> 20<span class="hljs-selector-tag">px</span> 0 0;//左上、右上、右下、左下<br>        &#125;<br> .border &#123; //0.5px单边框<br>        <span class="hljs-selector-tag">width</span>: 200<span class="hljs-selector-tag">px</span>;<br>        <span class="hljs-selector-tag">height</span>: 200<span class="hljs-selector-tag">px</span>;<br>        <span class="hljs-selector-tag">margin</span>: 0 <span class="hljs-selector-tag">auto</span>;<br>        <span class="hljs-selector-tag">border-bottom</span>: 1<span class="hljs-selector-tag">px</span> <span class="hljs-selector-tag">solid</span> <span class="hljs-selector-tag">transparent</span>;<br>        <span class="hljs-selector-tag">border-image</span>: <span class="hljs-selector-tag">linear-gradient</span>(<span class="hljs-selector-tag">to</span> <span class="hljs-selector-tag">bottom</span>,<span class="hljs-selector-tag">transparent</span> 50%, <span class="hljs-selector-tag">red</span> 50%) 0 0 100%/1<span class="hljs-selector-tag">px</span> 0;<br>&#125;<br>        <br>         .border &#123; //四边0.5px<br>        <span class="hljs-selector-tag">width</span>: 200<span class="hljs-selector-tag">px</span>;<br>        <span class="hljs-selector-tag">height</span>: 200<span class="hljs-selector-tag">px</span>;<br>        <span class="hljs-selector-tag">margin</span>: 0 <span class="hljs-selector-tag">auto</span>;<br>        <span class="hljs-selector-tag">position</span>: <span class="hljs-selector-tag">relative</span>;<br>    &#125;<br>    <span class="hljs-selector-class">.border</span><span class="hljs-selector-pseudo">::before</span> &#123;<br>        <span class="hljs-attribute">content</span>: <span class="hljs-string">&quot; &quot;</span>;<br>        <span class="hljs-attribute">position</span>: absolute;<br>        <span class="hljs-attribute">top</span>: <span class="hljs-number">0</span>;<br>        <span class="hljs-attribute">left</span>: <span class="hljs-number">0</span>;<br>        <span class="hljs-attribute">width</span>: <span class="hljs-number">200%</span>;<br>        <span class="hljs-attribute">height</span>: <span class="hljs-number">200%</span>;<br>        <span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> solid red;<br>        <span class="hljs-attribute">transform-origin</span>: <span class="hljs-number">0</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">scale</span>(<span class="hljs-number">0.5</span>);<br>    &#125;<br><br></code></pre></td></tr></table></figure><h5 id="12、文件树的数据结构"><a href="#12、文件树的数据结构" class="headerlink" title="12、文件树的数据结构"></a>12、文件树的数据结构</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FileTree</span></span>&#123;<br>rmEmpty: <span class="hljs-built_in">Boolean</span> = <span class="hljs-literal">false</span><br>    fileCount = <span class="hljs-number">0</span><br>    folderCount = <span class="hljs-number">0</span><br>    filesCount = <span class="hljs-number">0</span><br>    foldersCount = <span class="hljs-number">0</span><br>    allCount = <span class="hljs-number">0</span><br><br>    files = []<br>    folders = []<br><span class="hljs-comment">//循环遍历</span><br>Traverse (folder1 : any, dir = <span class="hljs-string">&#x27;&#x27;</span>)<br><br>&#125;<br></code></pre></td></tr></table></figure><h5 id="13、深拷贝"><a href="#13、深拷贝" class="headerlink" title="13、深拷贝"></a>13、深拷贝</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">deepCopy</span>(<span class="hljs-params">source</span>) </span>&#123;<br>    <span class="hljs-keyword">if</span> (!(<span class="hljs-keyword">typeof</span> obj === <span class="hljs-string">&#x27;object&#x27;</span> &amp;&amp; obj !== <span class="hljs-literal">null</span>))<br>        <span class="hljs-keyword">return</span> source;<br>    <span class="hljs-keyword">let</span> target = <span class="hljs-built_in">Array</span>.isArray(source)?[]:&#123;&#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> k <span class="hljs-keyword">in</span> source)&#123;<br>        <span class="hljs-keyword">if</span>(source.hasOwnProperty(k))&#123;<br>            <span class="hljs-keyword">if</span>(<span class="hljs-keyword">typeof</span> source[k] === <span class="hljs-string">&#x27;object&#x27;</span>)<br>            target[k] = deepCopy(source[k])<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            target[k] = source[k];<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> target;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="14、setTimeout实现setInterval"><a href="#14、setTimeout实现setInterval" class="headerlink" title="14、setTimeout实现setInterval"></a>14、setTimeout实现setInterval</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">setInterval</span>(<span class="hljs-params">func, t</span>)</span>&#123;<br>    <span class="hljs-keyword">var</span> inter = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br>        <span class="hljs-built_in">setTimeout</span>(inter,t);<br>        <span class="hljs-keyword">try</span>&#123;<br>            func.call(<span class="hljs-literal">null</span>);<br>        &#125;<br>        <span class="hljs-keyword">catch</span>(e)&#123;<br>            <span class="hljs-keyword">throw</span> e.toString();<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">setTimeout</span>(inter,t);<br>&#125;;<br></code></pre></td></tr></table></figure><h5 id="15、手撕bind、call、apply"><a href="#15、手撕bind、call、apply" class="headerlink" title="15、手撕bind、call、apply"></a>15、手撕bind、call、apply</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">myBind2</span>(<span class="hljs-params">context, ...args1</span>) </span>&#123;<span class="hljs-comment">// Cat</span><br>    <span class="hljs-keyword">var</span> self = <span class="hljs-built_in">this</span>;<br>    <span class="hljs-keyword">var</span> Fn = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">...args2</span>) </span>&#123;<br>        <span class="hljs-keyword">return</span> self.apply(<span class="hljs-built_in">this</span> <span class="hljs-keyword">instanceof</span> context ? <span class="hljs-built_in">this</span> : context, args1.concat(args2))<br>    &#125;<br>    <span class="hljs-keyword">var</span> Fmiddle = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123; &#125;;<br>    Fmiddle.prototype = <span class="hljs-built_in">this</span>.prototype;<br>    Fn.prototype = <span class="hljs-keyword">new</span> Fmiddle();<br>    <span class="hljs-keyword">return</span> Fn;<br>&#125;<br><br><span class="hljs-comment">// 全局添加一个_call方法</span><br><span class="hljs-built_in">Function</span>.prototype._call = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">obj</span>) </span>&#123;<br>    <span class="hljs-comment">// 参数是否存在，如果存在则转为Object类型，否则直接取window对象为默认对象</span><br>    <span class="hljs-keyword">var</span> _obj = obj ? <span class="hljs-built_in">Object</span>(obj) : <span class="hljs-built_in">window</span><br>    <span class="hljs-comment">// 把调用_call()方法的那个函数保存在目标对象中</span><br>    _obj.fn = <span class="hljs-built_in">this</span><br>    <span class="hljs-comment">// 保存参数的数组</span><br>    <span class="hljs-comment">// var argArr = [...arguments].slice(1)</span><br>    <span class="hljs-keyword">var</span> argArr = <span class="hljs-built_in">Array</span>.from(<span class="hljs-built_in">arguments</span>).slice(<span class="hljs-number">1</span>)<br>    <span class="hljs-comment">// 遍历参数,因为首项是obj，所以要从次项开始遍历才是参数</span><br>    <span class="hljs-comment">/* for (var i = 1; i &lt; arguments.length; i++) &#123;</span><br><span class="hljs-comment">        argArr.push(&#x27;arguments[&#x27;+ i + &#x27;]&#x27;)</span><br><span class="hljs-comment">      &#125; */</span><br>    <span class="hljs-comment">// 执行obj的fn方法，把arg拆分</span><br>    <span class="hljs-comment">// eval(&quot;_obj.fn(&quot; + argArr + &quot;)&quot;)</span><br>    _obj.fn(...argArr)<br>    <span class="hljs-comment">// 执行完之后删除这个方法</span><br>    <span class="hljs-keyword">delete</span> _obj.fn<br>&#125;<br><br><span class="hljs-built_in">Function</span>.prototype._apply = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">obj, argArr</span>) </span>&#123;<br>    <span class="hljs-comment">// 如果obj不存在则默认window对象</span><br>    <span class="hljs-keyword">var</span> _obj = obj ? obj : <span class="hljs-built_in">window</span><br>    <span class="hljs-comment">// 给_obj添加fn方法</span><br>    _obj.fn = <span class="hljs-built_in">this</span><br>    <span class="hljs-comment">// 获取第二个数组参数</span><br>    <span class="hljs-keyword">var</span> arg = []<br>    <span class="hljs-comment">// 当这个参数数组不存在或者为空时，直接执行函数，否则把数组拆分后传递给函数并执行</span><br>    <span class="hljs-keyword">if</span> (!argArr || argArr.length == <span class="hljs-number">0</span>) &#123;<br>        _obj.fn()<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; argArr.length; i++) &#123;<br>            arg.push(<span class="hljs-string">&#x27;argArr[&#x27;</span>+ i + <span class="hljs-string">&#x27;]&#x27;</span>)<br>        &#125;<br>        <span class="hljs-comment">// 执行obj的fn方法，把arg拆分</span><br>        <span class="hljs-built_in">eval</span>(<span class="hljs-string">&quot;_obj.fn(&quot;</span> + arg + <span class="hljs-string">&quot;)&quot;</span>)<br>    &#125;<br>    <span class="hljs-comment">// 移除这个方法</span><br>    <span class="hljs-keyword">delete</span> _obj.fn<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="16、Common-js和es6-module"><a href="#16、Common-js和es6-module" class="headerlink" title="16、Common.js和es6 module"></a>16、Common.js和es6 module</h5><p>产生<code>模块化</code>的原因：js很难编写大型项目，由于全局变量的污染和难以管理的依赖关系，这些问题导致了JS无法进行精细的模块划分，因为精细的模块化划分会导致更多的全局污染以及更加复杂的依赖关系；</p><ul><li><p>Common.js模板化</p><p>目前只有node环境才支持CommonJs模板化标准，要使用CommonJs,必须安装node</p><p>node遵循EcmaScript标准，但是由于脱离了浏览器环境，因此：无法使用浏览器的dom对象、window对象、document对象</p><ul><li><p>common.js的标准和使用</p><ul><li>一个js文件即是一个模板</li></ul></li></ul></li><li><p>如果一个模板需要暴露一些数据或者功能供其他模板使用，需要使用代码<code>module.expots = xxx</code></p><ul><li>如果一个模块需要使用另一个模块导出的内容，需要使用require(‘模块路径’)</li></ul></li><li><p>路径必须以./或者../开头</p><ul><li>如果模块文件后缀名为js,可以省略后缀名</li></ul></li><li><p>require函数返回的内容是模块导出的内容</p><ul><li>模块中所有全局代码产生的变量、函数均不会对全局造成任何污染，仅在模块内使用。</li></ul></li><li><p>模块具有缓存，第一次导入模块时会缓存模块的导出，之后再导入同一个模块，直接使用之前的缓存结果。</p></li><li><p>ES6模板化</p><ul><li>基本导出可以有多个，默认导出只能有一个</li><li>基本导出必须要有名字，默认导出由于有特殊名字，所以可以不用写名字。</li><li>ES6 module采用的依赖预加载模式，所有模块导入代码均会提升到代码顶部</li><li>不能将导入代码放置到判断，循环中</li><li>导入的内容放置到常量中，不可更改</li><li>ES6 module使用了缓存，保证每个模块仅加载一次</li></ul></li></ul><h5 id="17、实现一个实时搜索框"><a href="#17、实现一个实时搜索框" class="headerlink" title="17、实现一个实时搜索框"></a>17、实现一个实时搜索框</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;template&gt;<br>  &lt;div&gt;<br>    &lt;input<br>      type=<span class="hljs-string">&quot;text&quot;</span><br>      id=<span class="hljs-string">&quot;ss&quot;</span><br>      placeholder=<span class="hljs-string">&quot;搜索&quot;</span><br>      v-model=<span class="hljs-string">&quot;search&quot;</span><br>      v-on:input=<span class="hljs-string">&quot;request&quot;</span><br>    /&gt;<br>    &lt;button @click=<span class="hljs-string">&quot;btn&quot;</span>&gt;搜索&lt;/button&gt;<br>    &lt;br /&gt;<br>    &lt;input v-model=<span class="hljs-string">&quot;result&quot;</span> /&gt;<br>  &lt;/div&gt;<br>&lt;/template&gt;<br><br>&lt;script&gt;<br><span class="hljs-keyword">import</span> axios <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;axios&quot;</span>;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>  name: <span class="hljs-string">&quot;HelloWorld&quot;</span>,<br>  props: &#123;<br>    msg: <span class="hljs-built_in">String</span>,<br>  &#125;,<br>  <span class="hljs-function"><span class="hljs-title">data</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-keyword">return</span> &#123; <span class="hljs-attr">search</span>: <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-attr">result</span>: <span class="hljs-string">&quot;搜索结果:&quot;</span> &#125;;<br>  &#125;,<br>  methods: &#123;<br>    request: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">request</span>(<span class="hljs-params"></span>) </span>&#123;<br>      <span class="hljs-built_in">this</span>.$watch(<br>        <span class="hljs-string">&quot;search&quot;</span>,<br>        throttle(<span class="hljs-function">() =&gt;</span> &#123;<br>          <span class="hljs-keyword">var</span> CancelToken = axios.CancelToken;<br>          <span class="hljs-keyword">var</span> source = CancelToken.source();<br>          <span class="hljs-comment">//取消上一次请求</span><br>          <span class="hljs-keyword">if</span>(<span class="hljs-keyword">typeof</span> source === <span class="hljs-string">&#x27;function&#x27;</span>)<br>          source.cancel(<span class="hljs-string">&#x27;取消请求&#x27;</span>)<br>          axios<br>            .get(<span class="hljs-string">&quot;http://localhost:91&quot;</span>, &#123;<br>              <span class="hljs-comment">//searchContent: this.search,</span><br>              CancelToken: source.token<br>              &#125;)<br>            .then(<span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> <span class="hljs-built_in">this</span>.result = <span class="hljs-string">&quot;查询的结果:&quot;</span> + res.data)<br>            .catch(<span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> &#123;<br>              <span class="hljs-keyword">if</span> (axios.isCancel(err)) &#123;<br>                <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;request canceled&quot;</span>, err.message);<br>              &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-built_in">console</span>.log(err);<br>              &#125;<br>            &#125;);<br>        &#125;, <span class="hljs-number">3000</span>)<br>      )<br>    &#125;,<br>  &#125;,<br>&#125;;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">throttle</span>(<span class="hljs-params">func, delay</span>) </span>&#123;<br> <span class="hljs-keyword">let</span> timeout; <span class="hljs-comment">//定义计时器</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">...args</span>)</span>&#123;<br>            <span class="hljs-keyword">if</span>(!timeout)&#123;<br>                timeout = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">()=&gt;</span>&#123;<br>                    timeout = <span class="hljs-literal">null</span>;<br>                    func.apply(<span class="hljs-built_in">this</span>,args);<br>                &#125;,delay)<br>            &#125;<br>        &#125;<br>&#125;<br>&lt;/script&gt;<br><br>&lt;!-- Add <span class="hljs-string">&quot;scoped&quot;</span> attribute to limit CSS to <span class="hljs-built_in">this</span> component only --&gt;<br>&lt;style scoped&gt;<br>&lt;/style&gt;<br><br></code></pre></td></tr></table></figure><p>​      </p>]]></content>
    
    
    
    <tags>
      
      <tag>面试准备</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>动态规划</title>
    <link href="/2021/01/03/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E5%AD%A6%E4%B9%A0/"/>
    <url>/2021/01/03/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<p>动态规划这个问题，我在当初算法课的时候，是有了一点简单的了解，就针对包裹取物之类的问题的讨论，但是好像转换题目后发现对转移方程的问题，一直没用系统的总结，今天就抽出一天时间来处理动态规划的问题吧。</p><a id="more"></a><p>参考了网上的问题，有一句话我很赞同，动态规划的一般形式就是求最值。是运筹学中的一种优化方案，一般求最值，肯定是要穷举所有的情况的，但是动态规划有一点特别，特别的是在求解问题的时候，会有很多的<code>重叠子问题</code>，暴力破解就会是指数级的复杂度，因此我们需要引入DP表来优化问题。避免不必要的计算。</p><h5 id="1-斐波那契数列"><a href="#1-斐波那契数列" class="headerlink" title="1.斐波那契数列"></a>1.斐波那契数列</h5><p>为什么要从简单的问题入手，简单的问题，你才有精力集中在算法的通用思想上，而不会被隐晦的细节搞的莫名其妙。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">fib</span><span class="hljs-params">(<span class="hljs-keyword">int</span> N)</span></span>&#123;<br><span class="hljs-keyword">if</span>(N==<span class="hljs-number">1</span> || N==<span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br><span class="hljs-keyword">return</span> fib(N - <span class="hljs-number">1</span>) + fib(N - <span class="hljs-number">2</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>这是我们刚开始接触递归时候的经典写法，但是这个写法很低效，我们来思考一下，f(20)要求f(19)+f(18),f(19)=f(18)+f(17),那么光f(18)就计算了两次，那f(17)就会出现3次，再往下就会不断的重复计算。到f(3)岂不是要重复很多次。那么我们来优化一下<code>重叠子问题</code>的问题。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">fib</span><span class="hljs-params">(<span class="hljs-keyword">int</span> N)</span></span>&#123;<br><span class="hljs-keyword">if</span>(N &lt; <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(N+<span class="hljs-number">1</span>, <span class="hljs-number">0</span>)</span></span>;<br><span class="hljs-keyword">return</span> helper(dp, N);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">helper</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; dp, <span class="hljs-keyword">int</span> n)</span></span>&#123;<br><span class="hljs-keyword">if</span>(n == <span class="hljs-number">1</span> || n==<span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<span class="hljs-comment">//base case</span><br><span class="hljs-keyword">if</span>(dp[n] != <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> dp[n];<br>dp[n] = helper(dp,n<span class="hljs-number">-1</span>) + helper(dp,n<span class="hljs-number">-2</span>);<br><span class="hljs-keyword">return</span> dp[n];<br>&#125;<br></code></pre></td></tr></table></figure><p>实际上带着<code>备忘录</code>的递归解法的效率已经和动态规划差不多了。不过这种方式是<code>自顶向下</code>s的，动态规划是<code>自底向上</code>的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">fib</span><span class="hljs-params">(<span class="hljs-keyword">int</span> N)</span></span>&#123;<br><span class="hljs-keyword">if</span>(N &lt; <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><span class="hljs-keyword">if</span>(N == <span class="hljs-number">1</span> || N == <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br><span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">dp</span><span class="hljs-params">(N+<span class="hljs-number">1</span>,<span class="hljs-number">0</span>)</span></span>;<br>    <span class="hljs-comment">//base case</span><br>    dp[<span class="hljs-number">1</span>] = dp[<span class="hljs-number">2</span>] = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">3</span>;i &lt;= N; i++)<br>    &#123;<br>        dp[i] = dp[i<span class="hljs-number">-1</span>] +dp[i<span class="hljs-number">-2</span>]<br>&#125;<br>    <span class="hljs-keyword">return</span> dp[N];<br>&#125;<br></code></pre></td></tr></table></figure><p>甚至还能更优化，你会发现，有时候只需要两个前元素，就能完成计算，甚至能把空间复杂度给优化到o(1)。</p><h5 id="2、最长公共子串"><a href="#2、最长公共子串" class="headerlink" title="2、最长公共子串"></a>2、最长公共子串</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">LCS</span>(<span class="hljs-params">str1, str2</span>) </span>&#123;<br>    <span class="hljs-keyword">if</span> (str1 === <span class="hljs-string">&quot;&quot;</span> || str2 === <span class="hljs-string">&quot;&quot;</span>) &#123;<br>     <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>;<br>    &#125;<br>    <span class="hljs-keyword">var</span> len1 = str1.length;<br>    <span class="hljs-keyword">var</span> len2 = str2.length;<br>    <span class="hljs-keyword">var</span> a = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(len1);<br>    <span class="hljs-keyword">var</span> maxLen = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">var</span> maxPos = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; len1; i++) &#123; <br>     <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> j = len2 - <span class="hljs-number">1</span>; j &gt;= <span class="hljs-number">0</span>; j--) &#123;<br>      <span class="hljs-keyword">if</span> (str1.charAt(j) == str2.charAt(i)) &#123;<br>       <span class="hljs-keyword">if</span> (i === <span class="hljs-number">0</span> || j === <span class="hljs-number">0</span>) &#123;<br>        a[j] = <span class="hljs-number">1</span>;<br>       &#125; <span class="hljs-keyword">else</span> &#123;<br>        a[j] = a[j - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>;<br>       &#125;<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>       a[j] = <span class="hljs-number">0</span>;<br>      &#125;<br>      <span class="hljs-keyword">if</span> (a[j] &gt; maxLen) &#123;<br>       maxLen = a[j];<span class="hljs-comment">//最大匹配长度</span><br>       maxPos = j;<span class="hljs-comment">//最长匹配的点是末尾</span><br>      &#125;<br>     &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> str1.substr(maxPos - maxLen + <span class="hljs-number">1</span>, maxLen);<br>   &#125;<br></code></pre></td></tr></table></figure><p>该问题分解成最小子问题，是两个字符的比较，两重for循环，将db table绘制出来，如果相等，则该点的匹配长度为前一字符的匹配长度加1，如果该匹配点为开头第一个点，则匹配长度为1。</p><p>参考链接：<a href="https://www.jb51.net/article/134330.htm">https://www.jb51.net/article/134330.htm</a></p><h5 id="3、子数组的最大累加问题"><a href="#3、子数组的最大累加问题" class="headerlink" title="3、子数组的最大累加问题"></a>3、子数组的最大累加问题</h5><p>给定一个数组arr，返回子数组的最大累加和</p><p>例如，arr = [1, -2, 3, 5, -2, 6, -1]，所有子数组中，[3, 5, -2, 6]可以累加出最大的和12，所以返回12.</p><p>[要求]时间复杂度为O(n)，空间复杂度为O(1)</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">maxsum</span>(<span class="hljs-params">arr</span>) </span>&#123;<br>    <span class="hljs-keyword">if</span>(arr.length === <span class="hljs-number">0</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">let</span> cur = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">let</span> len = arr.length;<br>    <span class="hljs-keyword">let</span> max = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>;i &lt; len;i++)&#123;<br>        cur += arr[i];<br>        max = <span class="hljs-built_in">Math</span>.max(cur,max);<br>        cur = cur&gt;<span class="hljs-number">0</span>?cur:<span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> max;<br>&#125;<br><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">1</span>, -<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, -<span class="hljs-number">2</span>, <span class="hljs-number">6</span>, -<span class="hljs-number">1</span>]<br><span class="hljs-built_in">console</span>.log(maxsum(arr))<br></code></pre></td></tr></table></figure><p>这道题只遍历一遍，逐步累加，如果相加的过程中出现负值，则直接抛弃，因为如果是负值起步，不可能是最大值了，非负就一直加下去。</p><h5 id="4、机器人寻路"><a href="#4、机器人寻路" class="headerlink" title="4、机器人寻路"></a>4、机器人寻路</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number&#125;</span> <span class="hljs-variable">m</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number&#125;</span> <span class="hljs-variable">n</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number&#125;</span> <span class="hljs-variable">k</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> movingCount = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">m, n, k</span>) </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getsum</span>(<span class="hljs-params">x</span>)</span>&#123;  <span class="hljs-comment">//求和</span><br>        <span class="hljs-keyword">let</span> sum = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(x)&#123;<br>            sum += x%<span class="hljs-number">10</span>;<br>            x = <span class="hljs-built_in">Math</span>.floor(x/<span class="hljs-number">10</span>)<br>        &#125;<br>        <span class="hljs-keyword">return</span> sum;<br>    &#125;<br>    <span class="hljs-keyword">const</span> directionAry = [<br>       [<span class="hljs-number">1</span>,<span class="hljs-number">0</span>],<br>       [<span class="hljs-number">0</span>,<span class="hljs-number">1</span>]<br>    ]<br>    <span class="hljs-keyword">let</span> arrived = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>([<span class="hljs-string">&#x27;0,0&#x27;</span>])<br>    <span class="hljs-keyword">let</span> queue = [[<span class="hljs-number">0</span>,<span class="hljs-number">0</span>]];<br>    <span class="hljs-keyword">while</span>(queue.length)&#123;<br>        <span class="hljs-keyword">let</span> [x,y] = queue.shift();<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span> ;i &lt; <span class="hljs-number">2</span>;i++)&#123;<br>            <span class="hljs-keyword">let</span> offsetX = x + directionAry[i][<span class="hljs-number">0</span>];<br>            <span class="hljs-keyword">let</span> offsetY = y + directionAry[i][<span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">if</span>(offsetX &lt; <span class="hljs-number">0</span> || offsetX &gt;= m ||offsetY &lt; <span class="hljs-number">0</span> ||offsetY &gt;= n || getsum(offsetX)+getsum(offsetY)&gt;k||arrived.has(<span class="hljs-string">`<span class="hljs-subst">$&#123;offsetX&#125;</span>,<span class="hljs-subst">$&#123;offsetY&#125;</span>`</span>))<br>            &#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            arrived.add(<span class="hljs-string">`<span class="hljs-subst">$&#123;offsetX&#125;</span>,<span class="hljs-subst">$&#123;offsetY&#125;</span>`</span>);<br>            queue.push([offsetX,offsetY]);<br>        &#125;<br>    &#125; <br>    <span class="hljs-keyword">return</span> arrived.size;<br>&#125;<br><span class="hljs-built_in">console</span>.log(movingCount(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>))<br></code></pre></td></tr></table></figure><h5 id="5、矩阵中的路径"><a href="#5、矩阵中的路径" class="headerlink" title="5、矩阵中的路径"></a>5、矩阵中的路径</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;character[][]&#125;</span> <span class="hljs-variable">board</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;string&#125;</span> <span class="hljs-variable">word</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;boolean&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> exist = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">board, word</span>) </span>&#123;<br>    <span class="hljs-keyword">let</span> row = board.length;<br>    <span class="hljs-keyword">let</span> col = board[<span class="hljs-number">0</span>].length;<br>    <span class="hljs-keyword">let</span> res = <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">var</span> dfs = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">x, y, k, board, word</span>) </span>&#123;<br>        <span class="hljs-keyword">if</span> (x &gt;= row || x &lt; <span class="hljs-number">0</span> || y &gt;= col || y &lt; <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">let</span> temp = board[x][y];<br>        <span class="hljs-keyword">if</span> (board[x][y] === word[k]) &#123;<br>            board[x][y] = <span class="hljs-string">&#x27;*&#x27;</span><br>            <span class="hljs-keyword">if</span> (word.length - <span class="hljs-number">1</span> === k) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(dfs(x + <span class="hljs-number">1</span>, y, k + <span class="hljs-number">1</span>, board, word) || dfs(x - <span class="hljs-number">1</span>, y, k + <span class="hljs-number">1</span>, board, word) || dfs(x, y + <span class="hljs-number">1</span>, k + <span class="hljs-number">1</span>, board, word) || dfs(x, y - <span class="hljs-number">1</span>, k + <span class="hljs-number">1</span>, board, word))<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">else</span> &#123;<br>                board[x][y] = temp;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; row; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>; j &lt; col; j++) &#123;<br>            res = word[<span class="hljs-number">0</span>] === board[i][j] &amp;&amp; dfs(i, j, <span class="hljs-number">0</span>, board, word) || res<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;;<br><span class="hljs-built_in">console</span>.log(exist([[<span class="hljs-string">&quot;C&quot;</span>, <span class="hljs-string">&quot;A&quot;</span>, <span class="hljs-string">&quot;A&quot;</span>], [<span class="hljs-string">&quot;A&quot;</span>, <span class="hljs-string">&quot;A&quot;</span>, <span class="hljs-string">&quot;A&quot;</span>], [<span class="hljs-string">&quot;B&quot;</span>, <span class="hljs-string">&quot;C&quot;</span>, <span class="hljs-string">&quot;D&quot;</span>]],<br>    <span class="hljs-string">&quot;AAB&quot;</span>))<br></code></pre></td></tr></table></figure><h5 id="6、把数字翻译成字符串"><a href="#6、把数字翻译成字符串" class="headerlink" title="6、把数字翻译成字符串"></a>6、把数字翻译成字符串</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number&#125;</span> <span class="hljs-variable">num</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> translateNum = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">num</span>) </span>&#123;<br>    <span class="hljs-keyword">if</span> (num === <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">let</span> str = num.toString();<br>    <span class="hljs-keyword">const</span> length = str.length;<br>    <span class="hljs-keyword">let</span> dp = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(length).fill(<span class="hljs-number">0</span>);<br>    dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt; length; i++) &#123;<br>        <span class="hljs-keyword">let</span> temp = <span class="hljs-built_in">Number</span>(str[i - <span class="hljs-number">1</span>] + str[i]);<br>        <span class="hljs-keyword">if</span> (<span class="hljs-number">10</span> &lt;= temp &amp;&amp; temp &lt;= <span class="hljs-number">25</span>) &#123;<br>            <span class="hljs-keyword">if</span>(i&gt;<span class="hljs-number">1</span>)<br>            dp[i] = dp[i-<span class="hljs-number">1</span>] + dp[i-<span class="hljs-number">2</span>];<br>            <span class="hljs-keyword">else</span> dp[i] = dp[i-<span class="hljs-number">1</span>] + <span class="hljs-number">1</span>;<br>        &#125;<span class="hljs-keyword">else</span> dp[i] = dp[i-<span class="hljs-number">1</span>];<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp.pop();<br>&#125;;<br><br></code></pre></td></tr></table></figure><h5 id="7、礼物的最大价值"><a href="#7、礼物的最大价值" class="headerlink" title="7、礼物的最大价值"></a>7、礼物的最大价值</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number[][]&#125;</span> <span class="hljs-variable">grid</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> maxValue = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">grid</span>) </span>&#123;<br>    <span class="hljs-keyword">const</span> rowNum = grid.length;<br>    <span class="hljs-keyword">const</span> colNum = grid[<span class="hljs-number">0</span>].length;<br>    <span class="hljs-keyword">const</span> dp = [];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; rowNum; ++i) &#123;<br>        dp[i] = [];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>; j &lt; colNum; ++j) &#123;<br>            dp[i][j] = <span class="hljs-number">0</span>;<br>        &#125;<br>    &#125;<br><br>    dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = grid[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt; rowNum; ++i) &#123;<br>        dp[i][<span class="hljs-number">0</span>] = grid[i][<span class="hljs-number">0</span>] + dp[i - <span class="hljs-number">1</span>][<span class="hljs-number">0</span>];<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = <span class="hljs-number">1</span>; j &lt; colNum; ++j) &#123;<br>        dp[<span class="hljs-number">0</span>][j] = grid[<span class="hljs-number">0</span>][j] + dp[<span class="hljs-number">0</span>][j - <span class="hljs-number">1</span>];<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt; rowNum; ++i) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = <span class="hljs-number">1</span>; j &lt; colNum; ++j) &#123;<br>            dp[i][j] = grid[i][j] + <span class="hljs-built_in">Math</span>.max(dp[i - <span class="hljs-number">1</span>][j], dp[i][j - <span class="hljs-number">1</span>]);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> dp[rowNum - <span class="hljs-number">1</span>][colNum - <span class="hljs-number">1</span>];<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="其他："><a href="#其他：" class="headerlink" title="其他："></a>其他：</h4><h5 id="8、字符串的排列组合"><a href="#8、字符串的排列组合" class="headerlink" title="8、字符串的排列组合"></a>8、字符串的排列组合</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;string&#125;</span> <span class="hljs-variable">s</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;string[]&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> permutation = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">s</span>) </span>&#123;<br>    <span class="hljs-keyword">if</span> (!s)<br>        <span class="hljs-keyword">return</span> [];<br>    <span class="hljs-keyword">if</span> (s.length === <span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">return</span> [s];<br>    <span class="hljs-keyword">const</span> res = [];<br>    <span class="hljs-keyword">const</span> list = s.split(<span class="hljs-string">&#x27;&#x27;</span>);<br>    <span class="hljs-keyword">let</span> permu = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">list, begin</span>) </span>&#123;<br>        <span class="hljs-keyword">if</span> (begin === list.length) &#123;<br>            res.push(list.join(<span class="hljs-string">&#x27;&#x27;</span>));<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">let</span> set = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>();<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = begin; i &lt; s.length; i++) &#123;<br>                <span class="hljs-keyword">if</span> (set.has(list[i]))<br>                    <span class="hljs-keyword">continue</span>;<br>                <span class="hljs-keyword">let</span> temp = list[begin];<br>                list[begin] = list[i];<br>                list[i] = temp;<br><br>                permu(list, begin + <span class="hljs-number">1</span>);<br><br>                temp = list[begin];<br>                list[begin] = list[i];<br>                list[i] = temp;<br>                set.add(list[i]);<br>            &#125;<br>        &#125;<br>    &#125;<br>    permu(list, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">return</span> res;<br>&#125;;<br><br></code></pre></td></tr></table></figure><h5 id="9、逆序对"><a href="#9、逆序对" class="headerlink" title="9、逆序对"></a>9、逆序对</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number[]&#125;</span> <span class="hljs-variable">nums</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;number&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">var</span> reversePairs = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">nums</span>) </span>&#123;<br>    <span class="hljs-keyword">let</span> sum = <span class="hljs-number">0</span>;<br>    mergeSort(nums);<br>    <span class="hljs-keyword">return</span> sum;<br><br>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">mergeSort</span>(<span class="hljs-params">nums</span>) </span>&#123;<br>        <span class="hljs-keyword">if</span> (nums.length &lt; <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> nums;<br>        <span class="hljs-keyword">const</span> mid = <span class="hljs-built_in">parseInt</span>(nunms.length / <span class="hljs-number">2</span>);<br>        <span class="hljs-keyword">let</span> left = nums.slice(<span class="hljs-number">0</span>, mid);<br>        <span class="hljs-keyword">let</span> right = nums.slice(mid);<br>        <span class="hljs-keyword">return</span> merge(mergeSort(left), mergeSort(right));<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">merge</span>(<span class="hljs-params">left, right</span>) </span>&#123;<br>        <span class="hljs-keyword">let</span> res = [];<br>        <span class="hljs-keyword">let</span> leftLen = left.length;<br>        <span class="hljs-keyword">let</span> rightLen = right.length;<br>        <span class="hljs-keyword">let</span> len = leftLen + rightLen;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> index = <span class="hljs-number">0</span>, i = <span class="hljs-number">0</span>, j = <span class="hljs-number">0</span>; index &lt; len; index++) &#123;<br>            <span class="hljs-keyword">if</span>(i &gt;= leftLen) res[index] = right[j++];<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(j&gt;=rightLen) res[index] = left[i++];<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(left[i] &lt;= right[j]) res[index] = left[i++];<br>            <span class="hljs-keyword">else</span> &#123;<br>                res[index] = right[j++];<br>                sum += leftLen - i;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h5 id="10、最长回文子串"><a href="#10、最长回文子串" class="headerlink" title="10、最长回文子串"></a>10、最长回文子串</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;string&#125;</span> <span class="hljs-variable">s</span></span></span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;string&#125;</span></span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">longestPalindrome</span>(<span class="hljs-params">arr</span>) </span>&#123;<br>    <span class="hljs-keyword">let</span> left = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">let</span> right = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">let</span> max = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">let</span> now_n = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">let</span> maxstr = <span class="hljs-string">&quot;&quot;</span>;<br>    <span class="hljs-keyword">let</span> max_odd = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">let</span> max_even = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">let</span> odd = <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; arr.length; i++) &#123;<br>        <span class="hljs-keyword">if</span> (arr[i - <span class="hljs-number">1</span>] === arr[i + <span class="hljs-number">1</span>]) &#123;<br>            now_n = <span class="hljs-number">1</span>;<br>            left = i - <span class="hljs-number">1</span>;<br>            right = i + <span class="hljs-number">1</span>;<br>            max_odd = getMax(now_n, left, right, arr);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (arr[i] === arr[i + <span class="hljs-number">1</span>]) &#123;<br>            now_n = <span class="hljs-number">2</span><br>            left = i - <span class="hljs-number">1</span>;<br>            right = i + <span class="hljs-number">2</span>;<br>            max_even = getMax(now_n, left, right, arr)<br>        &#125;<br>        now_n = <span class="hljs-built_in">Math</span>.max(max_odd, max_even)<br>        odd = max_odd === now_n ? <span class="hljs-literal">true</span> : <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">if</span> (now_n &gt; max &amp;&amp; odd) &#123;<br>            max = now_n;<br>            maxstr = arr.substr(i - <span class="hljs-built_in">Math</span>.floor(max - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>, max)<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (now_n &gt; max &amp;&amp; !odd) &#123;<br>            max = now_n;<br>            maxstr = arr.substr(i - max / <span class="hljs-number">2</span> + <span class="hljs-number">1</span>, max)<br>        &#125;<br>        max_even = <span class="hljs-number">0</span>;<br>        max_odd = <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (maxstr === <span class="hljs-string">&quot;&quot;</span>) &#123; <span class="hljs-keyword">return</span> arr[<span class="hljs-number">0</span>] &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> maxstr;<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getMax</span>(<span class="hljs-params">now_n, left, right, arr</span>) </span>&#123;<br>    <span class="hljs-keyword">while</span> (left &gt;= <span class="hljs-number">0</span> &amp;&amp; right &lt; arr.length &amp;&amp; arr[left] === arr[right]) &#123;<br>        now_n = now_n + <span class="hljs-number">2</span>;<br>        left--;<br>        right++;<br>    &#125;<br>    <span class="hljs-keyword">return</span> now_n;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>算法总结</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法总结</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>北京北纬通信科技前端面试</title>
    <link href="/2020/12/31/%E5%8C%97%E4%BA%AC%E5%8C%97%E7%BA%AC%E9%80%9A%E4%BF%A1%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/"/>
    <url>/2020/12/31/%E5%8C%97%E4%BA%AC%E5%8C%97%E7%BA%AC%E9%80%9A%E4%BF%A1%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/</url>
    
    <content type="html"><![CDATA[<a id="more"></a><p>今天从下午两点面试到了五点多，谈了很多吧，今天是Hr先面，基本聊一些家常，然后就是技术总监和一个小姐姐面试，压力挺大的吧，小姐姐先进来说我们老大人可好了。然后说你是北科的？我是地大的你们对面，我17届的。然后就开始了，这是我被面的最长的一次。问题很多，但是leader告诉我，有总结面试的习惯吗？让我试试今天反思出来三个最重要的点，问题问的很多，让我捋一下。</p><h5 id="1、自我介绍"><a href="#1、自我介绍" class="headerlink" title="1、自我介绍"></a>1、自我介绍</h5><h5 id="2、介绍一下自己项目的难点，以及怎么解决的。"><a href="#2、介绍一下自己项目的难点，以及怎么解决的。" class="headerlink" title="2、介绍一下自己项目的难点，以及怎么解决的。"></a>2、介绍一下自己项目的难点，以及怎么解决的。</h5><h5 id="3、问了一下组件间的通信方式。"><a href="#3、问了一下组件间的通信方式。" class="headerlink" title="3、问了一下组件间的通信方式。"></a>3、问了一下组件间的通信方式。</h5><h5 id="4、实现一个左右分布的布局。"><a href="#4、实现一个左右分布的布局。" class="headerlink" title="4、实现一个左右分布的布局。"></a>4、实现一个左右分布的布局。</h5><h5 id="5、了解其他布局方式吗？"><a href="#5、了解其他布局方式吗？" class="headerlink" title="5、了解其他布局方式吗？"></a>5、了解其他布局方式吗？</h5><h5 id="6、盒子模型了解吗？描述一下两种盒子模型的区别-属性值"><a href="#6、盒子模型了解吗？描述一下两种盒子模型的区别-属性值" class="headerlink" title="6、盒子模型了解吗？描述一下两种盒子模型的区别,属性值"></a>6、盒子模型了解吗？描述一下两种盒子模型的区别,属性值</h5><h5 id="7、如何实现一行六个框的布局，然后间隔均匀"><a href="#7、如何实现一行六个框的布局，然后间隔均匀" class="headerlink" title="7、如何实现一行六个框的布局，然后间隔均匀"></a>7、如何实现一行六个框的布局，然后间隔均匀</h5><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.mycards</span> &#123;<br>           <span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span>;<br>           <span class="hljs-attribute">display</span>: flex;<br>           <span class="hljs-attribute">flex-wrap</span>: wrap;<br>           <span class="hljs-attribute">justify-content</span>: space-between;<br>           <span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> red solid;<br>       &#125;<br><br>       <span class="hljs-selector-class">.card_item</span> &#123;<br>           <span class="hljs-attribute">flex</span>: <span class="hljs-number">1</span>;<br>           <span class="hljs-attribute">width</span>: <span class="hljs-number">16%</span>;<br>           <span class="hljs-attribute">min-width</span>: <span class="hljs-number">16%</span>; <br>           <span class="hljs-attribute">max-width</span>:<span class="hljs-number">16%</span>; <br>           <span class="hljs-attribute">height</span>: <span class="hljs-number">350px</span>;<br>           <span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> red solid;<br>       &#125;<br></code></pre></td></tr></table></figure><h5 id="8、能不能不用vuex去实现一个状态管理。"><a href="#8、能不能不用vuex去实现一个状态管理。" class="headerlink" title="8、能不能不用vuex去实现一个状态管理。"></a>8、能不能不用vuex去实现一个状态管理。</h5><h5 id="9、ES6的标准了解多少，介绍一下。"><a href="#9、ES6的标准了解多少，介绍一下。" class="headerlink" title="9、ES6的标准了解多少，介绍一下。"></a>9、ES6的标准了解多少，介绍一下。</h5><h5 id="10、描述一下async和await。"><a href="#10、描述一下async和await。" class="headerlink" title="10、描述一下async和await。"></a>10、描述一下async和await。</h5><h5 id="11、数组去重的方式"><a href="#11、数组去重的方式" class="headerlink" title="11、数组去重的方式"></a>11、数组去重的方式</h5><h5 id="12、就我刚才提到的用set可以去重，问我set去重和普通方式的去重的效率比较"><a href="#12、就我刚才提到的用set可以去重，问我set去重和普通方式的去重的效率比较" class="headerlink" title="12、就我刚才提到的用set可以去重，问我set去重和普通方式的去重的效率比较"></a>12、就我刚才提到的用set可以去重，问我set去重和普通方式的去重的效率比较</h5><h5 id="13、框架选型的问题，为什么选择vue不选择react"><a href="#13、框架选型的问题，为什么选择vue不选择react" class="headerlink" title="13、框架选型的问题，为什么选择vue不选择react"></a>13、框架选型的问题，为什么选择vue不选择react</h5><h5 id="14、前端的优化做哪些，leader说想听我做的实实在在的优化，不是依托外界的"><a href="#14、前端的优化做哪些，leader说想听我做的实实在在的优化，不是依托外界的" class="headerlink" title="14、前端的优化做哪些，leader说想听我做的实实在在的优化，不是依托外界的"></a>14、前端的优化做哪些，leader说想听我做的实实在在的优化，不是依托外界的</h5><h5 id="15、算法问了我如何确定一个回文串的所有中点"><a href="#15、算法问了我如何确定一个回文串的所有中点" class="headerlink" title="15、算法问了我如何确定一个回文串的所有中点"></a>15、算法问了我如何确定一个回文串的所有中点</h5><h5 id="16、好像还问了我在鉴权阶段，如何分别用户"><a href="#16、好像还问了我在鉴权阶段，如何分别用户" class="headerlink" title="16、好像还问了我在鉴权阶段，如何分别用户"></a>16、好像还问了我在鉴权阶段，如何分别用户</h5><h5 id="17、vue3-0和2-0的区别了解吗？"><a href="#17、vue3-0和2-0的区别了解吗？" class="headerlink" title="17、vue3.0和2.0的区别了解吗？"></a>17、vue3.0和2.0的区别了解吗？</h5><h5 id="18、Vue3-0为什么把Object-defineProperty改为Proxy代理，说他的原理。"><a href="#18、Vue3-0为什么把Object-defineProperty改为Proxy代理，说他的原理。" class="headerlink" title="18、Vue3.0为什么把Object.defineProperty改为Proxy代理，说他的原理。"></a>18、Vue3.0为什么把Object.defineProperty改为Proxy代理，说他的原理。</h5><h5 id="19、promise在使用的过程中，如果使用try-catch包住，其中一个是获取name、一个获取phonenumber，第二个用await卡住，但是请求是并行的，如果第一个try-catch捕捉到了第一个错误，还能正常获取第二个值吗？"><a href="#19、promise在使用的过程中，如果使用try-catch包住，其中一个是获取name、一个获取phonenumber，第二个用await卡住，但是请求是并行的，如果第一个try-catch捕捉到了第一个错误，还能正常获取第二个值吗？" class="headerlink" title="19、promise在使用的过程中，如果使用try catch包住，其中一个是获取name、一个获取phonenumber，第二个用await卡住，但是请求是并行的，如果第一个try catch捕捉到了第一个错误，还能正常获取第二个值吗？"></a>19、promise在使用的过程中，如果使用try catch包住，其中一个是获取name、一个获取phonenumber，第二个用await卡住，但是请求是并行的，如果第一个try catch捕捉到了第一个错误，还能正常获取第二个值吗？</h5><h5 id="20、深拷贝和浅拷贝的方式，介绍一下"><a href="#20、深拷贝和浅拷贝的方式，介绍一下" class="headerlink" title="20、深拷贝和浅拷贝的方式，介绍一下"></a>20、深拷贝和浅拷贝的方式，介绍一下</h5><p>深拷贝和浅拷贝这个概念，应该很简单了，对于计算机科班出身的人，应该都知道，浅拷贝获得的是引用，而不会另外开辟内存空间，而深拷贝是会另外开辟内存空间。</p><p>名字是存在栈内存中，值是存在堆内存中，但是栈内存会提供一个引用的地址指向堆内存中的值。b=a进行拷贝时，其实复制的是a的引用地址，而并非堆里的值。</p><p>而当我们a[0]=1时进行数组修改时，由于a与b指向的是同一个地址，所以自然b也受了影响，这就是所谓的浅拷贝。如果能做到在堆内存中也开辟一个新的内存专门存放b的值，就像基本类型哪样，岂不是就达到了深拷贝的效果。</p><p>实现浅拷贝的方法：</p><ul><li>for……in只循环第一层</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">simpleCopy</span>(<span class="hljs-params">obj1</span>) </span>&#123;<br>   <span class="hljs-keyword">var</span> obj2 = <span class="hljs-built_in">Array</span>.isArray(obj1) ? [] : &#123;&#125;;<br>   <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i <span class="hljs-keyword">in</span> obj1) &#123;<br>   obj2[i] = obj1[i];<br>  &#125;<br>   <span class="hljs-keyword">return</span> obj2;<br>&#125;<br></code></pre></td></tr></table></figure><p>网上传的这种做法，我去切实实践了一下</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&gt;<span class="hljs-keyword">var</span> obj4 = simpleCopy(obj)<span class="hljs-comment">//这个simpleCopy是上面这个</span><br>&lt;<span class="hljs-literal">undefined</span><br>&gt;obj4<span class="hljs-comment">//我obj就是这样定义的，拷贝出来，内容一致</span><br>&#123;<span class="hljs-attr">a</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">b</span>: <span class="hljs-number">2</span>&#125;<br>&gt;<span class="hljs-keyword">var</span> obj5=<span class="hljs-built_in">Object</span>.assign(obj)<span class="hljs-comment">//这就是下面的方法，确实是一致的</span><br>&lt;<span class="hljs-literal">undefined</span><br>&gt;obj4===obj<span class="hljs-comment">//本来都是网上博客所说的浅拷贝</span><br>&lt;<span class="hljs-literal">false</span><span class="hljs-comment">//但是只有Object.assign(obj)实现了浅拷贝，那是为什么呢？</span><br>&gt;obj5===obj<br>&lt;<span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p>我进一步思考，好像懂了，确实是浅拷贝，但是对于这个对象的第一层是深拷贝，切切实实的深拷贝，但是对于如果对象里嵌套对象的情况，是无法深拷贝的，所以可以理解是浅拷贝了吧。也就是说，对象的属性如果是对象那么就是一种浅拷贝了。</p><p>同样的原理，Object.assign也是可以实现和上述的simpleCpoy的里面单层深拷贝，多层嵌套却是浅拷贝的样子。Object.assign({},obj) </p><ul><li>Object.assign方法</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> obj = object.assign(obj)<br></code></pre></td></tr></table></figure><ul><li>直接用=赋值</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span>  a = [<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>]<br>b=a<br></code></pre></td></tr></table></figure><p>实现深拷贝的方法：</p><ul><li>采用递归去拷贝所有层级属性</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">/*</span><br><span class="hljs-comment">    手写一个深拷贝的方式</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">cloneInDeep</span>(<span class="hljs-params">source</span>)</span>&#123;<br>    <span class="hljs-keyword">if</span>(source &amp;&amp; <span class="hljs-keyword">typeof</span> source === <span class="hljs-string">&#x27;object&#x27;</span>)&#123;<br>        <span class="hljs-keyword">let</span> target = &#123;&#125;;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> prop <span class="hljs-keyword">in</span> source)&#123;<br>            <span class="hljs-keyword">let</span> value = source[prop];       <span class="hljs-comment">//取出来所有的值</span><br><br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">Array</span>.isArray(value))&#123;       <span class="hljs-comment">// 如果值是个数组，那就重新创建一个数组，将值装入</span><br>                <span class="hljs-keyword">let</span> newArray = [];<br>                value.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">item, index</span>)</span>&#123;<br>                    <span class="hljs-keyword">if</span>(<span class="hljs-built_in">Array</span>.isArray(item) || <span class="hljs-built_in">Object</span>.getPrototypeOf(item) === <span class="hljs-built_in">Object</span>)   <br>                    &#123;<br>                        newArray.push(cloneInDeep(item))      <span class="hljs-comment">//如果数组的值是一个对象，则将对象进一步拷贝</span><br>                    &#125;<span class="hljs-keyword">else</span>&#123;<br>                        newArray.push(item)<br>                    &#125;<br>                &#125;);<br>                target[prop] = newArray;<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(<span class="hljs-built_in">Object</span>.getPrototypeOf(value) === <span class="hljs-built_in">Object</span>.prototype)&#123;<br>                target[prop] = cloneInDeep(value);          <span class="hljs-comment">//对象继续深入拷贝</span><br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                target[prop] = value;       <span class="hljs-comment">//基本数据类型就直接交付</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> target;<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">&#x27;source is not object!&#x27;</span>)<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><a href="https://www.jianshu.com/p/1c142ec2ca45">https://www.jianshu.com/p/1c142ec2ca45</a></p><h5 id="21、移动端开发熟悉吗？"><a href="#21、移动端开发熟悉吗？" class="headerlink" title="21、移动端开发熟悉吗？"></a>21、移动端开发熟悉吗？</h5><h5 id="22、最长公共子串（动态规划）"><a href="#22、最长公共子串（动态规划）" class="headerlink" title="22、最长公共子串（动态规划）"></a>22、最长公共子串（动态规划）</h5><h5 id="23、Echart的参数了解多少？"><a href="#23、Echart的参数了解多少？" class="headerlink" title="23、Echart的参数了解多少？"></a>23、Echart的参数了解多少？</h5><p>问题挺多的，我突然想不起来了，问题挺多的。后面就开始聊家常了，leader问我有没有女朋友是另我猝不及防的，还问我大学期间成绩如何，大学期间参加什么社团、大学期间有没有什么兴趣，和我聊了聊，问我最近看了什么电影，喜欢什么类型的，哈哈哈，告诉我工作不是生活的全部，他也想从测面了解我。聊了很多吧，慢慢就放松了，最后问他会挂我吗？leader说，他不挂我，剩下的一面是架构师面我，让我加油。</p>]]></content>
    
    
    
    <tags>
      
      <tag>面经总结</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>北京宇信科技集团前端面试</title>
    <link href="/2020/12/30/%E5%8C%97%E4%BA%AC%E5%AE%87%E4%BF%A1%E7%A7%91%E6%8A%80%E9%9B%86%E5%9B%A2%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/"/>
    <url>/2020/12/30/%E5%8C%97%E4%BA%AC%E5%AE%87%E4%BF%A1%E7%A7%91%E6%8A%80%E9%9B%86%E5%9B%A2%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/</url>
    
    <content type="html"><![CDATA[<a id="more"></a><p>我今天本来是很凌乱的在写代码，去为字节准备。然后我又收到了拼多多的笔试，我裂开了，就在我考完试的一个小时后，还不能换时间，然后，就在做职业性格测试的时候，突然一个北京的电话，我想起了是之前在双选会上投的前端岗位，然后经典开局。</p><h5 id="1、自我介绍"><a href="#1、自我介绍" class="headerlink" title="1、自我介绍"></a>1、自我介绍</h5><h5 id="2、看到你的项目使用到了vuex，能介绍一下vuex"><a href="#2、看到你的项目使用到了vuex，能介绍一下vuex" class="headerlink" title="2、看到你的项目使用到了vuex，能介绍一下vuex"></a>2、看到你的项目使用到了vuex，能介绍一下vuex</h5><p>vuex是做状态管理的，而且核心熟悉如下：</p><ul><li>state:vuex的基本数据，提供唯一 的公共数据源，所有共享的数据都要统一放在store中的state中，使用单一状态树，包含我们所需要的基本状态参数</li><li>getter：相当于State的计算属性</li><li>mutation:更新数据的方法，同步方式</li><li>action:功能和mutaion大致相同，action是通过提交mutation来更改状态。</li><li>module:整个store对象集中到一个很大的对象，将store分割到很多模块，使得每个模块拥有自己的属性</li></ul><h5 id="3、看到你用过ElementUI和iview说说主要有些啥组件？"><a href="#3、看到你用过ElementUI和iview说说主要有些啥组件？" class="headerlink" title="3、看到你用过ElementUI和iview说说主要有些啥组件？"></a>3、看到你用过ElementUI和iview说说主要有些啥组件？</h5><p>ElementUI:</p><ul><li><p>Layout布局</p><ul><li>Container布局容器</li><li>Color色彩</li><li>Typography字体</li><li>Border 边框</li><li>Icon 图标</li><li>Button 按钮</li><li>Link 文字链接</li></ul></li><li><p>Form</p><ul><li>Radio 单选框</li><li>Checkbox 多选框</li><li>Input 输入框</li><li>InputNumber 计数器</li><li>Select 选择器</li><li>Cascader 级联选择器</li><li>Switch 开关</li><li>Slider 滑块</li><li>TimePicker 时间选择器</li><li>DatePicker 日期选择器</li><li>DateTimePicker 日期时间选择器</li><li>Upload 上传</li><li>Rate 评分</li><li>ColorPicker 颜色选择器</li><li>Transfer 穿梭框</li><li>Form 表单</li></ul></li><li><p>Data</p><ul><li>Table表格</li><li>Tag标签</li><li>Progress进度条</li><li>Tree 树形控件</li><li>Pagination 分页</li><li>Badge 标记</li><li>Avatar 头像</li></ul></li><li><p>Notice</p><ul><li>Alert 警告</li><li>Loading 加载</li><li>Message 消息提示</li><li>MessageBox 弹框</li><li>Notification 通知</li></ul></li><li><p>Navigation</p><ul><li>NavMenu 导航菜单</li><li>Tabs 标签页</li><li>Breadcrumb 面包屑</li><li>PageHeader 页头</li><li>DropDown 下拉菜单</li><li>Steps 步骤条</li></ul></li><li><p>Others</p><ul><li>Dialog 对话框</li><li>Tooltip 文字提示</li><li>Popover 弹出框</li><li>Popconfirm 气泡确认框</li><li>Card 卡片</li><li>Carousel 走马灯</li><li>Collapse 折叠面板</li><li>Timeline 时间线</li><li>Divider 分割线</li><li>Calendar 日历</li><li>Backtop回到顶部</li><li>InfiniteScroll 无限滚动</li><li>Drawer抽屉</li></ul><p>iview不罗列了，去官网看吧：<a href="http://v1.iviewui.com/docs/introduce">http://v1.iviewui.com/docs/introduce</a></p></li></ul><h5 id="4、对Vue的命令知道多少"><a href="#4、对Vue的命令知道多少" class="headerlink" title="4、对Vue的命令知道多少?"></a>4、对Vue的命令知道多少?</h5><ul><li><p>v-text:用于操作纯文本，它会替代显示对应的数据对象上的值。当绑定的数据对象上的值发生改变，插值处的内容也会随之更新。注意：此处为单向绑定，数据 对象上的值改变，插值会发生变化；但是当插值发生变化并不会影响数据对象的值。其中：v-text可以简写为<code>&#123;%&#123;&#125;%&#125;</code>，并且支持逻辑运算。</p></li><li><p>v-html ：用于输出html，它与v-text区别在于v-text输出的是纯文本，浏览器不会对其再进行html解析，但v-html会将其当html标签解析后输出。</p></li><li><p>v-model:通常用于表单组件的绑定，例如input、select等。它与v-text的区别在于它实现的表单组件的双向绑定，如果用于表单控件以外的标签是没用的。</p></li><li><p>v-if:如果v-if=”true”显示v-if的内容，否则显示v-else的内容</p><p>注：<strong>v-if和v-show的作用都把内容显示和隐藏，不同的是，v-if在元素隐藏的时候，是把整个DOM元素删除，v-show知识在DOM元素上添加一个样式，把内容隐藏起来。频繁切换用v-show</strong></p></li><li><p>v-show：把v-show=”true”的内容显示出来。</p></li><li><p>v-else:当v-if=“false”的时候显示v-else的内容。</p></li><li><p>v-on:监听元素事件，并执行相应的操作，v-on可以绑定多个事件。</p></li><li><p>v-bind:绑定元素的熟悉并执行相应的操作</p></li></ul><h5 id="5、那v-bind具体呢？"><a href="#5、那v-bind具体呢？" class="headerlink" title="5、那v-bind具体呢？"></a>5、那v-bind具体呢？</h5><p>v-bind 主要用于属性绑定，比如你的class属性、style属性、value属性、href属性，只要是属性都可以用v-bind指令进行绑定。</p><p>如果我们绑定了class，可以动态的切换class</p><h5 id="5、vue的传值"><a href="#5、vue的传值" class="headerlink" title="5、vue的传值"></a>5、vue的传值</h5><ul><li><p>props/$emit（父-&gt;子）</p><p>在父组件的data中定义一个数据，可以在子组件中使用props来接受</p></li><li><p>事件传递（子-&gt;父）</p><p>在子组件中通过事件，将方法绑定，然后在methods中，完成自定义事件</p><p>在父组件中，通过v-on:自定义事件=函数 并将此函数在method中实现</p></li><li><p>创建一个空的vue实例作为中央事件总线</p><p>通过事件绑定这个自定义事件，通过Event(刚才创建的空实例).emit(自定义事件，传递数据)，同理在需要传递到的组件中，使用Event.$on(自定义事件，数据=&gt; function)</p></li><li><p>vuex</p><p>如果项目大了，使用上面这个方面会显得不易于管理，可以采用vuex作为状态管理方法。vuex实现了一个单向数据流，在全局拥有一个State来存放数据。设置为严格模式时，确保state中的值只能在mutations中被修改。getter是State的计算属性。action和mutation类似，是对异步的函数写入这里，以保证mutaions来仅同步实现。module是为了放在一个state显得冗杂，可以module嵌套，每个module都有自己的属性。</p></li></ul><h5 id="6、未来的职业规划"><a href="#6、未来的职业规划" class="headerlink" title="6、未来的职业规划"></a>6、未来的职业规划</h5><p>抱歉没有标准答案，母鸡，瞎掰。</p><p>然后她就说之后通知hr联系我，可能会有老板面？公司规模不大？不知道，在智联的上面看到公司规模1000人，小公司吧，就一面，后面没用技术面了，就这样吧，随便练练手，第一感觉压力不大，哈哈哈，hr小姐姐人挺好的，说没事，当聊天就好了。体验还不错，拿不拿offer无所谓了，感觉没咋学，就随便面面，攒攒人品。</p>]]></content>
    
    
    
    <tags>
      
      <tag>面经总结</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>笔试学习贴</title>
    <link href="/2020/12/28/%E7%AC%94%E8%AF%95%E9%97%AE%E9%A2%98/"/>
    <url>/2020/12/28/%E7%AC%94%E8%AF%95%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<p>最近拿到了博思软件校园招聘和拼多多的笔试机会，现在就准备一下</p><h5 id="1、哪个样式定义后，内敛（非块状）元素可以定义宽度和高度"><a href="#1、哪个样式定义后，内敛（非块状）元素可以定义宽度和高度" class="headerlink" title="1、哪个样式定义后，内敛（非块状）元素可以定义宽度和高度"></a>1、哪个样式定义后，内敛（非块状）元素可以定义宽度和高度</h5><p>答案：display:block</p><blockquote><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">display</span>属性 :<br><span class="hljs-selector-tag">block</span> :　<span class="hljs-selector-tag">CSS1</span> 块对象的默认值。将对象强制作为块对象呈递，为对象之后添加新行  可以定义高度和宽度<br><span class="hljs-selector-tag">none</span> :　<span class="hljs-selector-tag">CSS1</span> 隐藏对象。与 <span class="hljs-selector-tag">visibility</span> 属性的<span class="hljs-selector-tag">hidden</span>值不同，其不为被隐藏的对象保留其物理空间<br><span class="hljs-selector-tag">inline</span> :　<span class="hljs-selector-tag">CSS1</span> 内联对象的默认值。将对象强制作为内联对象呈递，从对象中删除行<br><span class="hljs-selector-tag">inline-block</span> :　<span class="hljs-selector-tag">IE5</span>.5 将对象呈递为内联对象，但是对象的内容作为块对象呈递。旁边的内联对象会被呈递在同一行内 <span class="hljs-selector-tag">inherit</span>: 看<span class="hljs-selector-tag">display</span>默认是不具备继承性的，使用<span class="hljs-selector-tag">inherit</span>可以让其继承父对象的<span class="hljs-selector-tag">display</span>属性。<br></code></pre></td></tr></table></figure></blockquote><h5 id="2、新窗口打开网页，用到以下哪个值"><a href="#2、新窗口打开网页，用到以下哪个值" class="headerlink" title="2、新窗口打开网页，用到以下哪个值"></a>2、新窗口打开网页，用到以下哪个值</h5><p>答案：_blank</p><p>在html中通过<code>&lt;a&gt;</code>标签打开一个链接，通过 <code>&lt;a&gt; </code>标签的 target 属性规定在何处打开链接文档。</p><p>如果在标签<code>&lt;a&gt;</code>中写入target属性，则浏览器会根据target的属性值去打开与其命名或名称相符的 框架<code>&lt;frame&gt;</code>或者窗口.</p><p>在target中还存在四个保留的属性值如下，</p><ul><li>属性值</li></ul><table><thead><tr><th align="left">值</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">_blank</td><td align="left">在新窗口中打开被链接文档。</td></tr><tr><td align="left">_self</td><td align="left">默认。在相同的框架中打开被链接文档。</td></tr><tr><td align="left">_parent</td><td align="left">在父框架集中打开被链接文档。</td></tr><tr><td align="left">_top</td><td align="left">在整个窗口中打开被链接文档。</td></tr><tr><td align="left"><em>framename</em></td><td align="left">在指定的框架中打开被链接文档。</td></tr></tbody></table><p>这些 target 的所有 4 个值都以下划线开始。任何其他用一个下划线作为开头的窗口或者目标都会被浏览器忽略，因此，不要将下划线作为文档中定义的任何框架 name 或 id 的第一个字符。</p><h5 id="3、元素的alt和title有什么异同，选出正确的说法"><a href="#3、元素的alt和title有什么异同，选出正确的说法" class="headerlink" title="3、元素的alt和title有什么异同，选出正确的说法"></a>3、元素的alt和title有什么异同，选出正确的说法</h5><p>alt是html标签的属性，而title既是html标签，又是html属性。<br>title标签这个不用多说，网页的标题就是写在<code>&lt;title&gt;&lt;/title&gt;</code>这对标签之内的。<br>title作为属性时，用来为元素提供额外说明信息。例如，给超链接标签a添加了title属性，把鼠标移动到该链接上面是，就会显示title的内容，以达到补充说明或者提示的效果。<br>而alt属性则是用来指定替换文字，只能用在img、area和input元素中（包括applet元素），用于网页中图片无法正常显示时给用户提供文字说明使其了解图像信息。</p><h5 id="4、下述有关css属性position的属性值的描述，说法错误的是？"><a href="#4、下述有关css属性position的属性值的描述，说法错误的是？" class="headerlink" title="4、下述有关css属性position的属性值的描述，说法错误的是？"></a>4、下述有关css属性position的属性值的描述，说法错误的是？</h5><p>CSS中Position属性有四个可选值，它们分别是：static、absolute、fixed、relative。</p><p>◆position:static　无定位</p><p>该属性值是所有元素定位的默认情况，在一般情况下，我们不需要特别的去声明它，但有时候遇到继承的情况，我们不愿意见到元素所继承的属性影响本身，从而可以用position:static取消继承，即还原元素定位的默认值。</p><p>◆position:absolute　绝对定位</p><p>使用position:absolute，能够很准确的将元素移动到你想要的位置，</p><p>◆position:fixed　相对于窗口的固定定位</p><p>这个定位属性值是什么意思呢？元素的定位方式同absolute类似，但它的包含块是视区本身。在屏幕媒体如WEB浏览器中，元素在文档滚动时不会在浏览器视察中移动。例如，它允许框架样式布局。在页式媒体如打印输出中，一个固定元素会出现于第一页的相同位置。这一点可用于生成流动标题或脚注。我们也见过相似的效果，但大都数效果不是通过CSS来实现了，而是应用了JS脚本。</p><p>请特别注意，IE6不支持CSS中的position:fixed属性。真的非常遗憾，要不然我们就可以试试这种酷酷的效果了。</p><p>◆position:relative　相对定位</p><p>所谓相对定位到底是什么意思呢，是基于哪里的相对呢？我们需要明确一个概念，相对定位是相对于元素默认的位置的定位。既然是相对的，我们就需要设置不同的值来声明定位在哪里，top、bottom、left、right四个数值配合，来明确元素的位置。</p><h5 id="5、下面有关javascript常见事件的触发情况"><a href="#5、下面有关javascript常见事件的触发情况" class="headerlink" title="5、下面有关javascript常见事件的触发情况"></a>5、下面有关javascript常见事件的触发情况</h5><p>常见事件：</p><ol><li>点击事件：<ol><li>onclick：单击事件</li><li>ondblclick: 双击事件</li></ol></li><li>焦点事件：<ol><li>onblur:失去焦点</li><li>onfocus:元素获得焦点</li></ol></li><li>加载事件<ol><li>onload：一张页面或一幅图像完成加载</li></ol></li><li>鼠标事件：<ol><li>onmousedown: 鼠标按钮被松下</li><li>onmouseup:鼠标按键被松开</li><li>onmousemove:鼠标被移动</li><li>onmouseover:鼠标移到某元素之上</li><li>onmouseout:鼠标从某元素上移开</li></ol></li><li>键盘事件：<ol><li>onkeydown:某个键盘按键被按下</li><li>onkeyup:某个键盘按键被松开。</li><li>onkeypress:某个键盘按键被按下并松开</li></ol></li><li>选择和改变：<ol><li>onchange:域的内容被改变</li><li>onselect:文本被选中</li></ol></li><li>表单事件：<ol><li>onsubmit 确认按钮被点击</li><li>onreset:重置按钮被点击</li></ol></li></ol><h5 id="6、下述有关border-none以及border-0的区别？"><a href="#6、下述有关border-none以及border-0的区别？" class="headerlink" title="6、下述有关border:none以及border:0的区别？"></a>6、下述有关border:none以及border:0的区别？</h5><p>1.效果</p><p>border-style:none;//无边框     </p><p>border-width:0;//边框宽度为0px  </p><p>2.区别</p><p>（1）性能差异</p><p>border:0;浏览器对border-width、border-color进行渲染，占用内存。</p><p>border:none;浏览器不进行渲染，不占用内存。</p><p>Chrome：</p><p>border:none;&gt;&gt; border:initial none initial;</p><p>border:0;&gt;&gt; border:0 initial initial ;</p><p>Firefox、360：</p><p>border:none; &gt;&gt;border:medium none;</p><p>border:0;&gt;&gt; border:0 none;</p><p>计算出的样式：</p><p><strong>border:0px none 元素color属性值;</strong></p><p>（2）浏览器兼容</p><p>IE7-不支持border:none;</p><p>W3C提示：请始终把border-style属性声明到border-color属性之前，元素必须在改变颜色之前获得边框。</p><h5 id="7、下面有关Css-sprites说法？"><a href="#7、下面有关Css-sprites说法？" class="headerlink" title="7、下面有关Css sprites说法？"></a>7、下面有关Css sprites说法？</h5><p>CSS Sprites</p><p>1.简介</p><p>CSS Sprites在国内很多人叫css精灵，是一种网页图片应用处理方式。它允许将一个页面涉及到的所有零星图片都包含到一张大图中， 利用CSS的“background-image”，“background- repeat”，“background-position”的组合进行背景定位， 访问页面时避免图片载入缓慢的现象。</p><p>2.优点</p><p>（1）CSS Sprites能很好地减少网页的http请求，从而大大的提高页面的性能，这是CSS Sprites最大的优点，也是其被广泛传播和应用的主要原因；</p><p>（2）CSS Sprites能减少图片的字节；</p><p>（3）CSS Sprites解决了网页设计师在图片命名上的困扰，只需对一张集合的图片命名，不需要对每一个小图片进行命名，从而提高了网页制作效率。</p><p>（4）CSS Sprites只需要修改一张或少张图片的颜色或样式来改变整个网页的风格。</p><p>3.缺点</p><p>（1）图片合并麻烦：图片合并时，需要把多张图片有序的合理的合并成一张图片，并留好足够的空间防止版块出现不必要的背景。</p><p>（2）图片适应性差：在高分辨的屏幕下自适应页面，若图片不够宽会出现背景断裂。</p><p>（3）图片定位繁琐：开发时需要通过工具测量计算每个背景单元的精确位置。</p><p>（4）可维护性差：页面背景需要少许改动，可能要修改部分或整张已合并的图片，进而要改动css。在避免改动图片的前提下，又只能（最好）往下追加图片，但这样增加了图片字节。</p><h5 id="8、无webkit内核的是"><a href="#8、无webkit内核的是" class="headerlink" title="8、无webkit内核的是"></a>8、无webkit内核的是</h5><p>Wekbit是一个开源的Web浏览器引擎，也就是浏览器的内核。Apple的Safari, Google的Chrome, Nokia S60平台的默认浏览器，Apple手机的默认浏览器，Android手机的默认浏览器均采用的Webkit作为器浏览器内核。Webkit的采用程度由 此可见一斑，理所当然的成为了当今主流的三大浏览器内核之一。另外两个分别是Gecko和Trident，大名鼎鼎的Firefox便是使用的Gecko 内核，而微软的IE系列则使用的是Trident内核。</p><p>另外，搜狗浏览器是双核的，双核并不是指一个页面由2个内核同时处理,而是所有网页（通常是标准通用标记语言的应用超文本标记语言）由webkit内核处理,只有银行网站用IE内核</p><h5 id="9、为所有-lt-h1-gt-添加背景颜色"><a href="#9、为所有-lt-h1-gt-添加背景颜色" class="headerlink" title="9、为所有&lt;h1&gt;添加背景颜色"></a>9、为所有<code>&lt;h1&gt;</code>添加背景颜色</h5><p>h1{background-color:#111111;}</p><h5 id="10、Css哪个属性不属于尺寸属性"><a href="#10、Css哪个属性不属于尺寸属性" class="headerlink" title="10、Css哪个属性不属于尺寸属性"></a>10、Css哪个属性不属于尺寸属性</h5><p>height、line-height、min-width    top不是，top是距离，而非尺寸</p><h5 id="11、正则里的-描述正确的是"><a href="#11、正则里的-描述正确的是" class="headerlink" title="11、正则里的$描述正确的是"></a>11、正则里的$描述正确的是</h5><p>^是正则表达式匹配字符串开始位置</p><p>$是正则表达式匹配字符串结束位置</p><h5 id="12、关于ES6解构表达式"><a href="#12、关于ES6解构表达式" class="headerlink" title="12、关于ES6解构表达式"></a>12、关于ES6解构表达式</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> [a,b, c,d, e] = <span class="hljs-string">``</span><span class="hljs-string">&quot;hello&quot;</span><span class="hljs-string">``</span>; <br></code></pre></td></tr></table></figure><p>描述正确的是（）</p><p>解析：一峰老师的ECMAScript 6入门：<a href="https://es6.ruanyifeng.com/#docs/destructuring">https://es6.ruanyifeng.com/#docs/destructuring</a></p><p>字符串的解构赋值</p><p>字符串也可以解构赋值，因为此时字符串被转换成一个类似数组的对象</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> [a,b, c,d, e] = <span class="hljs-string">&quot;hello&quot;</span>;<br><span class="hljs-built_in">console</span>.log(a);  <span class="hljs-comment">//h</span><br><span class="hljs-built_in">console</span>.log(b);  <span class="hljs-comment">//e</span><br><span class="hljs-built_in">console</span>.log(c);  <span class="hljs-comment">//l</span><br><span class="hljs-built_in">console</span>.log(d);  <span class="hljs-comment">//l</span><br><span class="hljs-built_in">console</span>.log(e);  <span class="hljs-comment">//o</span><br></code></pre></td></tr></table></figure><p>类似数组的对象都有一个 length 属性，因此还可以对这个属性解构赋值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> &#123;<span class="hljs-attr">length</span> : len&#125; = <span class="hljs-string">&#x27;hello&#x27;</span>;<br><span class="hljs-built_in">console</span>.log(len);  <span class="hljs-comment">//5</span><br></code></pre></td></tr></table></figure><h5 id="13、关于ES6-箭头函数-gt-，描述（）"><a href="#13、关于ES6-箭头函数-gt-，描述（）" class="headerlink" title="13、关于ES6 箭头函数 ()=&gt;{} ，描述（）"></a>13、关于ES6 箭头函数 ()=&gt;{} ，描述（）</h5><ul><li>当箭头函数没有参数或有大于等于两个的参数时，必须使用括号，如：let a = ()=&gt;{} 或 let a = (b, c) =&gt; {};</li><li>箭头函数没有arguments 绑定</li><li>箭头函数的this是函数定义的对象，而不是使用函数的对象</li><li>var f = v =&gt; v</li></ul><h5 id="14、Http请求返回码（status-code）中，代表-未授权的请求-的代码是"><a href="#14、Http请求返回码（status-code）中，代表-未授权的请求-的代码是" class="headerlink" title="14、Http请求返回码（status code）中，代表[未授权的请求]的代码是"></a>14、Http请求返回码（status code）中，代表[未授权的请求]的代码是</h5><p>401</p><h5 id="15、当HTMl页面加载完毕时触发的事件是"><a href="#15、当HTMl页面加载完毕时触发的事件是" class="headerlink" title="15、当HTMl页面加载完毕时触发的事件是"></a>15、当HTMl页面加载完毕时触发的事件是</h5><p>onload</p><h5 id="16、CSS3中，能使用div的宽度变化有2秒的过渡效果的属性是提示："><a href="#16、CSS3中，能使用div的宽度变化有2秒的过渡效果的属性是提示：" class="headerlink" title="16、CSS3中，能使用div的宽度变化有2秒的过渡效果的属性是提示："></a>16、CSS3中，能使用div的宽度变化有2秒的过渡效果的属性是提示：</h5><p>div {<br>      transition: width 2s;<br>}</p><h5 id="17、请使用Promise封装Ajax操作"><a href="#17、请使用Promise封装Ajax操作" class="headerlink" title="17、请使用Promise封装Ajax操作"></a>17、请使用Promise封装Ajax操作</h5><p>原始的Ajax操作如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> onSuccess = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">result</span>)</span>&#123;&#125;; <span class="hljs-comment">//成功的回调</span><br><span class="hljs-keyword">var</span> onFail = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">error</span>)</span>&#123;&#125;; <span class="hljs-comment">//失败的回调</span><br><span class="hljs-keyword">var</span> req = <span class="hljs-keyword">new</span> XMLHttpRequest();<br>req.open(<span class="hljs-string">&quot;POST&quot;</span>, <span class="hljs-string">&quot;www.baidu.com&quot;</span>, <span class="hljs-literal">true</span>);<br>req.onload = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br>  <span class="hljs-keyword">if</span>(req.readyState === <span class="hljs-number">4</span> &amp;&amp; req.status === <span class="hljs-number">200</span>)&#123;<br>    onSuccess(req.response);<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    onFail(req.statusText);<br>  &#125;<br>&#125;<br>req.onerror = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br>  onFail(<span class="hljs-built_in">Error</span>(<span class="hljs-string">&quot;网络异常&quot;</span>));<br>&#125;<br></code></pre></td></tr></table></figure><p>答案：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">resolve, reject</span>)</span>&#123;<br>   <span class="hljs-keyword">var</span> req = <span class="hljs-keyword">new</span> XMLHttpRequest();<br>   req.open(<span class="hljs-string">&quot;POST&quot;</span>,<span class="hljs-string">&quot;www.baidu.com&quot;</span>, <span class="hljs-literal">true</span>);<br>   req.onload = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br>     <span class="hljs-keyword">if</span>(req.readyState === <span class="hljs-number">4</span> &amp;&amp; req.status === <span class="hljs-number">200</span>)&#123;<br>       resolve(req.response);<br>     &#125; <span class="hljs-keyword">else</span> &#123;<br>       reject(req.statusText);<br>     &#125;<br>   &#125;<br>   req.onerror = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br>     reject(<span class="hljs-built_in">Error</span>(<span class="hljs-string">&quot;网络异常&quot;</span>));<br>   &#125;<br> &#125;);<br></code></pre></td></tr></table></figure><p>尝试把它跑起来：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">&quot;myFunction()&quot;</span>&gt;</span>发送<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br><span class="javascript">    <span class="hljs-keyword">const</span> request = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">method, url, isajax</span>) </span>&#123;</span><br><span class="javascript">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="javascript">            <span class="hljs-keyword">let</span> req = <span class="hljs-keyword">new</span> XMLHttpRequest();</span><br>            req.open(method, url, isajax);<br><span class="javascript">            req.onload = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;</span><br><span class="javascript">                <span class="hljs-keyword">if</span> (req.readState === <span class="hljs-number">4</span> &amp;&amp; req.status === <span class="hljs-number">200</span>) &#123;</span><br>                    resolve(req.response)<br><span class="javascript">                &#125; <span class="hljs-keyword">else</span> &#123;</span><br>                    reject(req.statusText);<br>                &#125;<br>               <br><span class="javascript">                req.onerror = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;</span><br><span class="javascript">                    reject(<span class="hljs-built_in">Error</span>(<span class="hljs-string">&quot;网络异常&quot;</span>))</span><br>                &#125;<br>            &#125;<br>            req.send();<br>        &#125;)<br>    &#125;<br><br><span class="javascript">    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">myFunction</span>(<span class="hljs-params"></span>) </span>&#123;</span><br><span class="javascript">        <span class="hljs-keyword">let</span> req = request(<span class="hljs-string">&quot;post&quot;</span>, <span class="hljs-string">&quot;www.baidu.com&quot;</span>, <span class="hljs-literal">true</span>)</span><br><span class="javascript">        req.then(<span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> &#123;</span><br><span class="javascript">            <span class="hljs-built_in">console</span>.log(e)</span><br><span class="javascript">        &#125;, <span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> &#123;</span><br><span class="javascript">            <span class="hljs-built_in">console</span>.log(e)</span><br>        &#125;)<br>    &#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><h5 id="18、对于HTTPS建立连接的过程，下面描述正确的是"><a href="#18、对于HTTPS建立连接的过程，下面描述正确的是" class="headerlink" title="18、对于HTTPS建立连接的过程，下面描述正确的是"></a>18、对于HTTPS建立连接的过程，下面描述正确的是</h5><p>DNS TCP TLS HTTP</p><h5 id="19、对于javascript执行引擎描述"><a href="#19、对于javascript执行引擎描述" class="headerlink" title="19、对于javascript执行引擎描述"></a>19、对于javascript执行引擎描述</h5><p>Node.js的Buffer类型对象在创建时内存不会分配到V8堆上</p><h5 id="20、关于解构的说法"><a href="#20、关于解构的说法" class="headerlink" title="20、关于解构的说法"></a>20、关于解构的说法</h5><ul><li>不完全结构，也会成功，不会报错。</li><li>只要支持Iterator接口，都可以被结构赋值。</li><li>null可以替代默认值，而成功的结构赋值。</li><li>结构中不定参数可以出现在除第一个以外的其它的其他位置。</li><li>默认值可以引用结构赋值的其他变量，但该变量必须已经声明。</li></ul><h5 id="21、下列对css外边距描述正确的是（不考虑BFC对边距的影响）"><a href="#21、下列对css外边距描述正确的是（不考虑BFC对边距的影响）" class="headerlink" title="21、下列对css外边距描述正确的是（不考虑BFC对边距的影响）"></a>21、下列对css外边距描述正确的是（不考虑BFC对边距的影响）</h5><p>两个上下相邻的同级元素Div1，Div2。Div1的下边距是20px，Div2的上边距是10px。Div1和Div2的间距是20px</p><p>box1的底部margin为10px，box2的顶部margin为20px，但表现在页面上2者之间的间隔为20px，而不是预想中的10+20px=30px，结果是选择2者之间最大的那个margin，这种机制被称为“外边距合并”；外边距合并不仅仅出现在相邻的元素间，父子间同样会出现。</p><h5 id="22、indexDB"><a href="#22、indexDB" class="headerlink" title="22、indexDB"></a>22、indexDB</h5><p>通俗地说，IndexedDB 就是浏览器提供的本地数据库，它可以被网页脚本创建和操作。IndexedDB 允许储存大量数据，提供查找接口，还能建立索引。这些都是 LocalStorage 所不具备的。就数据库类型而言，IndexedDB 不属于关系型数据库（不支持 SQL 查询语句），更接近 NoSQL 数据库。</p><p>IndexedDB 具有以下特点。</p><p><strong>（1）键值对储存。</strong> IndexedDB 内部采用对象仓库（object store）存放数据。所有类型的数据都可以直接存入，包括 JavaScript 对象。对象仓库中，数据以”键值对”的形式保存，每一个数据记录都有对应的主键，主键是独一无二的，不能有重复，否则会抛出一个错误。</p><p><strong>（2）异步。</strong> IndexedDB 操作时不会锁死浏览器，用户依然可以进行其他操作，这与 LocalStorage 形成对比，后者的操作是同步的。异步设计是为了防止大量数据的读写，拖慢网页的表现。</p><p><strong>（3）支持事务。</strong> IndexedDB 支持事务（transaction），这意味着一系列操作步骤之中，只要有一步失败，整个事务就都取消，数据库回滚到事务发生之前的状态，不存在只改写一部分数据的情况。</p><p><strong>（4）同源限制</strong> IndexedDB 受到同源限制，每一个数据库对应创建它的域名。网页只能访问自身域名下的数据库，而不能访问跨域的数据库。</p><p><strong>（5）储存空间大</strong> IndexedDB 的储存空间比 LocalStorage 大得多，一般来说不少于 250MB，甚至没有上限。</p><p><strong>（6）支持二进制储存。</strong> IndexedDB 不仅可以储存字符串，还可以储存二进制数据（ArrayBuffer 对象和 Blob 对象）</p><h5 id="23、浮点方法"><a href="#23、浮点方法" class="headerlink" title="23、浮点方法"></a>23、浮点方法</h5><ol><li>parseFloat 解析一个字符串，并返回一个浮点数</li><li>toFixed 把数字转换为字符串，结果的小数点后有指定位数的数字</li><li>Math.round 把一个数字舍入为最接近的整数</li><li>toPrecision 把数字格式化为指定的有效数字</li></ol><h5 id="24、如何判断一个js对象是否是Array-arr为要判断的对象，其中最准确的方法是？"><a href="#24、如何判断一个js对象是否是Array-arr为要判断的对象，其中最准确的方法是？" class="headerlink" title="24、如何判断一个js对象是否是Array,arr为要判断的对象，其中最准确的方法是？"></a>24、如何判断一个js对象是否是Array,arr为要判断的对象，其中最准确的方法是？</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">Object</span>.prototype.toString.call(arr) === <span class="hljs-string">&#x27;[object Array]&#x27;</span>;<br></code></pre></td></tr></table></figure><p><img src="https://uploadfiles.nowcoder.com/images/20170720/6941986_1500560338203_5B46C4D74B16DE332AFD135B27C26F7F" alt="img"></p><p>instanceof 在跨 frame 对象构建的场景下会失效</p><h5 id="25、假设DOM结构为："><a href="#25、假设DOM结构为：" class="headerlink" title="25、假设DOM结构为："></a>25、假设DOM结构为：</h5><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;a&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;b&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><p>JS代码为：</p><p>当点击id为b的div时，控制台输出的内容是：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;a&#x27;</span>).addEventListener(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-function"><span class="hljs-params">e</span> =&gt;</span> &#123;<span class="hljs-built_in">console</span>.log(<span class="hljs-number">1</span>)&#125;);<br><span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;b&#x27;</span>).addEventListener(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-function"><span class="hljs-params">e</span> =&gt;</span> &#123;e.preventDefault();<span class="hljs-built_in">console</span>.log(<span class="hljs-number">2</span>)&#125;);<br></code></pre></td></tr></table></figure><p>当点击id为b的div时，控制台输出的内容是：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-number">2</span><br><span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><h5 id="26、js中-和"><a href="#26、js中-和" class="headerlink" title="26、js中==和==="></a>26、js中<code>==</code>和<code>===</code></h5><p>==是会隐式的进行类型转换再进行比较的</p><p>===是不会进行类型转换，严格相等运算符</p><h5 id="27、html5中使用的媒体元素"><a href="#27、html5中使用的媒体元素" class="headerlink" title="27、html5中使用的媒体元素"></a>27、html5中使用的媒体元素</h5><ul><li>audio  定义音频</li><li>video   定义视频</li><li>embed   作为外部应用的容器</li><li>source   多种媒体源的支持</li><li>track   定义媒体的文本跟踪</li></ul><h5 id="28、SVG是什么"><a href="#28、SVG是什么" class="headerlink" title="28、SVG是什么"></a>28、SVG是什么</h5><p>什么是SVG? </p><ul><li>SVG 指可伸缩矢量图形 (Scalable Vector Graphics)</li><li> SVG 用来定义用于网络的基于矢量的图形</li><li>SVG 使用 XML 格式定义图形</li><li>SVG 图像在放大或改变尺寸的情况下其图形质量不会有所损失</li><li>SVG 是万维网联盟的标准</li><li>SVG 与诸如 DOM 和 XSL 之类的 W3C 标准是一个整体<br>(SVG是HTML下的一个分支)</li></ul><h5 id="29、HTML5中新增的标签"><a href="#29、HTML5中新增的标签" class="headerlink" title="29、HTML5中新增的标签"></a>29、HTML5中新增的标签</h5><p>新增header，footer，nav，article，section，aside，datalist，audio，video，embed，input属性</p><h5 id="30、canvas"><a href="#30、canvas" class="headerlink" title="30、canvas"></a>30、canvas</h5><p>canvas 中绘制的元素不可以通过浏览器提供的接口获取到。</p><h5 id="31、SEO优化"><a href="#31、SEO优化" class="headerlink" title="31、SEO优化"></a>31、SEO优化</h5><h5 id="32、XML和JSON的比较"><a href="#32、XML和JSON的比较" class="headerlink" title="32、XML和JSON的比较"></a>32、XML和JSON的比较</h5><p>JSON与XML的区别，在<strong>菜鸟教程</strong>上可以容易找到（<a href="https://www.runoob.com/json/json-vs-xml.html%EF%BC%89%E3%80%82">https://www.runoob.com/json/json-vs-xml.html）。</a></p><p>A. 针对 AJAX 应用，JSON 比 XML 数据加载更快，更简单。</p><p>B. 参考<a href="https://www.nowcoder.com/profile/984905694">tlltll</a>友友对Java和Javascript例子的解释。</p><p>C和E都在说XML比JSON好。但是<strong>菜鸟教程</strong>上明确指明JSON比XML好。😂😂😂JSON可以使用数组形式，XML不能。</p><p>D.JSON 是存储和交换文本信息的语法，是轻量级的文本数据交换格式；而HTML5是为了能在移动设备上支持多媒体而被创造，是HTML（用来描述网页的一种标记语言）最新的修订版本。</p><h5 id="33、伪类和伪元素的区别"><a href="#33、伪类和伪元素的区别" class="headerlink" title="33、伪类和伪元素的区别"></a>33、伪类和伪元素的区别</h5><p><a href="https://www.cnblogs.com/andy-lehhaxm/p/9561776.html">https://www.cnblogs.com/andy-lehhaxm/p/9561776.html</a></p><h5 id="34、哪些可以不用-闭合"><a href="#34、哪些可以不用-闭合" class="headerlink" title="34、哪些可以不用/闭合"></a>34、哪些可以不用/闭合</h5><p>HTML5中：<br>自关闭的斜线(/)对 ：area, base, br, col, command, embed, hr, img, input, keygen, link, meta, param, source, track, wbr空标签无效，言即不再需要自闭合(/)这个小尾巴了，如果要写上也是可以的。</p><h5 id="35、CSS样式中，Border-radius属性作用是什么"><a href="#35、CSS样式中，Border-radius属性作用是什么" class="headerlink" title="35、CSS样式中，Border-radius属性作用是什么"></a>35、CSS样式中，Border-radius属性作用是什么</h5><p>border-radius，国内翻译成圆角，你可能以为这个属性就是用来画圆角，但是除此之外，radius其实指的是边框所在圆的半径，这个CSS3属性不仅能够创建圆角，还可以创建椭圆角，把这些角按照不同的顺序和大小来展现，能够绘制成多种多样的图形。<br>如：border-radius:10px 15px 10px 5px;</p><p>四个值分别表示左上角、右上角、右下角、右下角。</p><h5 id="36、产生带有正方形项目的列表"><a href="#36、产生带有正方形项目的列表" class="headerlink" title="36、产生带有正方形项目的列表"></a>36、产生带有正方形项目的列表</h5><figure class="highlight dsconfig"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dsconfig"><span class="hljs-built_in">list-style-type:</span> <span class="hljs-string">square</span><br></code></pre></td></tr></table></figure><h5 id="37、input属于窗体元素-层级显示比flash、其它元素都高。请判断这句话的正确与否。（F）"><a href="#37、input属于窗体元素-层级显示比flash、其它元素都高。请判断这句话的正确与否。（F）" class="headerlink" title="37、input属于窗体元素,层级显示比flash、其它元素都高。请判断这句话的正确与否。（F）"></a>37、input属于窗体元素,层级显示比flash、其它元素都高。请判断这句话的正确与否。（F）</h5><p>在html中，帧元素（frameset）的优先级最高，表单元素比非表单元素的优先级要高。</p><p>表单元素包括：文本输入框，密码输入框，单选框，复选框，文本输入域，列表框等等；</p><p>非表单元素包括：连接（a），div,table,span等。</p><p>所有的html元素又可以根据其显示分成两类：有窗口元素以及无窗口元素。有窗口元素总是显示在无窗口元素的前面。</p><p>有窗口元素包括：select元素，object元素，以及frames元素等等。</p><p>无窗口元素：大部分html元素都是无窗口元素。</p><h5 id="38、-lt-address-gt-和-lt-hr-gt-和-lt-a-gt-和-lt-cite-gt"><a href="#38、-lt-address-gt-和-lt-hr-gt-和-lt-a-gt-和-lt-cite-gt" class="headerlink" title="38、&lt;address&gt;和&lt;hr&gt;和&lt;a&gt;和&lt;cite&gt;"></a>38、<code>&lt;address&gt;</code>和<code>&lt;hr&gt;</code>和<code>&lt;a&gt;</code>和<code>&lt;cite&gt;</code></h5><p><code>&lt;address&gt; </code>标签定义文档或文章的作者/拥有者的联系信息。</p><p><code>&lt;hr&gt; </code>标签在 HTML 页面中创建一条水平线。</p><p><code>&lt;a&gt;</code> 标签定义超链接，用于从一张页面链接到另一张页面。</p><p><code>&lt;cite&gt;</code> 标签通常表示它所包含的文本对某个参考文献的引用，比如书籍或者杂志的标题。</p><h5 id="39、input元素种类"><a href="#39、input元素种类" class="headerlink" title="39、input元素种类"></a>39、input元素种类</h5><p>HTML input元素种类</p><ul><li><p>email</p></li><li><p>url</p></li><li><p>number</p></li><li><p>range</p></li><li><p>Date pickers(date, month, week, time, datetime, datetime-local)</p></li><li><p>search</p></li><li><p>color</p></li></ul><h5 id="40、hgroup在H5中用于组合标题元素"><a href="#40、hgroup在H5中用于组合标题元素" class="headerlink" title="40、hgroup在H5中用于组合标题元素"></a>40、hgroup在H5中用于组合标题元素</h5><h5 id="41、slider可以定义滑块控件"><a href="#41、slider可以定义滑块控件" class="headerlink" title="41、slider可以定义滑块控件"></a>41、slider可以定义滑块控件</h5><p>其他什么的</p><table><thead><tr><th>button</th><th>定义可点击的按钮（大多与 JavaScript 使用来启动脚本）</th></tr></thead><tbody><tr><td>checkbox</td><td>定义复选框。</td></tr><tr><td>color</td><td>定义拾色器。</td></tr><tr><td>date</td><td>定义日期字段（带有 calendar 控件）</td></tr><tr><td>datetime</td><td>定义日期字段（带有 calendar 和 time 控件）</td></tr><tr><td>datetime-local</td><td>定义日期字段（带有 calendar 和 time 控件）</td></tr><tr><td>month</td><td>定义日期字段的月（带有 calendar 控件）</td></tr><tr><td>week</td><td>定义日期字段的周（带有 calendar 控件）</td></tr><tr><td>time</td><td>定义日期字段的时、分、秒（带有 time 控件）</td></tr><tr><td>email</td><td>定义用于 e-mail 地址的文本字段</td></tr><tr><td>file</td><td>定义输入字段和 “浏览…” 按钮，供文件上传</td></tr><tr><td>hidden</td><td>定义隐藏输入字段</td></tr><tr><td>image</td><td>定义图像作为提交按钮</td></tr><tr><td>number</td><td>定义带有 spinner 控件的数字字段</td></tr><tr><td>password</td><td>定义密码字段。字段中的字符会被遮蔽。</td></tr><tr><td>radio</td><td>定义单选按钮。</td></tr><tr><td>range</td><td>定义带有 slider 控件的数字字段。</td></tr><tr><td>reset</td><td>定义重置按钮。重置按钮会将所有表单字段重置为初始值。</td></tr><tr><td>search</td><td>定义用于搜索的文本字段。</td></tr><tr><td>submit</td><td>定义提交按钮。提交按钮向服务器发送数据。</td></tr><tr><td>tel</td><td>定义用于电话号码的文本字段。</td></tr><tr><td>text</td><td>默认。定义单行输入字段，用户可在其中输入文本。默认是 20 个字符。</td></tr><tr><td>url</td><td>定义用于 URL 的文本字段。</td></tr></tbody></table><h5 id="42、可以继承和不可以继承的"><a href="#42、可以继承和不可以继承的" class="headerlink" title="42、可以继承和不可以继承的"></a>42、可以继承和不可以继承的</h5><p><a href="https://www.cnblogs.com/thislbq/p/5882105.html">https://www.cnblogs.com/thislbq/p/5882105.html</a></p><h5 id="43、自动类型转换"><a href="#43、自动类型转换" class="headerlink" title="43、自动类型转换"></a>43、自动类型转换</h5><p>①为任意的数据类型“10”+3即可将其<strong>转换成String</strong>字符串类型，这是一种隐式类型转换，由浏览器自动完成，实际上也是调用String()函数。</p><p>②为任意的数据类型 “103”-“1” 即可将其<strong>转换成Number</strong>数值类型。</p><h5 id="44、回流触发"><a href="#44、回流触发" class="headerlink" title="44、回流触发"></a>44、回流触发</h5><p>首先早知道reflow是什么？ reflow(回流)是指浏览器为了重新渲染部分或者全部的文档,重新计算文档中的元素的位置和几何构造的过程。 因为回流可能导致整个Dom树的重新构造,所以是性能的一大杀手。 以下操作会引起回流：</p><p> ① 改变窗口大小</p><p> ② font-size大小改变</p><p> ③ 增加或者移除样式表 </p><p> ④ 内容变化（input中输入文字会导致）</p><p> ⑤ 激活CSS伪类（:hover）</p><p> ⑥ 操作class属性，新增或者减少</p><p> ⑦ js操作dom </p><p> ⑧ offset相关属性计算</p><p> ⑨ 设置style的值 …… 另外: reflow与repaint（重绘）是减缓js的几大主要原因，尤其是reflow更是性能杀手，所以我们应该想法避免。</p><h5 id="45、Vue-js具备的特性"><a href="#45、Vue-js具备的特性" class="headerlink" title="45、Vue.js具备的特性"></a>45、Vue.js具备的特性</h5><p>指令和过滤器</p><h5 id="46、Canvas和SVG的区别"><a href="#46、Canvas和SVG的区别" class="headerlink" title="46、Canvas和SVG的区别"></a>46、Canvas和SVG的区别</h5><ul><li><p>Canvas产生的dom数量比SVG要少</p></li><li><p>SVG可以使用css设置动画样式，但是Canv as不能用css设置动画样式</p></li><li><p>canvas 中绘制的元素不可以通过浏览器提供的接口获取到。SVG可以通过浏览器提供的接口获取到。</p><p>SVG与Canvas的区别<br> SVG<br>   不依赖分辨率<br>   支持事件绑定<br>   大型渲染区域的程序(例如百度地图)<br>   不能用来实现网页游戏<br>Canvas<br>   依赖分辨率<br>   不支持事件绑定<br>   最合适网页游戏<br>   保存为”.jpg”格式的图片</p></li></ul><h5 id="47、XML说法"><a href="#47、XML说法" class="headerlink" title="47、XML说法"></a>47、XML说法</h5><ul><li><p>Xml一般用于传输和存储数据，是对html的补充，两者的目的不同</p></li><li><p>在JavaScript里解析和处理xml数据时，因为浏览器的不同，其做法也不同</p></li><li><p>在IE浏览器里处理xml，首先需要创建ActiveXObject对象</p></li></ul><h5 id="48、jquery想找所有元素的同辈元素"><a href="#48、jquery想找所有元素的同辈元素" class="headerlink" title="48、jquery想找所有元素的同辈元素"></a>48、jquery想找所有元素的同辈元素</h5><p>siblings([expr])同辈，find([expr])后辈，eq第几个，next()下一个</p><h5 id="49、-lt-i-gt-lt-em-gt-标签语义表示"><a href="#49、-lt-i-gt-lt-em-gt-标签语义表示" class="headerlink" title="49、&lt;i&gt;``&lt;em&gt;标签语义表示"></a>49、<code>&lt;i&gt;``&lt;em&gt;</code>标签语义表示</h5><p><code>&lt;i&gt;</code>标签只是单纯的样式标签，表现斜体的样式，但是语义上与普通文本无异；<code>&lt;em&gt;</code>标签在样式上表示为斜体，同时在语义上也表示为斜体。<code>&lt;em&gt;</code>标签可以被设备识别，而<code>&lt;i&gt;</code>标签不能被识别。</p><h5 id="50、使用link和-import有什么区别"><a href="#50、使用link和-import有什么区别" class="headerlink" title="50、使用link和@import有什么区别"></a>50、使用link和@import有什么区别</h5><p>1.从属关系区别 @import是 CSS 提供的语法规则，只有导入样式表的作用；link是HTML提供的标签，不仅可以加载 CSS 文件，还可以定义 RSS、rel 连接属性等。 </p><p>2.加载顺序区别 加载页面时，link标签引入的 CSS 被同时加载；@import引入的 CSS 将在页面加载完毕后被加载。</p><p> 3.兼容性区别 @import是 CSS2.1 才有的语法，故只可在 IE5+ 才能识别；link标签作为 HTML 元素，不存在兼容性问题。</p><p> 4.DOM可控性区别 可以通过 JS 操作 DOM ，插入link标签来改变样式；由于 DOM 方法是基于文档的，无法使用@import的方式插入样式。</p><p>5.权重区别 link引入的样式权重大于@import引入的样式。</p><h5 id="51、JS的RegExp对象方法"><a href="#51、JS的RegExp对象方法" class="headerlink" title="51、JS的RegExp对象方法"></a>51、JS的RegExp对象方法</h5><p>JavaScript RegExp 对象有 3 个方法：test()、exec() 和 compile()。</p><ol><li>test() 方法用来检测一个字符串是否匹配某个正则表达式，如果匹配成功，返回 true ，否则返回 false；</li><li>exec() 方法用来检索字符串中与正则表达式匹配的值。exec() 方法返回一个数组，其中存放匹配的结果。如果未找到匹配的值，则返回 null；</li><li>compile() 方法可以在脚本执行过程中编译正则表达式，也可以改变已有表达式。</li></ol><p>注：<strong>match是支持正则表达式的String对象的方法</strong></p><h5 id="52、Javascript的全局函数"><a href="#52、Javascript的全局函数" class="headerlink" title="52、Javascript的全局函数"></a>52、Javascript的全局函数</h5><p>编码相关：</p><p>  escape()、unescape()、encodeURI()、decodeURI()、</p><p>  encodeURIComponent()、decodeURIComponent()</p><p>数据处理：</p><p>  Number()、String()</p><p>数字相关：</p><p>  isFinite()、isNaN()、parseFloat()、parseInt()</p><p>特殊：</p><p>  eval()</p><p>ps:对于 getClass() 方法。</p><h5 id="53、判断是不是数组对象"><a href="#53、判断是不是数组对象" class="headerlink" title="53、判断是不是数组对象"></a>53、判断是不是数组对象</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]<br><span class="hljs-built_in">Array</span>.isArray()<br><br>arr <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Array</span><br><br><span class="hljs-built_in">Object</span>.prototype.toString.call([<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>])  <span class="hljs-comment">/*比较推荐这个,因为准备吧*/</span><br></code></pre></td></tr></table></figure><h5 id="54、input元素在html5中新增了哪些type属性"><a href="#54、input元素在html5中新增了哪些type属性" class="headerlink" title="54、input元素在html5中新增了哪些type属性"></a>54、input元素在html5中新增了哪些type属性</h5><p>在HTML5中，为input元素新增了以下一些type属性值：</p><ul><li>color：用于指定颜色的控件。</li><li>date：用于输入日期的控件（年，月，日，不包括时间）。</li><li>month：用于输入年月的控件，不带时区。</li><li>week：用于输入一个由星期-年组成的日期，日期不包括时区</li><li>time：用于输入不含时区的时间控件。</li><li>datetime：基于UTC时区的日期时间输入控件（时，分，秒及几分之一秒）。</li><li>datetime-local：用于输入日期时间控件，不包含时区。</li><li>email：用于应该包含 e-mail 地址的输入域。在提交表单时，会自动验证 email 域的值。</li><li>number: 用于应该包含数值的输入域。只能输入数字</li><li>range：用于应该包含一定范围内数字值的输入域。range 类型显示为滑动条。</li><li>search：用于输入搜索字符串的单行文本字段。换行会被从输入的值中自动移除。</li><li>tel：用于输入电话号码的控件。在移动端输入会显示数字键盘，PC端无效果</li><li>url：用于编辑URL的字段。</li></ul><h5 id="55、设置不同屏幕中，元素的位置不会发生改变的是（）"><a href="#55、设置不同屏幕中，元素的位置不会发生改变的是（）" class="headerlink" title="55、设置不同屏幕中，元素的位置不会发生改变的是（）"></a>55、设置不同屏幕中，元素的位置不会发生改变的是（）</h5><p>使用 @media screen查询，你可以针对不同的媒体类型定义不同的样式。</p><p>@media 可以针对不同的屏幕尺寸设置不同的样式，特别是如果你需要设置设计响应式的页面，@media 是非常有用的。</p><p>当你重置浏览器大小的过程中，页面也会根据浏览器的宽度和高度重新渲染页面。</p><h5 id="56、实现翻书的效果可以使用css3里的什么方法"><a href="#56、实现翻书的效果可以使用css3里的什么方法" class="headerlink" title="56、实现翻书的效果可以使用css3里的什么方法"></a>56、实现翻书的效果可以使用css3里的什么方法</h5><p>A、rotateY：定义沿 Y 轴的 3D 旋转，可实现翻书的效果</p><p>B、translateY：沿着 Y 轴移动元素</p><p>C、scaleY：定义 2D 缩放转换时，改变元素的高度；定义 3D 缩放转换时，通过给定一个 Y 轴的值</p><p>D、perspective(n)：改变3D元素是怎样查看透视图（注：只影响 3D 转换元素）</p><h5 id="57、H5中常用的新特性"><a href="#57、H5中常用的新特性" class="headerlink" title="57、H5中常用的新特性"></a>57、H5中常用的新特性</h5><p>HTML5中常用的新特性：</p><p>canvas元素：用于定义图形（图表等），只是图形容器，必须使用脚本来绘制图形。</p><p>audio：用于音频播放。</p><p>video：用于视频播放。</p><p>article：规定独立的自包含内容。</p><p>header：定义文档的页眉，介绍相关信息。</p><p>section：定义文档中的节。</p><p>footer：定义文档的页脚，通常有文档的作者、版权信息、联系方式等。</p><p>nav：定义导航链接。</p><p>表单控件：</p><p>calender</p><p>date</p><p>time</p><p>email</p><p>url</p><p>search</p><h5 id="58、在文件-home-somebody-workspace-somemodule-js中第一行引用了一个模块：require-‘othermodule‘-，请问required-的查找模块的顺序"><a href="#58、在文件-home-somebody-workspace-somemodule-js中第一行引用了一个模块：require-‘othermodule‘-，请问required-的查找模块的顺序" class="headerlink" title="58、在文件/home/somebody/workspace/somemodule.js中第一行引用了一个模块：require(‘othermodule‘)，请问required 的查找模块的顺序"></a>58、在文件/home/somebody/workspace/somemodule.js中第一行引用了一个模块：require(‘othermodule‘)，请问required 的查找模块的顺序</h5><p>A. /home/somebody/workspace/node_modules/othermodule/index.js<br>B. /home/somebody/workspace/node_modules/othermodule. Js<br>C.CORE MODULES named othermodule<br>D./home/somebody/node_modules/othermodule/index.js</p><p>解析：(1):首先，Node在当前目录下查找<code>package.json</code>(CommonJS包规范定义的包描述文件)，通过JSON.parse()解析出包描述对象，从中取出main属性指定的文件名进行定位。如果文件缺少扩展名，将会进入扩展名分析的步骤。 　　</p><p>(2):而如果main属性制定的文件名错误，或者压根没有package.json文件，Node会将index当做默认文件名，然后依次查找index.js、index.node、index.json. 　　</p><p>(3):如果在目录分析的过程中没有定位成功任何文件，则自定义模块进入下一个模块路径进行查找。如果模块路径数组都被遍历完毕，依然没有查找到目标文件，则会抛出查找失败异常。 　　按照上面的思路，首先应该查找package.json文件，看看里面有没有核心模块，应该是C最先，othermodule不是核心模块，那么接着应该进入扩展名分析的步骤，就应该是查找othermodule. js，对应B，紧接着就是以index为默认文件名，也就是A，再接下来就是上一个文件目录D了，<br>所以答案是： C B A D</p><h5 id="59、嵌入在HTMl文档中的图像格式是"><a href="#59、嵌入在HTMl文档中的图像格式是" class="headerlink" title="59、嵌入在HTMl文档中的图像格式是"></a>59、嵌入在HTMl文档中的图像格式是</h5><p>网页html文档支持的图片格式有jpg ， gif  ,   png  和  bmp  这四种，jpg ， gif  和  png 格式的图片特点是体积很小，因为在网上很常见，然而 bmp就不常见了，因为这种格式虽然很清晰色彩丰富，但是所占内存很大，所以很少见，但是也是支持的。一共这4种</p><h5 id="60、bootstrap中如何让一个区块居中"><a href="#60、bootstrap中如何让一个区块居中" class="headerlink" title="60、bootstrap中如何让一个区块居中?"></a>60、bootstrap中如何让一个区块居中?</h5><p>center、center-block</p><p>center是指<code>&lt;center&gt;&lt;/center&gt;</code>标签,center-block是bootstrap的样式 .center-block</p><h5 id="61、行内块标签"><a href="#61、行内块标签" class="headerlink" title="61、行内块标签"></a>61、行内块标签</h5><p>行内元素典型代表 span ,a, ,strong , em, del, ins</p><p>特点：★在一行上显示</p><p>   ★不能直接设置宽高</p><p>   ★元素的宽和高就是内容撑开的宽高。</p><p>行内块元素（内联元素）典型代表 input img</p><p>特点：★在一行上显示</p><p>   ★可以设置宽高</p><p>块元素典型代表,div,h1-h6,p,ul,li</p><p>特点: ★独占一行</p><p>   ★可以设置宽高</p><p>   ★ 嵌套（包含）下，子块元素宽度（没有定义情况下）和父块元素宽度默认一致。</p><h5 id="62、this的问题"><a href="#62、this的问题" class="headerlink" title="62、this的问题"></a>62、this的问题</h5><p>this的行为有时候会显得极其诡异，让人感到困惑，但只需要记住 <strong>this的值要等到代码真正执行时才能确定</strong><br>同时this的值具体有以下几种情况：</p><ol><li>new 调用时指的是被构造的对象</li><li>call、apply调用，指向我们指定的对象</li><li>对象调用，如执行obj.b()，this指向obj</li><li>默认的，指向全局变量window(相当于执行window.fun())</li></ol><p>这样看来，当你执行fun()的时候，以上1,2点均不满足。<br>第3点,因为this是运行时确定的，而我们执行fun()，等同于windown.fun()(<strong>与obj没有任何关系</strong>)，自然的this指向window，而window没有定义变量a，结果是undefined。</p><h5 id="63、如何使用css-选择器定义某个父元素中所有第”奇数”个子元素的样式："><a href="#63、如何使用css-选择器定义某个父元素中所有第”奇数”个子元素的样式：" class="headerlink" title="63、如何使用css 选择器定义某个父元素中所有第”奇数”个子元素的样式："></a>63、如何使用css 选择器定义某个父元素中所有第”奇数”个子元素的样式：</h5><p>nth-child(odd) ：定义某个父元素中所有第”奇数”个子元素的样式</p><p>nth-of-type(odd) ：定义某个父元素中的不同类型中的所有第”奇数”个子元素的样式</p><p>nth-child(odd) 奇数 ,nth-child(even) 偶数。</p><p>nth-child(n) : 匹配父元素中的第 n 个子元素，元素类型没有限制。</p><h5 id="64、哪个元素创建了一组选项"><a href="#64、哪个元素创建了一组选项" class="headerlink" title="64、哪个元素创建了一组选项"></a>64、哪个元素创建了一组选项</h5><p><code>&lt;optgroup&gt;</code></p><h5 id="65、哪些方法可以用作javascript异步模式的编程"><a href="#65、哪些方法可以用作javascript异步模式的编程" class="headerlink" title="65、哪些方法可以用作javascript异步模式的编程"></a>65、哪些方法可以用作javascript异步模式的编程</h5><p>先解释一下“同步模式”和“异步模式”：<br>（1）同步模式：就是后一个任务等待前一个任务结束，然后再执行，程序的执行顺序与任务的排列顺序是一致的、同步的。<br>（2）异步模式：完全不同，每一个任务有一个或多个回调函数（callback），前一个任务结束后，不是执行后一个任务，而是执行回调函数，<br>                           后一个任务则是不等前一个任务结束就执行，所以程序的执行顺序与任务的排列顺序是不一致的、异步的。<br>JavaScript中实现异步编程模式的4种方法,回调函数、事件监听、发布/订阅、Promises对象：<br>（1）回调函数：这是异步编程最基本的方法，优点是简单、容易理解和部署，缺点是不利于代码的阅读和维护，各个部分之间高度耦合<br>                        （Coupling），流程会很混乱，而且每个任务只能指定一个回调函数。<br>                         例：假定有两个函数f1和f2，后者等待前者的执行结果，如果f1是一个很耗时的任务，可以考虑改写f1，把f2写成f1的回调函<br>                         数。<br>（2）事件监听：任务的执行不取决于代码的顺序，而取决于某个事件是否发生。优点是比较容易理解，可以绑定多个事件，每个事件可以指定<br>                           多个回调函数，而且可以”去耦合”（Decoupling），有利于实现模块化。缺点是整个程序都要变成事件驱动型，运行流程会变<br>                           得很不清晰。<br>                           例：为f1绑定一个事件，当f1发生done事件，就执行f2。<br>（3）发布/订阅：我们假定，存在一个”信号中心”，某个任务执行完成，就向信号中心”发布”（publish）一个信号，其他任务可以向信号中心”订<br>                           阅”（subscribe）这个信号，从而知道什么时候自己可以开始执行。这就叫做”发布/订阅模式”（publish-subscribe pattern），<br>                           又称”观察者模式”（observer pattern）。<br>                           这种方法的性质与”事件监听”类似，但是明显优于后者。因为我们可以通过查看”消息中心”，了解存在多少信号、每个信号<br>                           有多少订阅者，从而监控程序的运行。<br>（4）Promises对象：是CommonJS工作组提出的一种规范，目的是为异步编程提供统一接口。简单说，它的思想是，每一个异步任务返回一个<br>                                  Promise对象，该对象有一个then方法，允许指定回调函数。回调函数变成了链式写法，程序的流程可以看得很清楚，而<br>                                  且有一整套的配套方法，可以实现许多强大的功能。<br>                                  例：f1的回调函数f2，f1().then(f2);</p><h5 id="66、Ajax和Flash的优缺点"><a href="#66、Ajax和Flash的优缺点" class="headerlink" title="66、Ajax和Flash的优缺点"></a>66、Ajax和Flash的优缺点</h5><p><strong>引用：<a href="http://www.awflasher.com/blog/archives/503">http://www.awflasher.com/blog/archives/503</a><br>Ajax的优势</strong></p><p><strong>可搜索性</strong><br>普通的文本网页会更有利于SEO。文本内容是搜索引擎容易检索的，而繁琐的swf字节码却是搜索引擎不愿触及的。虽然Google等一些大型的搜索引擎可以检索SWF内部的内容，但是仍然有很多麻烦存在。</p><p><strong>开放性</strong><br>Flash常年以来被Macromedia看的很死。包括Flex、FMS等辅佐技术一直都需要昂贵的安装、维护费用。而JS则没有这样的麻烦。没有人愿意承担法律和版权的风险。</p><p><strong>费用</strong><br>Flash开发是很昂贵的，因为FlashIDE等环境都是要收费的．而Ajax则不同．虽然有一些便宜的生成swf的工具，但是他们的工能实在无法满足复杂需求。</p><p><strong>易用性</strong><br>Ajax程序有更好的易用性。由于中间有一层Flashplayer***层，因此许多辅助功能无法被Flash灵活利用。而且Flash在一些方面有着不好的口碑。比如弹出广告、比如恶意代码。<br>（awflasher.com个人认为这八成是乱上xx网站造成的）</p><p><strong>易于开发</strong><br>人们开发复杂的Ajax和Flash应用程序时，都会借助一些高级的开发工具。普遍来说，Ajax的开发包比Flash简便、容易。</p><p><strong>Flash的优势</strong><br><strong>多媒体处理</strong><br>Flash在音频、视频等多媒体领域相比HTML有绝对的优势。现在几乎所有的网站都包含有Flash内容。</p><p><strong>兼容性</strong><br>兼容性好：由于通过了唯一的FlashPlayer“***”。人们不必像调试JS那样，在不同的浏览器中调试程序。</p><p><strong>矢量图型</strong><br>这是Flash最大的优势，同样处在这一领域的SVG、Canvas element以及Direct完全不能与Flash相比。</p><p><strong>客户端资源调度</strong><br>Flash能够更容易的调用浏览器以外的外部资源。比如摄像头、麦克风等。然而这是普通的HTML无法完成的。但是这也许是一个缺点（为什么呢？）</p><h5 id="67、ele-clientWidth-宽度-padding"><a href="#67、ele-clientWidth-宽度-padding" class="headerlink" title="67、ele.clientWidth = 宽度 + padding"></a>67、ele.clientWidth = 宽度 + padding</h5><p>ele.offsetWidth = 宽度 + padding + border</p><p> ele.scrollTop = 被卷去的上侧距离</p><p> ele.scrollHeight = 自身实际的高度（不包括边框）</p><h5 id="68-关于BFC"><a href="#68-关于BFC" class="headerlink" title="68.关于BFC"></a>68.关于BFC</h5><p>在一个Web页面的CSS渲染中，<a href="http://www.w3.org/TR/CSS21/visuren.html#block-formatting">块级格式化上下文</a> (Block Fromatting Context)是按照块级盒子布局的。W3C对BFC的定义如下：</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gams">浮动元素和绝对定位元素，非块级盒子的块级容器（例如 inline-blocks, <span class="hljs-keyword">table</span>-cells, 和 <span class="hljs-keyword">table</span>-captions），以及overflow值不为“visiable”的块级盒子，都会为他们的内容创建新的BFC（块级格式上下文）。<br></code></pre></td></tr></table></figure><p>为了便于理解，我们换一种方式来重新定义BFC。一个HTML元素要创建BFC，则满足下列的任意一个或多个条件即可：</p><p>1、float的值不是none。<br>2、position的值不是static或者relative。<br>3、display的值是inline-block、table-cell、flex、table-caption或者inline-flex<br>4、overflow的值不是visible</p><p>BFC是一个独立的布局环境，其中的元素布局是不受外界的影响，并且在一个BFC中，块盒与行盒（行盒由一行中所有的内联元素所组成）都会垂直的沿着其父元素的边框排列。</p>]]></content>
    
    
    <categories>
      
      <category>javascript、css、html</category>
      
    </categories>
    
    
    <tags>
      
      <tag>笔试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>学习贴</title>
    <link href="/2020/12/26/%E5%AD%A6%E4%B9%A0%E5%88%AB%E4%BA%BA%E7%9A%84%E9%9D%A2%E7%BB%8F/"/>
    <url>/2020/12/26/%E5%AD%A6%E4%B9%A0%E5%88%AB%E4%BA%BA%E7%9A%84%E9%9D%A2%E7%BB%8F/</url>
    
    <content type="html"><![CDATA[<p>经历了上次面试，我觉得遇到不会的点还是要踏踏实实的落实一遍，just do it！</p><a id="more"></a><h5 id="1、CSS居中的方法有哪些"><a href="#1、CSS居中的方法有哪些" class="headerlink" title="1、CSS居中的方法有哪些"></a>1、CSS居中的方法有哪些</h5><ul><li><p>水平居中</p><ul><li><p>行内元素</p><p>把行内元素放在一个属性块（display:block）元素中，然后设置父层元素属性居中：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.test</span>&#123;<br><span class="hljs-attribute">text-align</span>:center;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>块内元素</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.test</span>&#123;<br><span class="hljs-attribute">margin</span>: <span class="hljs-number">10px</span> auto<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>多个块状元素</p><ul><li>把块状元素属性（display:inline-block）,然后设置父层元素属性居中：</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.test</span>&#123;<br><span class="hljs-attribute">text-align</span>:center<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>flexbox布局实现：把块状元素的父元素属性display:flex和justify-content:center</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.test</span>&#123;<br>        <span class="hljs-attribute">display</span>:flex<br>        justify-content:center<br>    text-align:center;<br>    &#125;<br></code></pre></td></tr></table></figure></li></ul></li><li><p>垂直居中</p><ul><li><p>多行的行内元素</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.test</span>&#123;<br><span class="hljs-attribute">display</span>:table-cell;<br><span class="hljs-attribute">vertical-align</span>:middle;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>已知高度的块状元素</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.test</span>&#123;<br><span class="hljs-attribute">top</span>: <span class="hljs-number">50%</span>;<br><span class="hljs-attribute">margin-top</span>: -<span class="hljs-number">50px</span>;  <span class="hljs-comment">/* margin-top值为自身高度的一半*/</span><br><span class="hljs-attribute">position</span>:absolute;<br><span class="hljs-attribute">padding</span>:<span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li><li><p>水平垂直居中</p><ul><li>已知高度和宽度的元素</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs css">方法一：<br><span class="hljs-selector-class">.test</span>&#123;<br><span class="hljs-attribute">position</span>:absolute;<br><span class="hljs-attribute">margin</span>:auto;<br><span class="hljs-attribute">left</span>:<span class="hljs-number">0</span>;<br><span class="hljs-attribute">top</span>:<span class="hljs-number">0</span>;<br><span class="hljs-attribute">right</span>:<span class="hljs-number">0</span>;<br><span class="hljs-attribute">bottom</span>:<span class="hljs-number">0</span>;<br>&#125;<br><br>方法二：<br><span class="hljs-selector-class">.test</span>&#123;<br><span class="hljs-attribute">position</span>:absolute;<br><span class="hljs-attribute">top</span>:<span class="hljs-number">50%</span>;<br><span class="hljs-attribute">left</span>:<span class="hljs-number">50%</span>;<br><span class="hljs-attribute">margin-top</span>:-<span class="hljs-number">75px</span>;<span class="hljs-comment">/*设置margin-left、margin-top为自身高度和宽度的一半*/</span><br><span class="hljs-attribute">margin-left</span>:-<span class="hljs-number">75px</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>未知高度和宽度元素<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs css">方法一：<br><span class="hljs-selector-class">.test</span>&#123;<br><span class="hljs-attribute">position</span>:absolute:<br>top:<span class="hljs-number">50%</span><br>left:<span class="hljs-number">50%</span><br>transform:<span class="hljs-built_in">translate</span>(-<span class="hljs-number">50%</span>,-<span class="hljs-number">50%</span>)<span class="hljs-comment">/*使用css3的tranform来实现*/</span><br>&#125;<br><br>方法二：<br><span class="hljs-selector-class">.test</span>&#123;<br><span class="hljs-attribute">display</span>:flex;<br><span class="hljs-attribute">justify-content</span>:center;<br><span class="hljs-attribute">align-items</span>:center;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li></ul><h5 id="2、JS的基本数据类型"><a href="#2、JS的基本数据类型" class="headerlink" title="2、JS的基本数据类型"></a>2、JS的基本数据类型</h5><ul><li><p>undefined</p></li><li><p>null</p></li><li><p>string</p><ul><li><p>常用操作方法：</p><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>charAt( index)</td><td>返回在指定位置的字符。</td></tr><tr><td>charCodeAt(index)</td><td>返回指定的位置的字符的Unicode编码。</td></tr><tr><td>concat(str2……)</td><td>连接两个或更多字符串，并返回新的字符串。</td></tr><tr><td>fromCharCode(codeNumber)</td><td>将Unicode编码转为字符</td></tr><tr><td>indexOf(str)</td><td>返回某个指定的字符串值在字符串中首次出现的位置</td></tr><tr><td>includes(str)</td><td>查找字符串是否包含指定的字符串。</td></tr><tr><td>lastIndexof(str)</td><td>从后向钱搜索字符串，并从起始位置开始计算在字符串中出现的位置。</td></tr><tr><td>match(reg)</td><td>查找找到一个或多个正则表达式的匹配</td></tr><tr><td>repeat(Count)</td><td>复制字符串指定次数，并将它们连接在一起返回</td></tr><tr><td>replace(oriStr,repStr)</td><td>在字符串中查找匹配的子串，并替换与正则表达式匹配的子串</td></tr><tr><td>search(str)</td><td>查找与正则表达式匹配的值</td></tr><tr><td>slice(startN,endN)</td><td>提取字符串的片段，并在新的字符串中返回被提取的部分。</td></tr><tr><td>split(str)</td><td>把字符串分割为字符串数组</td></tr><tr><td>startsWith(str)</td><td>查看字符串是否以指定的字符串开头</td></tr><tr><td>substr(start,length)</td><td>从起始索引提取字符串中指定数目的字符</td></tr><tr><td>substring(start,end)</td><td>提取字符串中两个指定的索引号之间的字符</td></tr><tr><td>toLowerCase()</td><td>把字符串转换为小写</td></tr><tr><td>toUpperCase()</td><td>把字符串转换为大写</td></tr><tr><td>trim()</td><td>去除字符串两边的空白</td></tr><tr><td>toLocaleLowerCase()</td><td>根据本地主机的语言环境把字符串转换为小写</td></tr><tr><td>toLocaleUpperCase()</td><td>根据本地主机的语言环境把字符串转换为大写</td></tr><tr><td>valueOf()</td><td>返回某个字符串对象的原始值</td></tr><tr><td>toString()</td><td>返回一个字符串</td></tr></tbody></table></li></ul></li><li><p>boolean</p></li><li><p>number</p><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>isFinite</td><td>检测指定参数是否为无穷大</td></tr><tr><td>toExponential()</td><td>把对象的值转换为指数计数法</td></tr><tr><td>toFixed(num)</td><td>把数字转换为字符串，结果的小数点后有指定位数的数字</td></tr><tr><td>toPrecision()</td><td>把数字格式化为指定的长度</td></tr><tr><td>toString()</td><td>把数字转换为字符串</td></tr><tr><td>valueOf()</td><td>返回一个Number对象的基本数字值</td></tr></tbody></table><p>ES6新增Number方法</p><ul><li><p>Number.isInteger(Num):用来判断给定的参数是否为整数</p></li><li><p>Number.isSafeInteger(Num):判断传入的参数值是否是一个“安全整数”</p><p>安全整数范围为 -($2^{53}$ - 1)到 $2^{53}$ - 1 之间的整数，包含 -($2^{53}$ - 1)和 $2^{53}$ - 1。</p></li></ul></li><li><p>symbol(ES6)</p><p>ES5的对象属性名都是字符串，这容易造成属性名的冲突。比如，你使用了一个他人提供的对象，但又想为这个对象添加新的方法（mixin模式），新方法的名字就又可能与现有方法产生冲突。如果有一种机制，保证有一种机制，保证每个属性的名字都是独一无二的就好了，这样就根本上防止属性名的冲突。这就是ES6引入Symbol的原因。</p><p>加了参数之后，就易于区分。不利于区分。如果参数是一个对象，就会调用该对象的toString方法，将其转换为字符串，然后菜生产一个Symbol值。</p></li><li><p>object</p></li></ul><h5 id="3、数组有哪些方法"><a href="#3、数组有哪些方法" class="headerlink" title="3、数组有哪些方法"></a>3、数组有哪些方法</h5><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>concat(Arr1……)</td><td>连接两个或者更多的数组，并返回结果</td></tr><tr><td>copyWithin(target,start,end)</td><td>从target开始，换成后面的start到end</td></tr><tr><td>entries()</td><td>返回一个数组的迭代对象</td></tr><tr><td>every(function)</td><td>如果数组中检测到元素是否满足条件，如果一个不满足就不检测，返回false</td></tr><tr><td>fill(value,start,end)</td><td>从开始到结束用value填充</td></tr><tr><td>filter(function)</td><td>返回满足条件的全部元素，如果都不满足返回空数组</td></tr><tr><td>find(function)</td><td>可以返回第一个满足条件的元素</td></tr><tr><td>findIndex(function)</td><td>返回满足条件的第一个元素位置的下标</td></tr><tr><td>forEach(function(item,index))</td><td>方法用于调用数组的每个元素，并将该元素传给回调函数</td></tr><tr><td>from(obj)</td><td>将字符串生成一个数组</td></tr><tr><td>includes(SearchEle,start)</td><td>从指定位置开始查找需要查找的元素值，可以省略，从0 开始</td></tr><tr><td>indexOf(item,start)</td><td>返回数组中某个指定的元素的下标</td></tr><tr><td>isArray()</td><td>判断一个对象是否为数组</td></tr><tr><td>join(sep)</td><td>将数组变成字符串，然后插入sep分割</td></tr><tr><td>keys()</td><td>从数组中创建一个可迭代的对象，该对象包含数组的键（下标）</td></tr><tr><td>lastIndexOf(item,start)</td><td>指定元素子数组中出现的最后位置</td></tr><tr><td>map(function)</td><td>返回一个新数组，将数组中的元素为原始数组元素调用函数处理的值</td></tr><tr><td>pop()</td><td>删除数组的最后一个元素，并返回删除元素</td></tr><tr><td>push()</td><td>在数组末尾添加一个或多个元素，并返回新的长度</td></tr><tr><td>reduce(function（total,currentIndex）,initialValue)</td><td>接收一个函数作为累加器，数组中的每个值（从左往右开始缩减）</td></tr><tr><td>reduceRight()</td><td>和reduce一样，从右往左</td></tr><tr><td>reverse()</td><td>将数组中元素的顺序倒置</td></tr><tr><td>shift()</td><td>用于数组的第一个元素从中删除，并返回第一个元素的值</td></tr><tr><td>slice(start,end)</td><td>从start到end-1的选中元素</td></tr><tr><td>some(function(currentValue))</td><td>找到是否存在满足条件的元素，找到一个满足就返回true</td></tr><tr><td>sort(sortfuction)      sortfunciton(a,b){return a-b}小到大，return b-a 从大到小</td><td>按字母或数字的顺序按升序或降序排列</td></tr><tr><td>splice(index,howmany,item,itemX)</td><td>从index开始删除howmany个字符，可为0，插入item，itemX</td></tr><tr><td>toString()</td><td>将数组用，隔开</td></tr><tr><td>unshift(item,itemx)</td><td>向数组开头添加一个或者更多的元素，返回新的长度</td></tr><tr><td>valueOf()</td><td>返回Array对象的原始值</td></tr></tbody></table><h5 id="4、for……in和for……of的区别"><a href="#4、for……in和for……of的区别" class="headerlink" title="4、for……in和for……of的区别"></a>4、for……in和for……of的区别</h5><ul><li><p>for……in是ES5的标准，遍历key(属性名)，并且原型链上的所有属性也会被遍历。过滤原型链上的属性可以用hasOwnProperty()方法过滤。同时for……in遍历并不能保证顺序</p></li><li><p>for……of是ES6的标准，遍历value(属性值)，但是只能对数组使用，不可以对对象使用</p></li></ul><h5 id="5、数组去重"><a href="#5、数组去重" class="headerlink" title="5、数组去重"></a>5、数组去重</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> arr1 = [<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">3</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">4</span>,<span class="hljs-number">4</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">5</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">6</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">7</span>,<span class="hljs-number">7</span>]<br><span class="hljs-built_in">console</span>.log(arr1)<br><span class="hljs-keyword">var</span> arr2 = [];<br>arr1.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">val</span>)</span>&#123;<br><span class="hljs-keyword">if</span>(arr2.indexOf(val) === -<span class="hljs-number">1</span>)&#123;<br>arr2.push(val)<br>&#125;<br>&#125;)<br><span class="hljs-built_in">console</span>.log(arr2)<br><br><span class="hljs-comment">//方法2</span><br><span class="hljs-keyword">var</span> arr = [<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>]<br><span class="hljs-built_in">Array</span>.prototype.unique2 = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;  <br>            <span class="hljs-keyword">var</span> hash = [],<br>            n = [];<span class="hljs-comment">//hash 哈希表，n 为临时数组</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">this</span>.length; i ++)&#123;<br>                <span class="hljs-keyword">if</span>(!hash[<span class="hljs-built_in">this</span>[i]])&#123;<br>                    hash[<span class="hljs-built_in">this</span>[i]] = <span class="hljs-literal">true</span>;<span class="hljs-comment">//存入哈希表</span><br>                    n.push(<span class="hljs-built_in">this</span>[i]);<span class="hljs-comment">//当前元素push到数组中</span><br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">return</span> n<br>        &#125;<br>        <span class="hljs-built_in">console</span>.log(arr.unique2())<br></code></pre></td></tr></table></figure><h5 id="6、使用闭包有什么问题"><a href="#6、使用闭包有什么问题" class="headerlink" title="6、使用闭包有什么问题"></a>6、使用闭包有什么问题</h5><ul><li><p>闭包的官方解释<br>一个拥有许多变量和绑定了这些变量的环境的表达式（通常是一个函数），因而这些变量也是该表达式的一部分。</p></li><li><p>闭包的定义<br>1、闭包就是能够读取其他函数内部变量的函数；<br>2、在javascript中，只有函数内部的子函数才能读取局部变量，所以闭包可以理解成“定义在一个函数内部的函数“；<br>3、在本质上，闭包是将函数内部和函数外部连接起来的桥梁。</p></li><li><p>闭包的用途<br>1、能够读取函数内部的变量；<br>2、让这些变量的值始终保持在内存中。</p></li><li><p>闭包需要注意什么<br>1、闭包会使函数中的变量保存在内存中，内存消耗很大。所以不能滥用闭包，否则会造成网页的性能问题，在IE中可能导致内存泄漏。解决办法是，在退出函数之前，将不使用的局部变量删除。<br>2、闭包会在父函数外部，改变父函数内部变量的值。所以，如果把父函数当做对象使用，把闭包当作它的公用方法，把内部变量当作它的私有属性，这时要注意不要随便改变父函数内部变量的值。</p></li><li><p>闭包的应用场景<br>1、保护函数内部变量的安全；<br>2、通过保护变量安全实现JS私有属性和私有方法不能被外部访问；<br>3、使用闭包代替全局变量，防止变量污染。</p></li><li><p>闭包的优点<br>1、变量长期驻扎在内存中；<br>2、避免全局变量的污染；<br>3、私有成员的存在。</p></li><li><p>闭包的缺点<br>1、常驻内存中，会增大内存的使用量；</p></li></ul><h5 id="7、原生的dom操作"><a href="#7、原生的dom操作" class="headerlink" title="7、原生的dom操作"></a>7、原生的dom操作</h5><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>document.createElement(TagName)</td><td>创建新元素</td></tr><tr><td>document.getElementById(“Id”)</td><td>按照ID查询</td></tr><tr><td>element.getElementsByClassName()  ie9+</td><td>按照Class查询</td></tr><tr><td>element.querySelectorAll()         ie8</td><td>按照Class查询</td></tr><tr><td>element.getElementsByTagName()   ie6+</td><td>按照Tag查询</td></tr><tr><td>element.parentNode()</td><td>获取父节点</td></tr><tr><td>element.childNode()</td><td>获取子节点</td></tr><tr><td>parentElement.appendChild(child)</td><td>添加到最后面</td></tr><tr><td>parentElement.insertBefore(newElement,Element)</td><td>newElement添加到elemnt前面</td></tr><tr><td>element.style.css</td><td>修改css</td></tr><tr><td>element.setAttribute()</td><td></td></tr><tr><td>element.removeAtrribute()</td><td></td></tr><tr><td>element.lacssNam</td><td></td></tr></tbody></table><h5 id="8、inline-block和inline和block区别"><a href="#8、inline-block和inline和block区别" class="headerlink" title="8、inline-block和inline和block区别"></a>8、inline-block和inline和block区别</h5><ul><li><strong>inline</strong>：使元素变成行内元素（内联），拥有行内元素的特性，即</li></ul><ol><li>与其他行内元素共享一行</li><li>不能修改width、height属性，大小由内容撑开</li><li>padding属性 top、right、botto、left设置都有效；margin属性只有left、right设置有效</li></ol><ul><li><strong>block</strong>： 使元素变成块级元素，拥有块级的特性，即</li></ul><ol><li>独占一行，在不设置自己的宽度的情况下，块级元素会默认填满父级元素的宽度</li><li>可以修改width、height属性</li><li>padding、margin四个方向的值设置均有效</li></ol><ul><li><strong>inline-block</strong>： 使元素变成行内块级元素，结合了行内元素和块级元素的特性（不独占一行的块级元素），即</li></ul><ol><li>与其他行内元素共享一行</li><li>可以修改width、height属性</li><li>padding、margin四个方向的值设置均有效</li></ol><p>注意：当多个inline-block的元素写在一起时，是否换行效果不同（换行后两者中间会有间距），如img、button标签，这也是代码经过压缩后效果与开发版本不同的原因之一，解决方案是去除换行</p><h5 id="9、什么是非对称加密"><a href="#9、什么是非对称加密" class="headerlink" title="9、什么是非对称加密"></a>9、什么是非对称加密</h5><ul><li>非对称加密：加密算法需要两个密钥进行加密和解密，这两个密钥是公开密钥和私有密钥</li><li>加密和解密使用的是同一个密钥</li></ul><h5 id="10、CSS3动画"><a href="#10、CSS3动画" class="headerlink" title="10、CSS3动画"></a>10、CSS3动画</h5><p>Css3可以创建动画，它可以取代许多页面动画图像、Flash动画和JavaScript实现的效果</p><p>CSs3 @Keyframes规则</p><ul><li><p>@Keyframes的规则是创建动画：当在@Keyframes创建动画，把它绑定到一个选择器，否则动画不会有任何效果。指定至少这两个CSS3的动画属性绑定向一个选择器。</p><ul><li><p>规定动画的名称</p></li><li><p>规定动画的时长</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">div</span><br>&#123;<br><span class="hljs-attribute">animation</span>: myfirst <span class="hljs-number">5s</span><span class="hljs-comment">/*您必须定义动画的名称和动画的持续时间。如果省略的持续时间，动画将无法运行，因为默认值是0*/</span><br>-webkit-animation:myfirst <span class="hljs-number">5s</span>; <span class="hljs-comment">/*Safari与Chrome*/</span><br>    <br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li><li><p>@Keyframes规则内指定一个Css样式和动画将逐步从目前的样式更改为新的样式。</p><ul><li>Css3动画是什么？动画是使元素从一种样式逐渐变化为另一种样式的效果。</li></ul><p>您可以改变任意多的样式任意多的次数。</p><p>请用百分比来规定<code>发生的时间</code>,或用关键词“from”和”to“，等同于0%和100%</p><p>0%是动画的开始，100%是动画的完成。</p><p>为了得到最佳的浏览器支持，您应该始终定义0%和100%的选择器</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-keyword">@keyframes</span> myfirst<br>&#123;<br>0% &#123;<span class="hljs-attribute">background</span>:red; <span class="hljs-attribute">left</span>:<span class="hljs-number">0px</span>; <span class="hljs-attribute">top</span>:<span class="hljs-number">0px</span>;&#125;<br>25%&#123;<span class="hljs-attribute">background</span>:yellow; <span class="hljs-attribute">left</span>:<span class="hljs-number">200px</span>; <span class="hljs-attribute">top</span>:<span class="hljs-number">0px</span>;&#125;<br>50%&#123;<span class="hljs-attribute">background</span>:blue; <span class="hljs-attribute">left</span>:<span class="hljs-number">200px</span>; <span class="hljs-attribute">top</span>:<span class="hljs-number">200px</span>;&#125;<br>100%&#123;<span class="hljs-attribute">background</span>:green; <span class="hljs-attribute">left</span>:<span class="hljs-number">0px</span>; <span class="hljs-attribute">top</span>:<span class="hljs-number">0px</span>;&#125;<br>&#125;<br><br><span class="hljs-keyword">@-webkit-keyframes</span> myfirst /*Safari与Chrome*/<br>&#123;<br>0% &#123;<span class="hljs-attribute">background</span>:red; <span class="hljs-attribute">left</span>:<span class="hljs-number">0px</span>; <span class="hljs-attribute">top</span>:<span class="hljs-number">0px</span>;&#125;<br>25%&#123;<span class="hljs-attribute">background</span>:yellow; <span class="hljs-attribute">left</span>:<span class="hljs-number">200px</span>; <span class="hljs-attribute">top</span>:<span class="hljs-number">0px</span>;&#125;<br>50%&#123;<span class="hljs-attribute">background</span>:blue; <span class="hljs-attribute">left</span>:<span class="hljs-number">200px</span>; <span class="hljs-attribute">top</span>:<span class="hljs-number">200px</span>;&#125;<br>100%&#123;<span class="hljs-attribute">background</span>:green; <span class="hljs-attribute">left</span>:<span class="hljs-number">0px</span>; <span class="hljs-attribute">top</span>:<span class="hljs-number">0px</span>;&#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><p>@keyframes规则和所有动画属性</p><table><thead><tr><th>属性</th><th>描述</th></tr></thead><tbody><tr><td>@keyframes</td><td>规定动画</td></tr><tr><td>animation</td><td>所有动画属性的简写属性。</td></tr><tr><td>animation-name</td><td>规定@keyframes动画的名称</td></tr><tr><td>animation-duration</td><td>规定动画完成一个周期所花费的秒或毫秒</td></tr><tr><td>animation-timing-function</td><td>规定动画的速度曲线。默认是”ease“</td></tr><tr><td>animation-fill-mode</td><td>规定当动画不播放时（当动画完成时，或当动画有一个延迟未开始播放时）元素的样式</td></tr><tr><td>animation-delay</td><td>规定动画何时开始，默认是0。</td></tr><tr><td>animation-iteration-count</td><td>规定动画被播放的次数。默认是1。</td></tr><tr><td>animation-direction</td><td>规定动画是否在下一周期逆向地播放。默认是”normal“。</td></tr><tr><td>animation-play-state</td><td>规定动画是否正在运行或暂停。默认是”running“</td></tr></tbody></table><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">div</span><br>&#123;<br>    <span class="hljs-attribute">animation-name</span>: myfirst;<br>    <span class="hljs-attribute">animation-duration</span>: <span class="hljs-number">5s</span>;<br>    <span class="hljs-attribute">animation-timing-function</span>: linear;<br>    <span class="hljs-attribute">animation-delay</span>: <span class="hljs-number">2s</span>;<br>    <span class="hljs-attribute">animation-iteration-count</span>: infinite;<br>    <span class="hljs-attribute">animation-direction</span>: alternate;<br>    <span class="hljs-attribute">animation-play-state</span>: running;<br>    <span class="hljs-comment">/* Safari 与 Chrome: */</span><br>    <span class="hljs-attribute">-webkit-animation-name</span>: myfirst;<br>    <span class="hljs-attribute">-webkit-animation-duration</span>: <span class="hljs-number">5s</span>;<br>    <span class="hljs-attribute">-webkit-animation-timing-function</span>: linear;<br>    <span class="hljs-attribute">-webkit-animation-delay</span>: <span class="hljs-number">2s</span>;<br>    <span class="hljs-attribute">-webkit-animation-iteration-count</span>: infinite;<br>    <span class="hljs-attribute">-webkit-animation-direction</span>: alternate;<br>    <span class="hljs-attribute">-webkit-animation-play-state</span>: running;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="12、transition属性"><a href="#12、transition属性" class="headerlink" title="12、transition属性"></a>12、transition属性</h5><p>transition属性设置元素当过渡效果，四个简写属性为：</p><ul><li>transition-property      指定Css属性的name,transition效果</li><li>transition-duration       transition效果需要指定多少秒或毫秒才能完成</li><li>transition-timing-function       指定transition效果的转速曲线</li><li>transition-delay             定义transition效果开始的时候</li></ul>]]></content>
    
    
    <categories>
      
      <category>javascript、css</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>西安腾讯前端一面试总结</title>
    <link href="/2020/12/25/%E8%85%BE%E8%AE%AF%E8%A5%BF%E5%AE%89%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93%E4%B8%80%E9%9D%A2/"/>
    <url>/2020/12/25/%E8%85%BE%E8%AE%AF%E8%A5%BF%E5%AE%89%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93%E4%B8%80%E9%9D%A2/</url>
    
    <content type="html"><![CDATA[<a id="more"></a><p>事发突然很难受，刚睡醒，就接到腾讯面试官的电话，之前一直在想面试会问啥，其实这次面试并不能，出乎意料的简单，但是错失了机会。基础问题，被说安全基础差，踏实学习吧。之前一直浮躁，从没用认识思考基础知识，而且这是第一次面试，超级紧张。</p><p>现在回顾复盘一下问了一些什么，附带应该有的回答</p><h5 id="1、你什么时候开始学习前端的，项目经历"><a href="#1、你什么时候开始学习前端的，项目经历" class="headerlink" title="1、你什么时候开始学习前端的，项目经历"></a>1、你什么时候开始学习前端的，项目经历</h5><h5 id="2、你从输出一个url到看到页面经过的过程"><a href="#2、你从输出一个url到看到页面经过的过程" class="headerlink" title="2、你从输出一个url到看到页面经过的过程"></a>2、你从输出一个url到看到页面经过的过程</h5><ul><li>输入网址：浏览器在输入网址的时候，就可能只能的匹配url</li><li>DNS解析：详细见4问（回答的不具体，然后展开又问了一下）</li><li>建立TCP连接</li><li>向客户端发起HTTP请求</li><li>服务器处理请求</li><li>服务器响应</li><li>浏览器展示HTML</li></ul><h5 id="3、页面渲染的过程"><a href="#3、页面渲染的过程" class="headerlink" title="3、页面渲染的过程"></a>3、页面渲染的过程</h5><ul><li><p>根据html文件构建DOM树和CSSOM树。构建DOM树期间，如果遇到JS,阻塞DOM树及CSSOM树的构建，优先加载JS文件，加载完毕后，继续再构建DOM树及CSSOM树</p></li><li><p>构建渲染树</p></li><li><p>页面的重绘与重排。页面渲染完成后，若JS操作了DOM节点，根据JS对DOM操作动作的大小，浏览器会对页面进行重绘和重排</p><p>（<code>重排</code>：由于布局的改变引起的页面重新渲染     <code>重绘</code>：由于样式的改变引起的页面重新渲染）</p></li></ul><h5 id="4、DNS具体解析的过程"><a href="#4、DNS具体解析的过程" class="headerlink" title="4、DNS具体解析的过程"></a>4、DNS具体解析的过程</h5><ol><li><p>首先会在本机的hosts的文件里寻找，如果没用就向本地DNS服务器进行递归查询</p></li><li><p>本地服务器采用迭代查询。它向一个根域名服务器查询。</p></li><li><p>根域名服务器告诉本地服务器，下一次查询的顶级域名服务器的ip地址</p></li><li><p>本地域名服务器向顶级域名服务器查询</p></li><li><p>顶级域名服务器告诉本地域名服务器下一把的权限服务器的ip地址</p></li><li><p>本地域名服务器向权限服务器进行查询。</p></li><li><p>权限服务器告诉本地服务器所查的主机的ip地址</p></li><li><p>本地域名服务器把查询结果告诉主机</p><p>整个过程共用到8个UDP报文</p></li></ol><h5 id="5、三次握手、四次挥手的细节"><a href="#5、三次握手、四次挥手的细节" class="headerlink" title="5、三次握手、四次挥手的细节"></a>5、三次握手、四次挥手的细节</h5><ul><li>三次握手<ol><li>客户端发送syn包（seq=x）到服务器，并进入SYN_SEND状态，等待服务器确认</li><li>服务器收到syn包，必须确认客户的SYN（ack=x+1），同时自己页发送一个SYN包（seq=y）,即SYN+ACK包，此时服务器进入SYN_RECV状态</li><li>客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack=y+1)，此包发送完毕，客户端和服务器进入Established状态</li></ol></li><li>四次挥手<ol><li>主动关闭方发送一个FIN，用来关闭主动方到被动关闭方的数据传送，也就是主动关闭方告诉被动关闭方：我已经不会再给你发送数据了（当然，再FIN包之前发送出去的数据，如果没用收到对应的ack确认报文，主动关闭方依然会重发这些数据），但是此时主动关闭方还可以接受数据</li><li>被动关闭方收到FIN包后，发送一个ACK给对方，确认序号为收到序号+1（与SYN相同，一个FIN占用一个序号）</li><li>被动关闭方发送一个FIN,用来关闭被动关闭方到主动关闭方的数据传送，也就是告诉主动关闭方，我的数据页发送完了，不会再给你发送数据了。</li><li>主动关闭方收到FIN后，发送一个ACK给被动关闭方，确认序号为收到序号+！，至此，完成四次挥手</li></ol></li></ul><p>既然都到这里了，我们把传输过程中的问题页一并复习了吧</p><ul><li>超时重传：超时重传机制用来保障TCP传输的可靠性。每次发送数据包时，发送的数据宝都有seq号，接受端收到数据后，会回复ack进行确认，表示某一seq号数据已经收到。发送方在发送了某个seq包后，等待一段时间，如果没有收到对应的ack回复，就会认为报文丢失，会重传这个数据包。</li><li>快速重传：接受数据一方发现有数据包丢失掉了，就会发送ack报文告诉发送方重传丢失的报文。如果发送端连续收到标号相同的ack包，则会触发发送端的快速重传。（超时重传就类似于发送端傻等超时，而快速重传就类似接受端主动告诉发送端，没收到，而触发超时重传）</li><li>流量控制：这里主要说TCP的滑动窗口流量控制。TCP头有个字段叫WIndow，由叫Advertised-Window,这个字段是接受端告诉发送端自己还有多少缓冲区可以接受数据。于是发送端就可以根据这个接受端的处理能力来发送数据，而不会导致接收端处理不过来。滑动窗口可以提高TCP传输效率的一种机制。</li><li>拥塞控制：滑动窗口用来做流量控制。流量控制只会关注发送端和接受端自身的状况，而没有考虑整个网络的通信情况。拥塞控制，则是基于整个网络来考虑的。考虑一下这样的场景：某个时刻网络上的延时突然增加，那么，TCP对这个事做出的应对只有重传数据，但是，重传会导致网络负担更重，于是会导致更大的延迟以及更多丢包，于是，这种情况会进入恶心循环被不断地放大。试想一下，如果一个网络内有成千上万的TCP连接都这样行事，会马上形成“网络风暴”,TCP这个协议就会拖垮整个网络。为此TCP就引入了拥塞控制策略。拥塞策略算法主要包括：慢启动，拥塞避免，快重传，快速恢复。<ul><li>慢开始：刚开始发送方维护一个拥塞窗口，大小等于发送窗口，通过出现了超时来判断网络出现拥塞。慢开始的思路是一开始发送方发送一个字节，在收到接受方的确认，然后发送的字节数量增大一倍（就是以指数增长的速率），逐步增大拥塞窗口，当拥塞窗口到达满开始门限，停止慢开始算法，开始拥塞避免算法。</li><li>拥塞避免：拥塞避免的增长速率变成线性增长，也就是每经过一个往返时间RTT就把发送方的拥塞窗口加1</li><li>快重传：上述两个算法使得网络传输速率一直增大，直至出现<code>超时</code>，这时候需要将<code>拥塞窗口</code>重新调整到1字节开始，使用<code>慢开始算法</code>，同时需要将<code>慢开始门限</code>调整为<code>超时</code>时的<code>拥塞窗口</code>大小的<code>一半</code>,继续执行慢开始算法、拥塞避免算法。</li><li>快恢复：如果收到了连续3个对同一报文的重复确认，此时可能发生了报文缺失，发送方不执行慢开始算法，直接使用<code>快重传算法</code>，立即发送缺失的报文段。同时执行快恢复算法，将门限值调整为此时拥塞窗口的一半，并执行拥塞避免算法</li></ul></li></ul><h5 id="6、前端安全的问题有哪些，具体防范措施"><a href="#6、前端安全的问题有哪些，具体防范措施" class="headerlink" title="6、前端安全的问题有哪些，具体防范措施"></a>6、前端安全的问题有哪些，具体防范措施</h5><ul><li><p>跨站脚本攻击（XSS攻击）：跨站脚本攻击，指的是恶意攻击者往Web页面里插入恶意html代码，当用户浏览该页之时，嵌入其中Web里面的html代码会被执行，从而达到用户的特殊目的。</p><p><code>预防措施</code>:输入过滤，对用户提交的数据进行有效性验证。</p><ul><li><p>过滤一些些常见的敏感字符，例如：&lt; &gt; ‘ “ &amp; # \ javascript expression ；</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">.replace(<span class="hljs-regexp">/src=&quot;javascript:/g</span>, <span class="hljs-string">&#x27;src=&quot;&#x27;</span>).replace(<span class="hljs-regexp">/src=&#x27;javascript:/g</span>, <span class="hljs-string">&#x27;src=\&#x27;&#x27;</span>)<br></code></pre></td></tr></table></figure></li><li><p>过滤或移除特殊的Html标签， 例如: <code>&lt;script&gt;</code>, <code>&lt;iframe&gt;</code> </p></li><li><p>过滤JavaScript 事件的标签，例如 “onclick=”, “onfocus”</p></li><li><p>通过http-only Cooke禁止读取某些敏感Cookies</p></li><li><p>在关键业务部分增加验证码，防止脚本冒充用户提交危险操作</p></li></ul><p>输出编码：当需要将一个字符串输出到Web网页时，同时又不确定这个字符串中是否包括XSS特殊字符（如&lt; &gt; &amp;‘”等），为了确保输出内容的完整性和正确性，可以使用编码（HTMLEncode）进行处理。</p></li><li><p>SQL语句注入</p></li><li><p>跨站请求伪造（CSRF攻击）</p><p>防范措施：</p><p>Token，就是令牌，最大的特点就是随机性，不可预测。一般黑客或软件无法猜测出来。</p><p>那么，Token有什么作用？又是什么原理呢？</p><p>Token一般用在两个地方:</p><ul><li>1)防止表单重复提交、</li><li>2)anti csrf攻击（跨站点请求伪造）。</li></ul><p>两者在原理上都是通过session token来实现的。当客户端请求页面时，服务器会生成一个随机数Token，并且将Token放置到session当中，然后将Token发给客户端（一般通过构造hidden表单）。下次客户端提交请求时，Token会随着表单一起提交到服务器端。<br>然后，如果应用于“anti csrf攻击”，则服务器端会对Token值进行验证，判断是否和session中的Token值相等，若相等，则可以证明请求有效，不是伪造的。<br>不过，如果应用于“防止表单重复提交”，服务器端第一次验证相同过后，会将session中的Token值更新下，若用户重复提交，第二次的验证判断将失败，因为用户提交的表单中的Token没变，但服务器端session中Token已经改变了。</p><h2 id="SameSite-属性"><a href="#SameSite-属性" class="headerlink" title="SameSite 属性"></a>SameSite 属性</h2><p>Cookie 的<code>SameSite</code>属性用来限制第三方 Cookie，从而减少安全风险。</p><p>它可以设置三个值。</p><blockquote><ul><li>Strict</li><li>Lax</li><li>None</li></ul></blockquote><h3 id="2-1-Strict"><a href="#2-1-Strict" class="headerlink" title="2.1 Strict"></a>2.1 Strict</h3><p><code>Strict</code>最为严格，完全禁止第三方 Cookie，跨站点时，任何情况下都不会发送 Cookie。换言之，只有当前网页的 URL 与请求目标一致，才会带上 Cookie。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">Set-Cookie: CookieName=CookieValue; SameSite=Strict;<br></code></pre></td></tr></table></figure></blockquote><p>这个规则过于严格，可能造成非常不好的用户体验。比如，当前网页有一个 GitHub 链接，用户点击跳转就不会带有 GitHub 的 Cookie，跳转过去总是未登陆状态。</p><h3 id="2-2-Lax"><a href="#2-2-Lax" class="headerlink" title="2.2 Lax"></a>2.2 Lax</h3><p><code>Lax</code>规则稍稍放宽，大多数情况也是不发送第三方 Cookie，但是导航到目标网址的 Get 请求除外。</p><blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs markup">Set-Cookie: CookieName&#x3D;CookieValue; SameSite&#x3D;Lax;<br></code></pre></td></tr></table></figure></blockquote><p>导航到目标网址的 GET 请求，只包括三种情况：链接，预加载请求，GET 表单。详见下表。</p><table><thead><tr><th align="left">请求类型</th><th align="center">示例</th><th align="right">正常情况</th><th align="left">Lax</th></tr></thead><tbody><tr><td align="left">链接</td><td align="center"><code>&lt;a href=&quot;...&quot;&gt;&lt;/a&gt;</code></td><td align="right">发送 Cookie</td><td align="left">发送 Cookie</td></tr><tr><td align="left">预加载</td><td align="center"><code>&lt;link rel=&quot;prerender&quot; href=&quot;...&quot;/&gt;</code></td><td align="right">发送 Cookie</td><td align="left">发送 Cookie</td></tr><tr><td align="left">GET 表单</td><td align="center"><code>&lt;form method=&quot;GET&quot; action=&quot;...&quot;&gt;</code></td><td align="right">发送 Cookie</td><td align="left">发送 Cookie</td></tr><tr><td align="left">POST 表单</td><td align="center"><code>&lt;form method=&quot;POST&quot; action=&quot;...&quot;&gt;</code></td><td align="right">发送 Cookie</td><td align="left">不发送</td></tr><tr><td align="left">iframe</td><td align="center"><code>&lt;iframe src=&quot;...&quot;&gt;&lt;/iframe&gt;</code></td><td align="right">发送 Cookie</td><td align="left">不发送</td></tr><tr><td align="left">AJAX</td><td align="center"><code>$.get(&quot;...&quot;)</code></td><td align="right">发送 Cookie</td><td align="left">不发送</td></tr><tr><td align="left">Image</td><td align="center"><code>&lt;img src=&quot;...&quot;&gt;</code></td><td align="right">发送 Cookie</td><td align="left">不发送</td></tr></tbody></table><p>设置了<code>Strict</code>或<code>Lax</code>以后，基本就杜绝了 CSRF 攻击。当然，前提是用户浏览器支持 SameSite 属性。</p><h3 id="2-3-None"><a href="#2-3-None" class="headerlink" title="2.3 None"></a>2.3 None</h3><p>Chrome 计划将<code>Lax</code>变为默认设置。这时，网站可以选择显式关闭<code>SameSite</code>属性，将其设为<code>None</code>。不过，前提是必须同时设置<code>Secure</code>属性（Cookie 只能通过 HTTPS 协议发送），否则无效。</p><p>下面的设置无效。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">Set-Cookie: widget_session=abc123; SameSite=None<br></code></pre></td></tr></table></figure></blockquote><p>下面的设置有效。</p><blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">Set-Cookie: widget_session=abc123; SameSite=None; Secure<br></code></pre></td></tr></table></figure></blockquote></li><li><p>文件上传</p><p>xss参考链接：<a href="https://www.cnblogs.com/for-easy-fast/articles/12956062.html">https://www.cnblogs.com/for-easy-fast/articles/12956062.html</a></p></li></ul><h5 id="7、XSS具体是如何发动攻击的"><a href="#7、XSS具体是如何发动攻击的" class="headerlink" title="7、XSS具体是如何发动攻击的"></a>7、XSS具体是如何发动攻击的</h5><ul><li><p>分类：XSS分为反射型、存储型、及DOM-based型，其中反射型和DOM-based型可以归为非持久XSS攻击类型。存储型可以归类为持久性XSS攻击</p><ul><li><p>反射型XSS:一般指攻击者通过特定的方式来诱惑受害者去访问一个包含恶意代码的URL。当受害者点击恶意链接url的时候，恶意代码会直接在受害者的主机上的浏览器执行。</p><p>那么为什么要叫反射型呢？因为这种攻击方式的注入代码是从目标服务器通过错误信息，搜索结果等方式反射回来的，而为什么又叫非持久性XSS呢？因为这种攻击方式只有一次性。</p><p>攻击步骤如下</p><ol><li>攻击者在url后面的参数中加入恶意攻击代码</li><li>当用户打开带有恶意代码的URL的时候，网址服务器将恶意代码从URL中取出，拼接在html中并返回给浏览器端</li><li>用户浏览器接受到响应后执行解析，其中的恶意代码也会被执行到。</li><li>攻击者通过恶意代码来窃取到用户数据并发送到攻击者的网址。攻击者会获取到比如cookie等信息，然后使用该信息来冒充合法用户的行为，调用目标网站接口执行攻击等操作。</li></ol></li><li><p>存储型XSS:如果有一个博客网站，攻击者在上面发布一篇文章，如果不对文章进行任何处理就存入数据库，那么下次，其他用户访问该文章的时候，服务器就会读取然后响应给客户端，那么浏览器就会执行该段脚本，然后攻击者就会获取用户的cookie，然后会把cookie发送到攻击者的服务器上了。</p><p>攻击步骤如下:</p><ol><li>攻击者将恶意代码提交到目标网站数据库中</li><li>用户打开目标网站时，网站服务器将恶意代码从数据库中取出，然后拼接成html中返回给浏览器。</li><li>用户浏览器接受到响应后解析执行，其中恶意代码也会被执行。</li><li>那么恶意执行代码后，就能获取到用户数据，比如上面的cookie等信息，那么把该cookie发送到攻击者网站中，那么攻击者拿到该cookie然后会冒充该用户的行为，调用目标网站接口等违法操作。</li></ol><p>防范措施：后端需要对提交的数据进行过滤</p><p>前端页可以做一下处理方式，比如对script标签，将特殊字符替换成HTML编码等。</p></li><li><p>DOM-based型xss:我们客户端的js可以对页面dom节点进行动态的操作，比如插入、修改页面的内容。比如说客户端从URL中提取数据并且在本地执行、如果用户在客户端输入的数据包含了恶意的js脚本的话，但是这些脚本又没有做任何过滤处理的话，那么我们的应用程序就又可能收到DOM-based XSS的攻击。</p><p>攻击步骤如下：</p><ol><li>攻击者构造出特殊的URL、在其中可能包含恶意代码。</li><li>用户打开带有恶意的代码的URL</li><li>用户浏览器收到响应后解析执行。前端使用js取出url的恶意代码并执行。</li><li>执行时，，恶意代码窃取用户数据并发送到攻击者的网站中，那么攻击者网站拿着这些数据去冒充用户的行为操作。调用目标网站接口执行攻击者的一些操作。</li></ol><p>一般又如下的DOM操作</p><ul><li><p>document.write</p></li><li><p>innerHTML</p></li><li><p>location、location.href、location.replace、iframe.src、document.referer、window.name</p><p>因此我们需要对HTML进行编码，对JS进行编码来防止这些问题产生。</p></li></ul><p>参考链接：<a href="https://www.cnblogs.com/tugenhua0707/p/10909284.html#_labelTop">https://www.cnblogs.com/tugenhua0707/p/10909284.html#_labelTop</a></p><p><a href="https://www.cnblogs.com/mmy67/p/9923422.html">https://www.cnblogs.com/mmy67/p/9923422.html</a></p></li></ul></li></ul><h5 id="8、有哪些页面优化的手段，从框架啊、代码的角度说"><a href="#8、有哪些页面优化的手段，从框架啊、代码的角度说" class="headerlink" title="8、有哪些页面优化的手段，从框架啊、代码的角度说"></a>8、有哪些页面优化的手段，从框架啊、代码的角度说</h5><ul><li><p>资源压缩，减少http请求：合并css、合并javascript、合并图片（精灵图片的使用：例如微博上有很多的小图标，浏览器上的图片很多都是从服务器上获取的，如果分别存放在服务器上，就会增加很多的请求），同时使用Gzip压缩可以达到比较好的效果，但是如果服务器的资源不足的时候，但是通信带宽良好需要权衡考虑。</p></li><li><p>使用CDN:在浏览器第一次打开页面时，缓存是起不了作用的。这时候，CDN就很有用（CDN的本质仍然是一个缓存，而且将数据缓存在离用户最近的地方，使用户以最快的速度获取数据，就是所谓的网络访问第一跳，由于CDN部署在网络运营商的机房，这些运营商又是终端用户的网络服务提供商，因此用户请求路由的第一跳就到达了CDN服务器）</p></li><li><p>图片较多的页面可以使用lazyLoad等技术优化</p></li><li><p>非核心代码异步加载：不用立即使用的js代码可以采用异步加载</p></li><li><p>利用浏览器缓存:Css、javascript、logo、图标这些静态资源文件更新的频率都比较低，而且这些文件几乎每次http请求都需要的，如果将这些文件缓存在浏览器中，可以极好的改善性能。通过设置http头中的<code>cache-control</code>和<code>expires</code>属性，可设定浏览器缓存，缓存时间可以是几天，甚至是几个月。</p><p>但是某些时候，静态资源文件变化需要及时应用到客户端浏览器，这种情况，可以通过改变文件名实现，即更新javascript文件并不是更新javascript文件内容，而是生成一个新的JS文件并更新HTML文件中的引用。</p><p>使用浏览器缓存策略的网站在更新静态资源时，应该采用逐量更新的方法，比如需要更新1-个图标文件，不应当把10个文件一次全部更新，而是应该一个文件一个文件逐步更新，并有一定的间隔时间，以避免用户浏览器突然大量缓存失效，集中更新缓存，造成服务器负载骤增、网络堵塞的情况。</p></li><li><p>DNS预解析</p></li><li><p>Css尽量放在上方，javascript尽量放在下方：浏览器在下载完全部Css之后，才会对整个页面进行渲染，因此最好的做法是将Css放在页面的最上方（<code>&lt;head&gt;</code>）如果将Css放在Body中，则浏览器可能还未下载和解析到Css就已经开始渲染页面了，这就导致页面可能会从无Css状态跳转到有Css状态，用户体验会比较差。相反，JavaScript在浏览器加载javascript之后立即执行，有可能会阻塞整个页面，造成页面显示缓慢，因此javascript最好放在页面最下面。如果页面解析的时候就需要用到javascript，这时放在下面就不是很合适。</p></li><li><p>减少cookie传输：太大的cookie会严重影响数据传输，因此哪些数据需要写入cookie需要慎重考虑，尽量减少cookie中 传输量。另一方面。对于某些静态资源的访问，发送cookie没有意义，可以考虑静态资源使用独立域名去访问，避免请求静态资源时发送cookie，减少cookie传输次数</p></li><li><p>Javascript代码优化</p><ul><li><p>Dom：</p><ol><li>HTMl Collection（HTMl收集器，返回的是一个数组内容信息）在脚本中document.images、document.forms、getElementsByTagName()返回的都是HTMLCollection类型的集合，在平时使用的时候大多将它作为数组来使用，因为它有length属性，也可以使用索引来访问每个元素。不过在访问性能上比数组差很多，原因是这个集合并不是一个静态的结果，它表示的仅仅是一个特定的查询，每次访问该集合时都会重新执行这个查询从而更新查询的结果。所谓的<code>访问集合</code>包括读取集合的length属性、访问集合里的元素。 因此，当你需要遍历HEML Collection的时候，尽量将它转为数组再去访问，以提高性能。即使不转变成为数组，也尽可能的少访问它，例如在遍历的时候可以将length属性、成员保存到局部变量后再使用局部变量。</li><li>DOM操作还需要考虑浏览器的回流和重绘，应位哪都需要消耗资源的。</li></ol></li><li><p>慎用with</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-title">with</span>(<span class="hljs-params">obj</span>)</span>&#123;<br>p = <span class="hljs-number">1</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>代码块的行为实际上的修改了代码块中的执行环境，将obj放在了其作用域链的最前端，在with代码块中访问非局部变量是都是先从obj上开始查找，如果没有再依次按作用链域向上查找，因此使用with相当于增加了作用域链长度。而每次查找作用域链都是要消耗时间的，过长的作用域链会导致查找性能下降。因此，除非你能肯定在with代码中只访问obj中的属性，否则慎用with，替代的可以使用局部变量来缓存需要访问的属性。</p></li><li><p>避免使用eval和Function</p><p>每次eval或Function构造函数作用于字符串表示的源代码时，脚本引擎都需要将源代码转换成可执行代码。这是很消耗资源的操——通常比简单的函数调用慢100倍以上。</p><p>eval函数效率特别低，由于事先无法知晓上下文，因此只能有浏览器在运行时解释代码。这对性能影响很大。Function构造函数也比eval略好，因为使用此代码不会影响周围代码，但是速度仍然很慢，此外，使用eval和Function也不利于Javascript压缩攻击执行压缩。</p></li><li><p>减少作用域查找</p><p>在循环的时候尤其需要注意的问题。如果在循环中需要访问非本作用域下的变量时请在遍历之前用局部变量缓存该变量，并在遍历结束后再重写那个变量，这一点对全局变量尤其重要，因为全局变量处于作用域链的最顶端，访问时的查找次数是最多的。此外，要减少作用域链查找还应该减少闭包的使用。</p></li><li><p>字符串拼接，使用<code>+</code>号来拼接字符串的效率比较低，因此相比较之下可以使用数组的join方法，将需要拼接的字符串放在数组中最后调用join方法得到结果。但是数组也有一定的开销，因此需要拼接的字符串较多的时候可以考虑用此方法。</p></li></ul></li><li><p>反向代理服务器：传统代理服务器位于浏览器以测，代理浏览器将http请求发送到互联网上，而反向代理服务器位于网站机房以测，代理网站web服务器接收http请求。和传统代理服务器可以保护浏览器安全一样，反向代理服务器也具有保护网站安全的作用，来自互联网的请求必须经过代理服务器，相当于web服务器和可能的网络攻击之间建立了一个屏障。除了安全功能代理服务器也可以通过配置缓存功能加速web请求。当用户第一次访问静态内容的时候，静态内容就被缓存在反向代理服务器上，这样当用户访问该静态能让的时候，就可以直接从反向代理服务器返回，加速web请求速度，减轻web服务器负载压力。事实上，有些网站会把动态内容也缓存在代理服务器上，比如维基百科和一些博客论坛网站，把热门词条、帖子、博客缓存在反向代理服务器上加速用户访问速度，当这些动态内容有变化的时，通过内部通知反向代理缓存失效，反向代理会重新加载最新的动态内容再次缓存起来。</p><p>此外，反向代理也可以实现负载均衡的功能，而通过负载均衡构建的应用集群可以提高系统总体处理能力，进而改善网站高并发情况下的性能。</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>面经</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面经</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Interview Summary</title>
    <link href="/2020/12/13/Css3%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/"/>
    <url>/2020/12/13/Css3%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<p>Css问题汇总</p><a id="more"></a><h5 id="1、Css的选择器"><a href="#1、Css的选择器" class="headerlink" title="1、Css的选择器"></a>1、Css的选择器</h5><table><thead><tr><th>选择器</th><th>用法</th></tr></thead><tbody><tr><td>id选择器</td><td>#myid</td></tr><tr><td>类选择器</td><td>.myclassname</td></tr><tr><td>标签选择器</td><td>div,h1,p</td></tr><tr><td>相邻选择器</td><td>h1+p</td></tr><tr><td>子选择器</td><td>ul &gt; li</td></tr><tr><td>后代选择器</td><td>li a</td></tr><tr><td>通配符选择器</td><td>*</td></tr><tr><td>属性选择器</td><td>a[rel=”external”]</td></tr><tr><td>伪类选择器</td><td>a:hover, li:nth-child</td></tr></tbody></table><h5 id="2、样式层叠次序"><a href="#2、样式层叠次序" class="headerlink" title="2、样式层叠次序"></a>2、样式层叠次序</h5><p>当同一个 HTML 元素定义了多个样式时，应该使用哪个样式？</p><p>一般而言，所有的样式会根据下面的规则层叠于一个新的虚拟样式表中，其中数字 4 拥有最高的优先权。</p><ol><li>浏览器缺省设置</li><li>外部样式表（在<code>&lt;head&gt;和&lt;/head&gt;之间的link中</code>）</li><li>内部样式表（位于 <code>&lt;head&gt;</code> 标签内部）</li><li>内联样式（在 HTML 元素内部）</li></ol><p>因此，内联样式（在 HTML 元素内部）拥有最高的优先权，这意味着它将优先于以下的样式声明： 标签中的样式声明，外部样式表中的样式声明，或者浏览器中的样式声明（缺省值）。</p><p>注： CS 选择器有修饰上的优先级，即：</p><p>内联选择器 &gt; id选择器 &gt; 类选择器 &gt; 标签选择器</p><h5 id="3、多重样式优先级顺序"><a href="#3、多重样式优先级顺序" class="headerlink" title="3、多重样式优先级顺序"></a>3、多重样式优先级顺序</h5><p>下列是一份优先级逐级增加的选择器列表，其中数字 7 拥有最高的优先权：</p><ol><li>通用选择器（*）</li><li>元素(类型)选择器</li><li>类选择器</li><li>属性选择器</li><li>伪类</li><li>ID 选择器</li><li>内联样式</li></ol><h5 id="4、权重计算"><a href="#4、权重计算" class="headerlink" title="4、权重计算:"></a>4、权重计算:</h5><ul><li>内联样式表的权值最高 1000</li><li>ID 选择器的权值为 100</li><li>Class 类选择器的权值为 10</li><li>HTML 标签选择器的权值为 1</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-id">#redP</span> <span class="hljs-selector-tag">p</span> &#123;   <br><br><span class="hljs-comment">/* 权值 = 100+1=101 */</span>    <br><br><span class="hljs-attribute">color</span>:<span class="hljs-number">#F00</span>;  <span class="hljs-comment">/* 红色 */</span>   <br><br>&#125;    <br><br><span class="hljs-selector-id">#redP</span> <span class="hljs-selector-class">.red</span> <span class="hljs-selector-tag">em</span> &#123;    <br><br><span class="hljs-comment">/* 权值 = 100+10+1=111 */</span>    <br><br><span class="hljs-attribute">color</span>:<span class="hljs-number">#00F</span>; <span class="hljs-comment">/* 蓝色 */</span>   <br><br>&#125;   <br><br><span class="hljs-selector-id">#redP</span> <span class="hljs-selector-tag">p</span> <span class="hljs-selector-tag">span</span> <span class="hljs-selector-tag">em</span> &#123;   <br><br><span class="hljs-comment">/* 权值 = 100+1+1+1=103 */</span><br><br><span class="hljs-attribute">color</span>:<span class="hljs-number">#FF0</span>;<span class="hljs-comment">/*黄色*/</span>   <br><br>&#125;    <br></code></pre></td></tr></table></figure><h3 id="CSS-优先级法则："><a href="#CSS-优先级法则：" class="headerlink" title="CSS 优先级法则："></a>CSS 优先级法则：</h3><ul><li> A 选择器都有一个权值，权值越大越优先；</li><li> B 当权值相等时，后出现的样式表设置要优于先出现的样式表设置；</li><li> C 创作者的规则高于浏览者：即网页编写者设置的 CSS 样式的优先权高于浏览器所设置的样式；</li><li> D 继承的 CSS 样式不如后来指定的 CSS 样式；</li><li> E 在同一组属性设置中标有 “!important” 规则的优先级最大；</li></ul><h5 id="5、https-www-w3cschool-cn-css-css-outline-html"><a href="#5、https-www-w3cschool-cn-css-css-outline-html" class="headerlink" title="5、https://www.w3cschool.cn/css/css-outline.html"></a>5、<a href="https://www.w3cschool.cn/css/css-outline.html">https://www.w3cschool.cn/css/css-outline.html</a></h5>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>css</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Interview Summary</title>
    <link href="/2020/12/12/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93(%E4%BA%8C)/"/>
    <url>/2020/12/12/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93(%E4%BA%8C)/</url>
    
    <content type="html"><![CDATA[<p>前端面试总结</p><a id="more"></a><h5 id="1、如何看待前端框架选型"><a href="#1、如何看待前端框架选型" class="headerlink" title="1、如何看待前端框架选型"></a>1、如何看待前端框架选型</h5><p><a href="https://blog.csdn.net/qq_42774426/article/details/86600913">https://blog.csdn.net/qq_42774426/article/details/86600913</a></p><h5 id="2、vue如何实现双向绑定"><a href="#2、vue如何实现双向绑定" class="headerlink" title="2、vue如何实现双向绑定"></a>2、vue如何实现双向绑定</h5><p>vue.js 是采用数据劫持结合发布者-订阅者模式的方式，通过new Proxy()来劫持各个属性的setter，getter，在数据变动时发布消息给订阅者，触发相应的监听回调。</p><p>Vue 3.0与Vue 2.0的区别仅是数据劫持的方式由Object.defineProperty更改为Proxy代理，其他代码不变。</p><h5 id="3、react虚拟DOM是什么"><a href="#3、react虚拟DOM是什么" class="headerlink" title="3、react虚拟DOM是什么"></a>3、react虚拟DOM是什么</h5><p>当我们更新了<code>state</code>中的值的时候，React会去调用<code>render()</code>方法来重新渲染整个组件的UI，但是如果我们真的去操作这么大量的DOM，显然性能是堪忧的。所以React实现了一个<code>Virtual DOM</code>，组件的<code>真实DOM结构</code>和<code>Virtual DOM</code>之间有一个映射的关系，React在虚拟DOM上实现了一个<code>diff</code>算法，当<code>render()</code>去重新渲染组件的时候，<code>diff</code>会找到需要变更的DOM，然后再把修改更新到浏览器上面的真实DOM上，所以，React并不是渲染了整个DOM树，<code>Virtual DOM</code>就是JS数据结构，所以比原生的DOM快得多。</p><h5 id="4、diff算法将传统的复杂度o-n-3-变成o-n-2"><a href="#4、diff算法将传统的复杂度o-n-3-变成o-n-2" class="headerlink" title="4、diff算法将传统的复杂度o(n$^3$)变成o(n$^2$)"></a>4、diff算法将传统的复杂度o(n$^3$)变成o(n$^2$)</h5><p>策略一（tree diff）：<br>Web UI中DOM节点跨层级的移动操作特别少，可以忽略不计。</p><p>策略二（component diff）：<br>拥有相同类的两个组件 生成相似的树形结构，<br>拥有不同类的两个组件 生成不同的树形结构。</p><p>策略三（element diff）：<br>对于同一层级的一组子节点，通过唯一id区分。</p><h5 id="5、vue组件间传值的方式"><a href="#5、vue组件间传值的方式" class="headerlink" title="5、vue组件间传值的方式"></a>5、vue组件间传值的方式</h5><ul><li><p>props/$emit（父-&gt;子）</p><p>在父组件的data中定义一个数据，可以在子组件中使用props来接受</p></li><li><p>事件传递（子-&gt;父）</p><p>在子组件中通过事件，将方法绑定，然后在methods中，完成自定义事件</p><p>在父组件中，通过v-on:自定义事件=函数 并将此函数在method中实现</p></li><li><p>创建一个空的vue实例作为中央事件总线</p><p>通过事件绑定这个自定义事件，通过Event(刚才创建的空实例).emit(自定义事件，传递数据)，同理在需要传递到的组件中，使用Event.$on(自定义事件，数据=&gt; function)</p></li><li><p>vuex</p><p>如果项目大了，使用上面这个方面会显得不易于管理，可以采用vuex作为状态管理方法。vuex实现了一个单向数据流，在全局拥有一个State来存放数据。设置为严格模式时，确保state中的值只能在mutations中被修改。getter是State的计算属性。action和mutation类似，是对异步的函数写入这里，以保证mutaions来仅同步实现。module是为了放在一个state显得冗杂，可以module嵌套，每个module都有自己的属性。</p></li></ul><h5 id="6、前端网络攻击"><a href="#6、前端网络攻击" class="headerlink" title="6、前端网络攻击"></a>6、前端网络攻击</h5><ul><li><p>XSS跨站脚本攻击，开启cookie的HttpOnly</p></li><li><p>SQL注入</p></li><li><p>CSRF跨站请求伪造，利用浏览器的cookis或服务器的session策略，模拟用户向第三方网站发送恶意请求</p><ul><li><p>解决方式：1、同源检测：可以禁止外域或不受信任的域名对我们发起请求。可以通过<code>origin header</code>或者<code>referer header</code>判断请求源</p><p>​                   2、Token验证：请求提交的时候携带Token，并且每次的Token都是合法的随机数，采用post去传递token</p></li></ul></li></ul><h5 id="7、前端跨域问题如何解决"><a href="#7、前端跨域问题如何解决" class="headerlink" title="7、前端跨域问题如何解决"></a>7、前端跨域问题如何解决</h5><p>常见的跨域常见</p><table><thead><tr><th>URL</th><th>说明</th><th>是否允许通信</th></tr></thead><tbody><tr><td><a href="http://www.domain.com/a.js">http://www.domain.com/a.js</a><br/><a href="http://www.domain.com/b.js">http://www.domain.com/b.js</a> <br/><a href="http://www.domain.com/lab/c.js">http://www.domain.com/lab/c.js</a></td><td>同一域名，不同文件或路径</td><td>允许</td></tr><tr><td><a href="http://www.domain.com:8000/a.js">http://www.domain.com:8000/a.js</a><br/><a href="http://www.domain.com/b.js">http://www.domain.com/b.js</a></td><td>同一域名，不同端口</td><td>不允许</td></tr><tr><td><a href="http://www.domain.com/a.js">http://www.domain.com/a.js</a><br/><a href="https://www.domain.com/b.js">https://www.domain.com/b.js</a></td><td>同一域名，不同协议</td><td>不允许</td></tr><tr><td><a href="http://www.domain.com/a.js">http://www.domain.com/a.js</a><br/><a href="http://192.168.4.12/b.js">http://192.168.4.12/b.js</a></td><td>域名和域名对应相同ip</td><td>不允许</td></tr><tr><td><a href="http://www.domain.com/a.js">http://www.domain.com/a.js</a><br/><a href="http://x.domain.com/b.js">http://x.domain.com/b.js</a> <br/><a href="http://domain.com/c.js">http://domain.com/c.js</a></td><td>主域相同，子域不同</td><td>不允许</td></tr><tr><td><a href="http://www.domain1.com/a.js">http://www.domain1.com/a.js</a><br/><a href="http://www.domain2.com/b.js">http://www.domain2.com/b.js</a></td><td>不同域名</td><td>不允许</td></tr></tbody></table><ul><li><p><code>JSONP</code></p><p>当为了减轻web服务器的负载，我们把js、css、img等静态资源分离到另一个独立域名的服务器上，在html页面中再通过相应的标签从不同域名下加载静态资源。动态创建script，再请求一个带参数网址实现跨域通信。 </p></li><li><p><code>CORS跨域</code></p><p>后端修改请求头</p></li><li><p>document.domain + iframe跨域问题</p><blockquote><p>这两个域名必须属于同一个一级域名!而且所用的协议，端口都要一致，否则无法利用document.domain进行跨域。</p></blockquote><p>通过js强制设置document.domain为基础主域，就实现了同域</p></li><li><p>location.hash+iframe</p><p>不同域之间只能通过hash值单向通信，a借助一个辅助页c,再通过与a同域的数据传回，但是会直接暴露在url中，数据容量和类型都有限</p><p>缺陷：只能实现get一种请求不同域只能通过hash值单向通信，b与c也不同域也只能单向通信，但c与a同域，所以c可通过parent.parent访问a页面所有对象。</p></li><li><p>window.name+iframe跨域</p><p>window.name在不同页面（甚至不同域名）加载后依旧存在，并且支持2MB的name值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> proxy = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">url, callback</span>) </span>&#123;<br>    <span class="hljs-keyword">var</span> state = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">var</span> iframe = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">&#x27;iframe&#x27;</span>);<br><br>    <span class="hljs-comment">// 加载跨域页面</span><br>    iframe.src = url;<br><br>    <span class="hljs-comment">// onload事件会触发2次，第1次加载跨域页，并留存数据于window.name</span><br>    iframe.onload = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>        <span class="hljs-keyword">if</span> (state === <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-comment">// 第2次onload(同域proxy页)成功后，读取同域window.name中数据</span><br>            callback(iframe.contentWindow.name);<br>            destoryFrame();<br><br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (state === <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-comment">// 第1次onload(跨域页)成功后，切换到同域代理页面</span><br>            iframe.contentWindow.location = <span class="hljs-string">&#x27;http://www.domain1.com/proxy.html&#x27;</span>;<br>            state = <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;;<br><br>    <span class="hljs-built_in">document</span>.body.appendChild(iframe);<br><br>    <span class="hljs-comment">// 获取数据以后销毁这个iframe，释放内存；这也保证了安全（不被其他域frame js访问）</span><br>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">destoryFrame</span>(<span class="hljs-params"></span>) </span>&#123;<br>        iframe.contentWindow.document.write(<span class="hljs-string">&#x27;&#x27;</span>);<br>        iframe.contentWindow.close();<br>        <span class="hljs-built_in">document</span>.body.removeChild(iframe);<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">// 请求跨域b页面数据</span><br>proxy(<span class="hljs-string">&#x27;http://www.domain2.com/b.html&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">data</span>)</span>&#123;<br>    alert(data);<br>&#125;);<br></code></pre></td></tr></table></figure></li></ul><h5 id="8、RESTful-API"><a href="#8、RESTful-API" class="headerlink" title="8、RESTful API"></a>8、RESTful API</h5><p>REST全称是Representational State Transfer（表征性状态转移）</p><p>RESTful更多的是一种风格，只要符合标准的框架都是RESTful的</p><p>RESTful框架的主要原则</p><ul><li>对网络上所有的资源都有一个资源标志符。</li><li>对资源的操作不会改变标识符。</li><li>同一资源有多种表现形式（xml、json）</li><li>所有操作都是无状态的（Stateless）</li></ul><p>符合上述REST原则的架构方式称为RESTful</p><p>参考链接：<a href="https://blog.csdn.net/x541211190/article/details/81141459">https://blog.csdn.net/x541211190/article/details/81141459</a></p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>javascript,css</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Interview Summary</title>
    <link href="/2020/12/07/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/"/>
    <url>/2020/12/07/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<p>前端面试总结</p><a id="more"></a><h5 id="1、盒子模型"><a href="#1、盒子模型" class="headerlink" title="1、盒子模型"></a>1、盒子模型</h5><p>所有HTML元素可以看作盒子，在CSS中，”box model”这一术语是用来设计和布局时使用。</p><p>CSS盒模型本质上是一个盒子，封装周围的HTML元素，它包括：边距，边框，填充，和实际内容。</p><p>盒模型允许我们在其它元素和周围元素边框之间的空间放置元素。</p><p>不同部分的说明：</p><ul><li><strong>Margin(外边距)</strong> - 清除边框外的区域，外边距是透明的。</li><li><strong>Border(边框)</strong> - 围绕在内边距和内容外的边框。</li><li><strong>Padding(内边距)</strong> - 清除内容周围的区域，内边距是透明的。</li><li><strong>Content(内容)</strong> - 盒子的内容，显示文本和图像。</li></ul><h5 id="2、https加密"><a href="#2、https加密" class="headerlink" title="2、https加密"></a>2、https加密</h5><p>https协议是由http和ssl协议构建的可进行加密传输和身份认证的网络协议，比http协议的安全性更高。</p><p>Https协议需要ca证书，费用较高。https则是具有安全性的ssl加密传输协议。</p><h5 id="3、css实现两栏布局、左边固定、右边自适应"><a href="#3、css实现两栏布局、左边固定、右边自适应" class="headerlink" title="3、css实现两栏布局、左边固定、右边自适应"></a>3、css实现两栏布局、左边固定、右边自适应</h5><p><a href="https://segmentfault.com/a/1190000010698609">https://segmentfault.com/a/1190000010698609</a></p><h5 id="4、vue与react的区别"><a href="#4、vue与react的区别" class="headerlink" title="4、vue与react的区别"></a>4、vue与react的区别</h5><p><a href="https://blog.csdn.net/qq_37617413/article/details/90669216">https://blog.csdn.net/qq_37617413/article/details/90669216</a></p><h5 id="5、vue的双向绑定原理"><a href="#5、vue的双向绑定原理" class="headerlink" title="5、vue的双向绑定原理"></a>5、vue的双向绑定原理</h5><p>vue的数据双向绑定主要通过Object.defineProperty()方法来进行数据劫持以及发布者-订阅模式来实现的，</p><ul><li>具体怎么实现的呢？</li></ul><p>要想实现数据的双向绑定首先就要通过数据拦截来进行监听数据的改变，这个时候就要设置一个监听器Observer来进行监听，如果属性发生改变的话就告诉订阅者Watcher看看是否需要改变，同时的话订阅者可以有好多个，我们就用一个订阅者管理器(Dep)来管理这些订阅者。紧接着我们还要有个指令解析器来对每个节点进行扫描和解析（解析节点的指令如v-on）,把他们初始化成一个订阅器Watcher,并且绑定相应的函数，Watcher会对比前后两个的数值是否发生变化，然后确定是否通知视图进行重新渲染；</p><h5 id="6、vuex的核心属性"><a href="#6、vuex的核心属性" class="headerlink" title="6、vuex的核心属性"></a>6、vuex的核心属性</h5><ul><li>state:vuex的基本数据，提供唯一 的公共数据源，所有共享的数据都要统一放在store中的state中，使用单一状态树，包含我们所需要的基本状态参数</li><li>getter：相当于State的计算属性</li><li>mutation:更新数据的方法，同步方式</li><li>action:功能和mutaion大致相同，action是通过提交mutation来更改状态。</li><li>module:整个store对象集中到一个很大的对象，将store分割到很多模块，使得每个模块拥有自己的属性</li></ul><h5 id="7、box-sizing的使用场景"><a href="#7、box-sizing的使用场景" class="headerlink" title="7、box-sizing的使用场景"></a>7、box-sizing的使用场景</h5><p>首先盒子模型：ie盒子模型和标准W3C盒子模型</p><ul><li>标准盒子模型：width=content  height=content</li><li>ie盒子模型：width=margin+border+padding+content</li></ul><p>1、考虑到盒子的大小设置会比较麻烦，有时设置的width，结果最后大小不是之前设置的大小，所以这时就要box-sizing登场了，当我们设置box-sizing:border-box以后，如果我们想要一个宽度100的盒子，直接设置width为100，就不用考虑该盒子是否为标准盒子了。这是box-sizing最实用的一个属性。等于：siting-width=border+padding+content-width;（为元素设定的宽度和高度决定了元素的边框盒。就是说，为元素指定的任何内边距和边框都将在已设定的宽度和高度内进行绘制。通过从已设定的宽度和高度分别减去边框和内边距才能得到内容的宽度和高度）</p><p>2、当box-sizing设置成content-box后，等于标准情况：siting-width=conten-width;（在宽度和高度之外绘制元素的内边距和边框。）</p><h5 id="8、弹性flex布局"><a href="#8、弹性flex布局" class="headerlink" title="8、弹性flex布局"></a>8、弹性flex布局</h5><blockquote><p>通过修改父元素div的<code>display:flex</code>，让父元素成为一个<code>flex容器</code>，从而可以自由的操作容器中子元素（项目）的排列方式。</p></blockquote><ul><li>为什么现在我们都用flex布局</li></ul><p>例如我们让多个div横向排列，传统做法是使用浮动，但浮空后因为脱离文档流的缘故，父元素会失去高度，这又涉及了清除浮动等一系列的问题。</p><p>而flex布局相对简单很多，修改父元素display:flex，你会发现div自动就排列成了一行，而且没有浮动之后的副作用，从回流角度考虑，flex的性能更优于float；随着浏览器不断兼容以及旧版本的淘汰，flex布局注定会成为更为流行的布局方案。</p><p>给予容器控制内部元素高度和宽度的能力。</p><p>在webkit内核的浏览器使用时，必须加上**-webkit-**前缀</p><ul><li>Google Chrome 谷歌浏览器</li><li>Safari浏览器</li><li>搜狗高速浏览器</li><li>遨游浏览器3</li><li>QQ浏览器</li><li>360极速浏览器</li><li>世界之窗浏览器</li><li>阿里云浏览器</li></ul><p>使用flex的容器，它内部的元素自动成为flex项目。容器拥有两根隐形的轴，水平的主轴和竖直的交叉轴，主轴与左边框的交点为main start,主轴与右边框的交点为main end,交叉轴的起点为cross start,交叉轴结束的位置成位cross end,项目的主轴宽度为main size,交叉轴方向上的宽度为cross size.同时flex item的float、clear、vertical-align属性将失效。</p><p>felx的相关的示意图见下链：</p><p><a href="https://images2015.cnblogs.com/blog/1008386/201608/1008386-20160829212313605-763604383.png">https://images2015.cnblogs.com/blog/1008386/201608/1008386-20160829212313605-763604383.png</a></p><ul><li><p>容器的属性</p><ol><li><p>flex-direction:</p><ul><li>row:主轴为水平方向，项目沿主轴从左至右排列</li><li>column:主轴为竖直方向，项目沿主轴从上至下排列</li><li>row-reverse:主轴水平，项目从右至左排列，与row反向</li><li>column-reverse:主轴竖直，项目从下至上排列，与column反向</li></ul></li><li><p>flex-wrap</p><ul><li>nowrap:自动缩小项目，不换行</li><li>wrap:换行，且第一行在上方</li><li>wrap-reverse:换行，第一行在下面</li></ul></li><li><p>flex-flow</p><p>  是flex-direction和flex-wrap的简写形式，有row wrap|column wrap-reverse等, 默认值为row nowrap</p></li><li><p>justify-content</p><p>决定item在主轴上的对齐方式，可能的值有flex-start(默认）</p><ul><li>flex-start:左对齐</li><li>flex-end:右对齐</li><li>center:居中对齐</li><li>space-between:两端对齐</li><li>space-around:沿轴线均匀分布</li></ul></li><li><p>align-items</p><p>决定item在交叉轴上的对齐方式</p><ul><li>flex-start:顶端对齐</li><li>flex-end:底部对齐</li><li>center:竖直方向上居中对齐</li><li>baseline:item第一行文字的底部对齐</li><li>stretch:当item未设置高度时，item将和容器等高对齐</li></ul></li><li><p>align-content</p><p>该属性定义了当有很多根主轴时，即item不止一行时，多行在交叉轴轴上的对齐方式。注意当有多行时，align-items属性将失效</p><ul><li>flex-start:左对齐</li><li>flex-end:右对齐</li><li>center:居中对齐</li><li>space-between:两端对齐</li><li>space-around:沿轴线均匀分布</li></ul></li></ol></li><li><p>项目属性</p><ol><li><p>order</p><p>order的值越小，项目排列越靠前</p></li><li><p>flex-grow</p><p>定义了当flex容器有多余空间时，item是否放大。默认值为0，即当有多余空间时也不放大，数值为对应的项目的放大比列。</p></li><li><p>flex-shrink</p><p>定义了当容器空间不足时，item是否缩小。默认值为1，当空间不足时，项目自动缩小。其可能的值为整数，表示不同的项目的缩小比例</p></li><li><p>flex-basis</p><p>表示项目的主轴占据的空间，默认值为auto。</p></li><li><p>flex</p><p>属性是flex-grow、flex-shrink和flex-basis三属性的简写总和</p></li><li><p>align-self</p><ul><li><p>auto: 和父元素align-self的值一致</p></li><li><p>flex-start:顶端对齐</p></li><li><p>flex-end:底部对齐</p></li><li><p>center:竖直方向上居中对齐</p></li><li><p>baseline: 项目的第一行文字的底部对齐</p></li><li><p>stretch: 当项目未设置高度时，item将和容器等高对齐</p><p>【参考链接】：<a href="https://www.cnblogs.com/nuannuan7362/p/5823381.html">https://www.cnblogs.com/nuannuan7362/p/5823381.html</a></p></li></ul></li></ol></li></ul><h5 id="9、什么是闭包"><a href="#9、什么是闭包" class="headerlink" title="9、什么是闭包"></a>9、什么是闭包</h5><p><strong>「函数」和「函数内部能访问到的变量」（也叫环境）的总和，就是一个闭包。</strong></p><p>希望能够把变量给隐藏了。</p><p>参考链接：<a href="https://zhuanlan.zhihu.com/p/22486908">https://zhuanlan.zhihu.com/p/22486908</a></p><h5 id="10、箭头函数和普通函数"><a href="#10、箭头函数和普通函数" class="headerlink" title="10、箭头函数和普通函数"></a>10、箭头函数和普通函数</h5><p>箭头函数本身没用prototype所以箭头函数本身没用this</p><p>箭头函数的this永远指向其上下文，call()、bind()、apply()改变不了其this的指向</p><p>普通函数的this指向调用它的那个对象</p><p>箭头函数相当于一个匿名函数，不能作为构造函数，不能new</p><p>箭头函数对比：<a href="https://www.cnblogs.com/shamszhang/p/10530298.html">https://www.cnblogs.com/shamszhang/p/10530298.html</a></p><h5 id="11、flex-1代表什么"><a href="#11、flex-1代表什么" class="headerlink" title="11、flex:1代表什么"></a>11、flex:1代表什么</h5><p><a href="https://zhuanlan.zhihu.com/p/136223806">https://zhuanlan.zhihu.com/p/136223806</a></p><h5 id="13、控制元素显示和隐藏的两种方法"><a href="#13、控制元素显示和隐藏的两种方法" class="headerlink" title="13、控制元素显示和隐藏的两种方法"></a>13、控制元素显示和隐藏的两种方法</h5><ul><li>方法一</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&quot;EleId&quot;</span>).style.visibility=<span class="hljs-string">&quot;hidden&quot;</span>;<br><span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&quot;EleId&quot;</span>).style.visibility=<span class="hljs-string">&quot;visible&quot;</span>;<br></code></pre></td></tr></table></figure><ul><li>方法二</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&quot;EleId&quot;</span>).style.display=<span class="hljs-string">&quot;none&quot;</span>;<br><span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&quot;EleId&quot;</span>).style.display=<span class="hljs-string">&quot;inline&quot;</span>;<br></code></pre></td></tr></table></figure><h5 id="17、post和get的区别"><a href="#17、post和get的区别" class="headerlink" title="17、post和get的区别"></a>17、post和get的区别</h5><ul><li>GET在浏览器回退时是无害的，而POST会再次提交请求。</li><li>GET产生的URL地址可以被Bookmark，而POST不可以。 </li><li>GET请求会被浏览器主动cache，而POST不会，除非手动设置。</li><li>GET请求只能进行url编码，而POST支持多种编码方式。</li><li>GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留。</li><li>GET请求在URL中传送的参数是有长度限制的，而POST么有。</li><li>对参数的数据类型，GET只接受ASCII字符，而POST没有限制。</li><li>GET比POST更不安全，因为参数直接暴露在URL上，所以不能用来传递敏感信息。</li></ul><p>参考链接：<a href="https://www.cnblogs.com/logsharing/p/8448446.html">https://www.cnblogs.com/logsharing/p/8448446.html</a></p><h5 id="20、defer和async的区别"><a href="#20、defer和async的区别" class="headerlink" title="20、defer和async的区别"></a>20、defer和async的区别</h5><p>当浏览器碰到script脚本，没用deffer和async，浏览器会立刻加载并执行指定的脚本</p><p>有async加载和渲染后续文档元素的过程将和script.js的加载与执行并行进行（异步）</p><p>有defer，加载后续文档元素的过程将和script.js的加载并行进行异步</p><p>示例图链接：<a href="https://segmentfault.com/img/bVWhRl?w=801&amp;h=814/view">https://segmentfault.com/img/bVWhRl?w=801&amp;h=814/view</a></p><h5 id="21、keep-alive"><a href="#21、keep-alive" class="headerlink" title="21、keep-alive"></a>21、keep-alive</h5><p><a href="https://www.cnblogs.com/sysuhanyf/p/7454530.html">https://www.cnblogs.com/sysuhanyf/p/7454530.html</a></p><h5 id="22、http状态码"><a href="#22、http状态码" class="headerlink" title="22、http状态码"></a>22、http状态码</h5><table><thead><tr><th align="left">分类</th><th align="left">分类描述</th></tr></thead><tbody><tr><td align="left">1**</td><td align="left">信息，服务器收到请求，需要请求者继续执行操作</td></tr><tr><td align="left">2**</td><td align="left">成功，操作被成功接收并处理</td></tr><tr><td align="left">3**</td><td align="left">重定向，需要进一步的操作以完成请求</td></tr><tr><td align="left">4**</td><td align="left">客户端错误，请求包含语法错误或无法完成请求</td></tr><tr><td align="left">5**</td><td align="left">服务器错误，服务器在处理请求的过程中发生了错误</td></tr></tbody></table><p>​                                                        Http状态码分类</p><table><thead><tr><th align="left">状态码</th><th align="left">状态码英文名称</th><th align="left">中文描述</th></tr></thead><tbody><tr><td align="left">100</td><td align="left">Continue</td><td align="left">继续。<a href="http://www.dreamdu.com/webbuild/client_vs_server/">客户端</a>应继续其请求</td></tr><tr><td align="left">101</td><td align="left">Switching Protocols</td><td align="left">切换协议。服务器根据客户端的请求切换协议。只能切换到更高级的协议，例如，切换到HTTP的新版本协议</td></tr><tr><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">200</td><td align="left">OK</td><td align="left">请求成功。一般用于GET与POST请求</td></tr><tr><td align="left">201</td><td align="left">Created</td><td align="left">已创建。成功请求并创建了新的资源</td></tr><tr><td align="left">202</td><td align="left">Accepted</td><td align="left">已接受。已经接受请求，但未处理完成</td></tr><tr><td align="left">203</td><td align="left">Non-Authoritative Information</td><td align="left">非授权信息。请求成功。但返回的meta信息不在原始的服务器，而是一个副本</td></tr><tr><td align="left">204</td><td align="left">No Content</td><td align="left">无内容。服务器成功处理，但未返回内容。在未更新网页的情况下，可确保浏览器继续显示当前文档</td></tr><tr><td align="left">205</td><td align="left">Reset Content</td><td align="left">重置内容。服务器处理成功，用户终端（例如：浏览器）应重置文档视图。可通过此返回码清除浏览器的表单域</td></tr><tr><td align="left">206</td><td align="left">Partial Content</td><td align="left">部分内容。服务器成功处理了部分GET请求</td></tr><tr><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">300</td><td align="left">Multiple Choices</td><td align="left">多种选择。请求的资源可包括多个位置，相应可返回一个资源特征与地址的列表用于用户终端（例如：浏览器）选择</td></tr><tr><td align="left">301</td><td align="left">Moved Permanently</td><td align="left">永久移动。请求的资源已被永久的移动到新URI，返回信息会包括新的URI，浏览器会自动定向到新URI。今后任何新的请求都应使用新的URI代替</td></tr><tr><td align="left">302</td><td align="left">Found</td><td align="left">临时移动。与301类似。但资源只是临时被移动。客户端应继续使用原有URI</td></tr><tr><td align="left">303</td><td align="left">See Other</td><td align="left">查看其它地址。与301类似。使用GET和POST请求查看</td></tr><tr><td align="left">==<strong>304</strong>==</td><td align="left">Not Modified</td><td align="left">未修改。所请求的资源未修改，服务器返回此状态码时，不会返回任何资源。客户端通常会缓存访问过的资源，通过提供一个头信息指出客户端希望只返回在指定日期之后修改的资源</td></tr><tr><td align="left">305</td><td align="left">Use Proxy</td><td align="left">使用代理。所请求的资源必须通过代理访问</td></tr><tr><td align="left">306</td><td align="left">Unused</td><td align="left">已经被废弃的HTTP状态码</td></tr><tr><td align="left">307</td><td align="left">Temporary Redirect</td><td align="left">临时重定向。与302类似。使用GET请求重定向</td></tr><tr><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">400</td><td align="left">Bad Request</td><td align="left">客户端请求的语法错误，服务器无法理解</td></tr><tr><td align="left">401</td><td align="left">Unauthorized</td><td align="left">请求要求用户的身份认证</td></tr><tr><td align="left">402</td><td align="left">Payment Required</td><td align="left">保留，将来使用</td></tr><tr><td align="left">403</td><td align="left">Forbidden</td><td align="left">服务器理解请求客户端的请求，但是拒绝执行此请求</td></tr><tr><td align="left">404</td><td align="left">Not Found</td><td align="left">服务器无法根据客户端的请求找到资源（网页）。通过此代码，网站设计人员可设置”您所请求的资源无法找到”的个性页面</td></tr><tr><td align="left">405</td><td align="left">Method Not Allowed</td><td align="left">客户端请求中的方法被禁止</td></tr><tr><td align="left">406</td><td align="left">Not Acceptable</td><td align="left">服务器无法根据客户端请求的内容特性完成请求</td></tr><tr><td align="left">407</td><td align="left">Proxy Authentication Required</td><td align="left">请求要求代理的身份认证，与401类似，但请求者应当使用代理进行授权</td></tr><tr><td align="left">408</td><td align="left">Request Time-out</td><td align="left">服务器等待客户端发送的请求时间过长，超时</td></tr><tr><td align="left">409</td><td align="left">Conflict</td><td align="left">服务器完成客户端的 PUT 请求时可能返回此代码，服务器处理请求时发生了冲突</td></tr><tr><td align="left">410</td><td align="left">Gone</td><td align="left">客户端请求的资源已经不存在。410不同于404，如果资源以前有现在被永久删除了可使用410代码，网站设计人员可通过301代码指定资源的新位置</td></tr><tr><td align="left">411</td><td align="left">Length Required</td><td align="left">服务器无法处理客户端发送的不带Content-Length的请求信息</td></tr><tr><td align="left">412</td><td align="left">Precondition Failed</td><td align="left">客户端请求信息的先决条件错误</td></tr><tr><td align="left">413</td><td align="left">Request Entity Too Large</td><td align="left">由于请求的实体过大，服务器无法处理，因此拒绝请求。为防止客户端的连续请求，服务器可能会关闭连接。如果只是服务器暂时无法处理，则会包含一个Retry-After的响应信息</td></tr><tr><td align="left">414</td><td align="left">Request-URI Too Large</td><td align="left">请求的URI过长（URI通常为网址），服务器无法处理</td></tr><tr><td align="left">415</td><td align="left">Unsupported Media Type</td><td align="left">服务器无法处理请求附带的媒体格式</td></tr><tr><td align="left">416</td><td align="left">Requested range not satisfiable</td><td align="left">客户端请求的范围无效</td></tr><tr><td align="left">417</td><td align="left">Expectation Failed</td><td align="left">服务器无法满足Expect的请求头信息</td></tr><tr><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">500</td><td align="left">Internal Server Error</td><td align="left">服务器内部错误，无法完成请求</td></tr><tr><td align="left">501</td><td align="left">Not Implemented</td><td align="left">服务器不支持请求的功能，无法完成请求</td></tr><tr><td align="left">502</td><td align="left">Bad Gateway</td><td align="left">作为网关或者代理工作的服务器尝试执行请求时，从远程服务器接收到了一个无效的响应</td></tr><tr><td align="left">503</td><td align="left">Service Unavailable</td><td align="left">由于超载或系统维护，服务器暂时的无法处理客户端的请求。延时的长度可包含在服务器的Retry-After头信息中</td></tr><tr><td align="left">504</td><td align="left">Gateway Time-out</td><td align="left">充当网关或代理的服务器，未及时从远端服务器获取请求</td></tr><tr><td align="left">505</td><td align="left">HTTP Version not supported</td><td align="left">服务器不支持请求的HTTP协议的版本，无法完成处理</td></tr></tbody></table><h5 id="24、vue是什么时候从后台获取数据的"><a href="#24、vue是什么时候从后台获取数据的" class="headerlink" title="24、vue是什么时候从后台获取数据的"></a>24、vue是什么时候从后台获取数据的</h5><p>beforeCreate 和 created 都是早期钩子，是我们获取数据的较好时机，如果获取的数据与绑定事件有关，可以放到 created 里面，无关的话，都可以，在服务器端的应用场景中， beforeCreate 可能会用到的多一些。</p><p>beforeMount 和 mounted 多用于页面组件上有新的用户交互，触发新的请求时候使用，比如在 mounted 里手动去触发滚动条的位置，而 beforeMount 里面，可以做比如通过域名识别来获取微信认证信息的操作。</p><p>应该beforecreate和created</p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>javascript,css</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
