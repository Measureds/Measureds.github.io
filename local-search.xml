<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>西安腾讯前端一面试总结</title>
    <link href="/2020/12/25/%E8%85%BE%E8%AE%AF%E8%A5%BF%E5%AE%89%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93%E4%B8%80%E9%9D%A2/"/>
    <url>/2020/12/25/%E8%85%BE%E8%AE%AF%E8%A5%BF%E5%AE%89%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93%E4%B8%80%E9%9D%A2/</url>
    
    <content type="html"><![CDATA[<p>事发突然很难受，刚睡醒，就接到腾讯面试官的电话，之前一直在想面试会问啥，其实这次面试并不能，出乎意料的简单，但是错失了机会。基础问题，被说安全基础差，踏实学习吧。之前一直浮躁，从没用认识思考基础知识，而且这是第一次面试，超级紧张。</p><p>现在回顾复盘一下问了一些什么，附带应该有的回答</p><h5 id="1、你什么时候开始学习前端的，项目经历"><a href="#1、你什么时候开始学习前端的，项目经历" class="headerlink" title="1、你什么时候开始学习前端的，项目经历"></a>1、你什么时候开始学习前端的，项目经历</h5><h5 id="2、你从输出一个url到看到页面经过的过程"><a href="#2、你从输出一个url到看到页面经过的过程" class="headerlink" title="2、你从输出一个url到看到页面经过的过程"></a>2、你从输出一个url到看到页面经过的过程</h5><ul><li>输入网址：浏览器在输入网址的时候，就可能只能的匹配url</li><li>DNS解析：详细见4问（回答的不具体，然后展开又问了一下）</li><li>建立TCP连接</li><li>向客户端发起HTTP请求</li><li>服务器处理请求</li><li>服务器响应</li><li>浏览器展示HTML</li></ul><h5 id="3、页面渲染的过程"><a href="#3、页面渲染的过程" class="headerlink" title="3、页面渲染的过程"></a>3、页面渲染的过程</h5><ul><li>根据html文件构建DOM树和CSSOM树。构建DOM树期间，如果遇到JS,阻塞DOM树及CSSOM树的构建，优先加载JS文件，加载完毕后，继续再构建DOM树及CSSOM树</li><li>构建渲染树</li><li>页面的重绘与重排。页面渲染完成后，若JS操作了DOM节点，根据JS对DOM操作动作的大小，浏览器会对页面进行重绘和重排</li></ul><h5 id="4、DNS具体解析的过程"><a href="#4、DNS具体解析的过程" class="headerlink" title="4、DNS具体解析的过程"></a>4、DNS具体解析的过程</h5><ol><li><p>首先会在本机的hosts的文件里寻找，如果没用就向本地DNS服务器进行递归查询</p></li><li><p>本地服务器采用迭代查询。它向一个根域名服务器查询。</p></li><li><p>根域名服务器告诉本地服务器，下一次查询的顶级域名服务器的ip地址</p></li><li><p>本地域名服务器向顶级域名服务器查询</p></li><li><p>顶级域名服务器告诉本地域名服务器下一把的权限服务器的ip地址</p></li><li><p>本地域名服务器向权限服务器进行查询。</p></li><li><p>权限服务器告诉本地服务器所查的主机的ip地址</p></li><li><p>本地域名服务器把查询结果告诉主机</p><p>整个过程共用到8个UDP报文</p></li></ol><h5 id="5、三次握手、四次挥手的细节"><a href="#5、三次握手、四次挥手的细节" class="headerlink" title="5、三次握手、四次挥手的细节"></a>5、三次握手、四次挥手的细节</h5><ul><li>三次握手<ol><li>客户端发送syn包（seq=x）到服务器，并进入SYN_SEND状态，等待服务器确认</li><li>服务器收到syn包，必须确认客户的SYN（ack=x+1），同时自己页发送一个SYN包（seq=y）,即SYN+ACK包，此时服务器进入SYN_RECV状态</li><li>客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack=y+1)，此包发送完毕，客户端和服务器进入Established状态</li></ol></li><li>四次挥手<ol><li>主动关闭方发送一个FIN，用来关闭主动方到被动关闭方的数据传送，也就是主动关闭方告诉被动关闭方：我已经不会再给你发送数据了（当然，再FIN包之前发送出去的数据，如果没用收到对应的ack确认报文，主动关闭方依然会重发这些数据），但是此时主动关闭方还可以接受数据</li><li>被动关闭方收到FIN包后，发送一个ACK给对方，确认序号为收到序号+1（与SYN相同，一个FIN占用一个序号）</li><li>被动关闭方发送一个FIN,用来关闭被动关闭方到主动关闭方的数据传送，也就是告诉主动关闭方，我的数据页发送完了，不会再给你发送数据了。</li><li>主动关闭方收到FIN后，发送一个ACK给被动关闭方，确认序号为收到序号+！，至此，完成四次挥手</li></ol></li></ul><p>既然都到这里了，我们把传输过程中的问题页一并复习了吧</p><ul><li>超时重传：超时重传机制用来保障TCP传输的可靠性。每次发送数据包时，发送的数据宝都有seq号，接受端收到数据后，会回复ack进行确认，表示某一seq号数据已经收到。发送方在发送了某个seq包后，等待一段时间，如果没有收到对应的ack回复，就会认为报文丢失，会重传这个数据包。</li><li>快速重传：接受数据一方发现有数据包丢失掉了，就会发送ack报文告诉发送方重传丢失的报文。如果发送端连续收到标号相同的ack包，则会触发发送端的快速重传。（超时重传就类似于发送端傻等超时，而快速重传就类似接受端主动告诉发送端，没收到，而触发超时重传）</li><li>流量控制：这里主要说TCP的滑动窗口流量控制。TCP头有个字段叫WIndow，由叫Advertised-Window,这个字段是接受端告诉发送端自己还有多少缓冲区可以接受数据。于是发送端就可以根据这个接受端的处理能力来发送数据，而不会导致接收端处理不过来。滑动窗口可以提高TCP传输效率的一种机制。</li><li>拥塞控制：滑动窗口用来做流量控制。流量控制只会关注发送端和接受端自身的状况，而没有考虑整个网络的通信情况。拥塞控制，则是基于整个网络来考虑的。考虑一下这样的场景：某个时刻网络上的延时突然增加，那么，TCP对这个事做出的应对只有重传数据，但是，重传会导致网络负担更重，于是会导致更大的延迟以及更多丢包，于是，这种情况会进入恶心循环被不断地放大。试想一下，如果一个网络内有成千上万的TCP连接都这样行事，会马上形成“网络风暴”,TCP这个协议就会拖垮整个网络。为此TCP就引入了拥塞控制策略。拥塞策略算法主要包括：慢启动，拥塞避免，快重传，快速恢复。<ul><li>慢开始：刚开始发送方维护一个拥塞窗口，大小等于发送窗口，通过出现了超时来判断网络出现拥塞。慢开始的思路是一开始发送方发送一个字节，在收到接受方的确认，然后发送的字节数量增大一倍（就是以指数增长的速率），逐步增大拥塞窗口，当拥塞窗口到达满开始门限，停止慢开始算法，开始拥塞避免算法。</li><li>拥塞避免：拥塞避免的增长速率变成线性增长，也就是每经过一个往返时间RTT就把发送方的拥塞窗口加1</li><li>快重传：上述两个算法使得网络传输速率一直增大，直至出现<code>超时</code>，这时候需要将<code>拥塞窗口</code>重新调整到1字节开始，使用<code>慢开始算法</code>，同时需要将<code>慢开始门限</code>调整为<code>超时</code>时的<code>拥塞窗口</code>大小的<code>一半</code>,继续执行慢开始算法、拥塞避免算法。</li><li>快恢复：如果收到了连续3个对同一报文的重复确认，此时可能发生了报文缺失，发送方不执行慢开始算法，直接使用<code>快重传算法</code>，立即发送缺失的报文段。同时执行快恢复算法，将门限值调整为此时拥塞窗口的一半，并执行拥塞避免算法</li></ul></li></ul><h5 id="6、前端安全的问题有哪些，具体防范措施"><a href="#6、前端安全的问题有哪些，具体防范措施" class="headerlink" title="6、前端安全的问题有哪些，具体防范措施"></a>6、前端安全的问题有哪些，具体防范措施</h5><ul><li>跨站脚本攻击（XSS攻击）：跨站脚本攻击，指的是恶意攻击者往Web页面里插入恶意html代码，当用户浏览该页之时，嵌入其中Web里面的html代码会被执行，从而达到用户的特殊目的。</li><li>SQL语句注入</li><li>跨站请求伪造（CSRF攻击）</li><li>文件上传</li></ul><h5 id="7、XSS具体是如何发动攻击的"><a href="#7、XSS具体是如何发动攻击的" class="headerlink" title="7、XSS具体是如何发动攻击的"></a>7、XSS具体是如何发动攻击的</h5><ul><li><p>分类：XSS分为反射型、存储型、及DOM-based型，其中反射型和DOM-based型可以归为非持久XSS攻击类型。存储型可以归类为持久性XSS攻击</p><ul><li><p>反射型XSS:一般指攻击者通过特定的方式来诱惑受害者去访问一个包含恶意代码的URL。当受害者点击恶意链接url的时候，恶意代码会直接在受害者的主机上的浏览器执行。</p><p>那么为什么要叫反射型呢？因为这种攻击方式的注入代码是从目标服务器通过错误信息，搜索结果等方式反射回来的，而为什么又叫非持久性XSS呢？因为这种攻击方式只有一次性。</p><p>攻击步骤如下</p><ol><li>攻击者在url后面的参数中加入恶意攻击代码</li><li>当用户打开带有恶意代码的URL的时候，网址服务器将恶意代码从URL中取出，拼接在html中并返回给浏览器端</li><li>用户浏览器接受到响应后执行解析，其中的恶意代码也会被执行到。</li><li>攻击者通过恶意代码来窃取到用户数据并发送到攻击者的网址。攻击者会获取到比如cookie等信息，然后使用该信息来冒充合法用户的行为，调用目标网站接口执行攻击等操作。</li></ol></li><li><p>存储型XSS:如果有一个博客网站，攻击者在上面发布一篇文章，如果不对文章进行任何处理就存入数据库，那么下次，其他用户访问该文章的时候，服务器就会读取然后响应给客户端，那么浏览器就会执行该段脚本，然后攻击者就会获取用户的cookie，然后会把cookie发送到攻击者的服务器上了。</p><p>攻击步骤如下:</p><ol><li>攻击者将恶意代码提交到目标网站数据库中</li><li>用户打开目标网站时，网站服务器将恶意代码从数据库中取出，然后拼接成html中返回给浏览器。</li><li>用户浏览器接受到响应后解析执行，其中恶意代码也会被执行。</li><li>那么恶意执行代码后，就能获取到用户数据，比如上面的cookie等信息，那么把该cookie发送到攻击者网站中，那么攻击者拿到该cookie然后会冒充该用户的行为，调用目标网站接口等违法操作。</li></ol><p>防范措施：后端需要对提交的数据进行过滤</p><p>前端页可以做一下处理方式，比如对script标签，将特殊字符替换成HTML编码等。</p></li><li><p>DOM-based型xss:我们客户端的js可以对页面dom节点进行动态的操作，比如插入、修改页面的内容。比如说客户端从URL中提取数据并且在本地执行、如果用户在客户端输入的数据包含了恶意的js脚本的话，但是这些脚本又没有做任何过滤处理的话，那么我们的应用程序就又可能收到DOM-based XSS的攻击。</p><p>攻击步骤如下：</p><ol><li>攻击者构造出特殊的URL、在其中可能包含恶意代码。</li><li>用户打开带有恶意的代码的URL</li><li>用户浏览器收到响应后解析执行。前端使用js取出url的恶意代码并执行。</li><li>执行时，，恶意代码窃取用户数据并发送到攻击者的网站中，那么攻击者网站拿着这些数据去冒充用户的行为操作。调用目标网站接口执行攻击者的一些操作。</li></ol><p>一般又如下的DOM操作</p><ul><li><p>document.write</p></li><li><p>innerHTML</p></li><li><p>location、location.href、location.replace、iframe.src、document.referer、window.name</p><p>因此我们需要对HTML进行编码，对JS进行编码来防止这些问题产生。</p></li></ul><p>参考链接：<a href="https://www.cnblogs.com/tugenhua0707/p/10909284.html#_labelTop">https://www.cnblogs.com/tugenhua0707/p/10909284.html#_labelTop</a></p><p><a href="https://www.cnblogs.com/mmy67/p/9923422.html">https://www.cnblogs.com/mmy67/p/9923422.html</a></p></li></ul></li></ul><h5 id="8、有哪些页面优化的手段，从框架啊、代码的角度说"><a href="#8、有哪些页面优化的手段，从框架啊、代码的角度说" class="headerlink" title="8、有哪些页面优化的手段，从框架啊、代码的角度说"></a>8、有哪些页面优化的手段，从框架啊、代码的角度说</h5><ul><li><p>资源压缩，减少http请求</p></li><li><p>使用CDN:在浏览器第一次打开页面时，缓存是起不了作用的。这时候，CDN就很有用</p></li><li><p>图片较多的页面可以使用lazyLoad等技术优化</p></li><li><p>非核心代码异步加载</p></li><li><p>利用浏览器缓存</p></li><li><p>DNS预解析</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>面经</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面经</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Interview Summary</title>
    <link href="/2020/12/13/Css3%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/"/>
    <url>/2020/12/13/Css3%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<p>Css问题汇总</p><a id="more"></a><h5 id="1、Css的选择器"><a href="#1、Css的选择器" class="headerlink" title="1、Css的选择器"></a>1、Css的选择器</h5><table><thead><tr><th>选择器</th><th>用法</th></tr></thead><tbody><tr><td>id选择器</td><td>#myid</td></tr><tr><td>类选择器</td><td>.myclassname</td></tr><tr><td>标签选择器</td><td>div,h1,p</td></tr><tr><td>相邻选择器</td><td>h1+p</td></tr><tr><td>子选择器</td><td>ul &gt; li</td></tr><tr><td>后代选择器</td><td>li a</td></tr><tr><td>通配符选择器</td><td>*</td></tr><tr><td>属性选择器</td><td>a[rel=”external”]</td></tr><tr><td>伪类选择器</td><td>a:hover, li:nth-child</td></tr></tbody></table><h5 id="2、样式层叠次序"><a href="#2、样式层叠次序" class="headerlink" title="2、样式层叠次序"></a>2、样式层叠次序</h5><p>当同一个 HTML 元素定义了多个样式时，应该使用哪个样式？</p><p>一般而言，所有的样式会根据下面的规则层叠于一个新的虚拟样式表中，其中数字 4 拥有最高的优先权。</p><ol><li>浏览器缺省设置</li><li>外部样式表（在<code>&lt;head&gt;和&lt;/head&gt;之间的link中</code>）</li><li>内部样式表（位于 <code>&lt;head&gt;</code> 标签内部）</li><li>内联样式（在 HTML 元素内部）</li></ol><p>因此，内联样式（在 HTML 元素内部）拥有最高的优先权，这意味着它将优先于以下的样式声明： 标签中的样式声明，外部样式表中的样式声明，或者浏览器中的样式声明（缺省值）。</p><p>注： CS 选择器有修饰上的优先级，即：</p><p>内联选择器 &gt; id选择器 &gt; 类选择器 &gt; 标签选择器</p><h5 id="3、多重样式优先级顺序"><a href="#3、多重样式优先级顺序" class="headerlink" title="3、多重样式优先级顺序"></a>3、多重样式优先级顺序</h5><p>下列是一份优先级逐级增加的选择器列表，其中数字 7 拥有最高的优先权：</p><ol><li>通用选择器（*）</li><li>元素(类型)选择器</li><li>类选择器</li><li>属性选择器</li><li>伪类</li><li>ID 选择器</li><li>内联样式</li></ol><h5 id="4、权重计算"><a href="#4、权重计算" class="headerlink" title="4、权重计算:"></a>4、权重计算:</h5><ul><li>内联样式表的权值最高 1000</li><li>ID 选择器的权值为 100</li><li>Class 类选择器的权值为 10</li><li>HTML 标签选择器的权值为 1</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-id">#redP</span> <span class="hljs-selector-tag">p</span> &#123;   <br><br><span class="hljs-comment">/* 权值 = 100+1=101 */</span>    <br><br><span class="hljs-attribute">color</span>:<span class="hljs-number">#F00</span>;  <span class="hljs-comment">/* 红色 */</span>   <br><br>&#125;    <br><br><span class="hljs-selector-id">#redP</span> <span class="hljs-selector-class">.red</span> <span class="hljs-selector-tag">em</span> &#123;    <br><br><span class="hljs-comment">/* 权值 = 100+10+1=111 */</span>    <br><br><span class="hljs-attribute">color</span>:<span class="hljs-number">#00F</span>; <span class="hljs-comment">/* 蓝色 */</span>   <br><br>&#125;   <br><br><span class="hljs-selector-id">#redP</span> <span class="hljs-selector-tag">p</span> <span class="hljs-selector-tag">span</span> <span class="hljs-selector-tag">em</span> &#123;   <br><br><span class="hljs-comment">/* 权值 = 100+1+1+1=103 */</span><br><br><span class="hljs-attribute">color</span>:<span class="hljs-number">#FF0</span>;<span class="hljs-comment">/*黄色*/</span>   <br><br>&#125;    <br></code></pre></td></tr></table></figure><h3 id="CSS-优先级法则："><a href="#CSS-优先级法则：" class="headerlink" title="CSS 优先级法则："></a>CSS 优先级法则：</h3><ul><li> A 选择器都有一个权值，权值越大越优先；</li><li> B 当权值相等时，后出现的样式表设置要优于先出现的样式表设置；</li><li> C 创作者的规则高于浏览者：即网页编写者设置的 CSS 样式的优先权高于浏览器所设置的样式；</li><li> D 继承的 CSS 样式不如后来指定的 CSS 样式；</li><li> E 在同一组属性设置中标有 “!important” 规则的优先级最大；</li></ul><h5 id="5、https-www-w3cschool-cn-css-css-outline-html"><a href="#5、https-www-w3cschool-cn-css-css-outline-html" class="headerlink" title="5、https://www.w3cschool.cn/css/css-outline.html"></a>5、<a href="https://www.w3cschool.cn/css/css-outline.html">https://www.w3cschool.cn/css/css-outline.html</a></h5>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>css</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Interview Summary</title>
    <link href="/2020/12/12/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93(%E4%BA%8C)/"/>
    <url>/2020/12/12/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93(%E4%BA%8C)/</url>
    
    <content type="html"><![CDATA[<p>前端面试总结</p><a id="more"></a><h5 id="1、如何看待前端框架选型"><a href="#1、如何看待前端框架选型" class="headerlink" title="1、如何看待前端框架选型"></a>1、如何看待前端框架选型</h5><p><a href="https://blog.csdn.net/qq_42774426/article/details/86600913">https://blog.csdn.net/qq_42774426/article/details/86600913</a></p><h5 id="2、vue如何实现双向绑定"><a href="#2、vue如何实现双向绑定" class="headerlink" title="2、vue如何实现双向绑定"></a>2、vue如何实现双向绑定</h5><p>vue.js 是采用数据劫持结合发布者-订阅者模式的方式，通过new Proxy()来劫持各个属性的setter，getter，在数据变动时发布消息给订阅者，触发相应的监听回调。</p><p>Vue 3.0与Vue 2.0的区别仅是数据劫持的方式由Object.defineProperty更改为Proxy代理，其他代码不变。</p><h5 id="3、react虚拟DOM是什么"><a href="#3、react虚拟DOM是什么" class="headerlink" title="3、react虚拟DOM是什么"></a>3、react虚拟DOM是什么</h5><p>当我们更新了<code>state</code>中的值的时候，React会去调用<code>render()</code>方法来重新渲染整个组件的UI，但是如果我们真的去操作这么大量的DOM，显然性能是堪忧的。所以React实现了一个<code>Virtual DOM</code>，组件的<code>真实DOM结构</code>和<code>Virtual DOM</code>之间有一个映射的关系，React在虚拟DOM上实现了一个<code>diff</code>算法，当<code>render()</code>去重新渲染组件的时候，<code>diff</code>会找到需要变更的DOM，然后再把修改更新到浏览器上面的真实DOM上，所以，React并不是渲染了整个DOM树，<code>Virtual DOM</code>就是JS数据结构，所以比原生的DOM快得多。</p><h5 id="4、diff算法将传统的复杂度o-n-3-变成o-n-2"><a href="#4、diff算法将传统的复杂度o-n-3-变成o-n-2" class="headerlink" title="4、diff算法将传统的复杂度o(n$^3$)变成o(n$^2$)"></a>4、diff算法将传统的复杂度o(n$^3$)变成o(n$^2$)</h5><p>策略一（tree diff）：<br>Web UI中DOM节点跨层级的移动操作特别少，可以忽略不计。</p><p>策略二（component diff）：<br>拥有相同类的两个组件 生成相似的树形结构，<br>拥有不同类的两个组件 生成不同的树形结构。</p><p>策略三（element diff）：<br>对于同一层级的一组子节点，通过唯一id区分。</p><h5 id="5、vue组件间传值的方式"><a href="#5、vue组件间传值的方式" class="headerlink" title="5、vue组件间传值的方式"></a>5、vue组件间传值的方式</h5><ul><li><p>props/$emit（父-&gt;子）</p><p>在父组件的data中定义一个数据，可以在子组件中使用props来接受</p></li><li><p>事件传递（子-&gt;父）</p><p>在子组件中通过事件，将方法绑定，然后在methods中，完成自定义事件</p><p>在父组件中，通过v-on:自定义事件=函数 并将此函数在method中实现</p></li><li><p>创建一个空的vue实例作为中央事件总线</p><p>通过事件绑定这个自定义事件，通过Event(刚才创建的空实例).emit(自定义事件，传递数据)，同理在需要传递到的组件中，使用Event.$on(自定义事件，数据=&gt; function)</p></li><li><p>vuex</p><p>如果项目大了，使用上面这个方面会显得不易于管理，可以采用vuex作为状态管理方法。vuex实现了一个单向数据流，在全局拥有一个State来存放数据。设置为严格模式时，确保state中的值只能在mutations中被修改。getter是State的计算属性。action和mutation类似，是对异步的函数写入这里，以保证mutaions来仅同步实现。module是为了放在一个state显得冗杂，可以module嵌套，每个module都有自己的属性。</p></li></ul><h5 id="6、前端网络攻击"><a href="#6、前端网络攻击" class="headerlink" title="6、前端网络攻击"></a>6、前端网络攻击</h5><ul><li><p>XSS跨站脚本攻击，开启cookie的HttpOnly</p></li><li><p>SQL注入</p></li><li><p>CSRF跨站请求伪造，利用浏览器的cookis或服务器的session策略，模拟用户向第三方网站发送恶意请求</p><ul><li><p>解决方式：1、同源检测：可以禁止外域或不受信任的域名对我们发起请求。可以通过<code>origin header</code>或者<code>referer header</code>判断请求源</p><p>​                   2、Token验证：请求提交的时候携带Token，并且每次的Token都是合法的随机数，采用post去传递token</p></li></ul></li></ul><h5 id="7、前端跨域问题如何解决"><a href="#7、前端跨域问题如何解决" class="headerlink" title="7、前端跨域问题如何解决"></a>7、前端跨域问题如何解决</h5><p>常见的跨域常见</p><table><thead><tr><th>URL</th><th>说明</th><th>是否允许通信</th></tr></thead><tbody><tr><td><a href="http://www.domain.com/a.js">http://www.domain.com/a.js</a><br/><a href="http://www.domain.com/b.js">http://www.domain.com/b.js</a> <br/><a href="http://www.domain.com/lab/c.js">http://www.domain.com/lab/c.js</a></td><td>同一域名，不同文件或路径</td><td>允许</td></tr><tr><td><a href="http://www.domain.com:8000/a.js">http://www.domain.com:8000/a.js</a><br/><a href="http://www.domain.com/b.js">http://www.domain.com/b.js</a></td><td>同一域名，不同端口</td><td>不允许</td></tr><tr><td><a href="http://www.domain.com/a.js">http://www.domain.com/a.js</a><br/><a href="https://www.domain.com/b.js">https://www.domain.com/b.js</a></td><td>同一域名，不同协议</td><td>不允许</td></tr><tr><td><a href="http://www.domain.com/a.js">http://www.domain.com/a.js</a><br/><a href="http://192.168.4.12/b.js">http://192.168.4.12/b.js</a></td><td>域名和域名对应相同ip</td><td>不允许</td></tr><tr><td><a href="http://www.domain.com/a.js">http://www.domain.com/a.js</a><br/><a href="http://x.domain.com/b.js">http://x.domain.com/b.js</a> <br/><a href="http://domain.com/c.js">http://domain.com/c.js</a></td><td>主域相同，子域不同</td><td>不允许</td></tr><tr><td><a href="http://www.domain1.com/a.js">http://www.domain1.com/a.js</a><br/><a href="http://www.domain2.com/b.js">http://www.domain2.com/b.js</a></td><td>不同域名</td><td>不允许</td></tr></tbody></table><ul><li><p><code>JSONP</code></p><p>当为了减轻web服务器的负载，我们把js、css、img等静态资源分离到另一个独立域名的服务器上，在html页面中再通过相应的标签从不同域名下加载静态资源。动态创建script，再请求一个带参数网址实现跨域通信。 </p></li><li><p><code>CORS跨域</code></p><p>后端修改请求头</p></li><li><p>document.domain + iframe跨域问题</p><blockquote><p>这两个域名必须属于同一个一级域名!而且所用的协议，端口都要一致，否则无法利用document.domain进行跨域。</p></blockquote><p>通过js强制设置document.domain为基础主域，就实现了同域</p></li><li><p>location.hash+iframe</p><p>不同域之间只能通过hash值单向通信，a借助一个辅助页c,再通过与a同域的数据传回，但是会直接暴露在url中，数据容量和类型都有限</p><p>缺陷：只能实现get一种请求不同域只能通过hash值单向通信，b与c也不同域也只能单向通信，但c与a同域，所以c可通过parent.parent访问a页面所有对象。</p></li><li><p>window.name+iframe跨域</p><p>window.name在不同页面（甚至不同域名）加载后依旧存在，并且支持2MB的name值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> proxy = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">url, callback</span>) </span>&#123;<br>    <span class="hljs-keyword">var</span> state = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">var</span> iframe = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">&#x27;iframe&#x27;</span>);<br><br>    <span class="hljs-comment">// 加载跨域页面</span><br>    iframe.src = url;<br><br>    <span class="hljs-comment">// onload事件会触发2次，第1次加载跨域页，并留存数据于window.name</span><br>    iframe.onload = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>        <span class="hljs-keyword">if</span> (state === <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-comment">// 第2次onload(同域proxy页)成功后，读取同域window.name中数据</span><br>            callback(iframe.contentWindow.name);<br>            destoryFrame();<br><br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (state === <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-comment">// 第1次onload(跨域页)成功后，切换到同域代理页面</span><br>            iframe.contentWindow.location = <span class="hljs-string">&#x27;http://www.domain1.com/proxy.html&#x27;</span>;<br>            state = <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;;<br><br>    <span class="hljs-built_in">document</span>.body.appendChild(iframe);<br><br>    <span class="hljs-comment">// 获取数据以后销毁这个iframe，释放内存；这也保证了安全（不被其他域frame js访问）</span><br>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">destoryFrame</span>(<span class="hljs-params"></span>) </span>&#123;<br>        iframe.contentWindow.document.write(<span class="hljs-string">&#x27;&#x27;</span>);<br>        iframe.contentWindow.close();<br>        <span class="hljs-built_in">document</span>.body.removeChild(iframe);<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">// 请求跨域b页面数据</span><br>proxy(<span class="hljs-string">&#x27;http://www.domain2.com/b.html&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">data</span>)</span>&#123;<br>    alert(data);<br>&#125;);<br></code></pre></td></tr></table></figure></li></ul><h5 id="8、RESTful-API"><a href="#8、RESTful-API" class="headerlink" title="8、RESTful API"></a>8、RESTful API</h5><p>REST全称是Representational State Transfer（表征性状态转移）</p><p>RESTful更多的是一种风格，只要符合标准的框架都是RESTful的</p><p>RESTful框架的主要原则</p><ul><li>对网络上所有的资源都有一个资源标志符。</li><li>对资源的操作不会改变标识符。</li><li>同一资源有多种表现形式（xml、json）</li><li>所有操作都是无状态的（Stateless）</li></ul><p>符合上述REST原则的架构方式称为RESTful</p><p>参考链接：<a href="https://blog.csdn.net/x541211190/article/details/81141459">https://blog.csdn.net/x541211190/article/details/81141459</a></p><h5 id="9、CORS跨域资源共享请求分类"><a href="#9、CORS跨域资源共享请求分类" class="headerlink" title="9、CORS跨域资源共享请求分类"></a>9、CORS跨域资源共享请求分类</h5><p><code>简单请求</code>和<code>预检请求</code></p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>javascript,css</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Interview Summary</title>
    <link href="/2020/12/07/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/"/>
    <url>/2020/12/07/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<p>前端面试总结</p><a id="more"></a><h5 id="1、盒子模型"><a href="#1、盒子模型" class="headerlink" title="1、盒子模型"></a>1、盒子模型</h5><p>所有HTML元素可以看作盒子，在CSS中，”box model”这一术语是用来设计和布局时使用。</p><p>CSS盒模型本质上是一个盒子，封装周围的HTML元素，它包括：边距，边框，填充，和实际内容。</p><p>盒模型允许我们在其它元素和周围元素边框之间的空间放置元素。</p><p>不同部分的说明：</p><ul><li><strong>Margin(外边距)</strong> - 清除边框外的区域，外边距是透明的。</li><li><strong>Border(边框)</strong> - 围绕在内边距和内容外的边框。</li><li><strong>Padding(内边距)</strong> - 清除内容周围的区域，内边距是透明的。</li><li><strong>Content(内容)</strong> - 盒子的内容，显示文本和图像。</li></ul><h5 id="2、https加密"><a href="#2、https加密" class="headerlink" title="2、https加密"></a>2、https加密</h5><p>https协议是由http和ssl协议构建的可进行加密传输和身份认证的网络协议，比http协议的安全性更高。</p><p>Https协议需要ca证书，费用较高。https则是具有安全性的ssl加密传输协议。</p><h5 id="3、css实现两栏布局、左边固定、右边自适应"><a href="#3、css实现两栏布局、左边固定、右边自适应" class="headerlink" title="3、css实现两栏布局、左边固定、右边自适应"></a>3、css实现两栏布局、左边固定、右边自适应</h5><p><a href="https://segmentfault.com/a/1190000010698609">https://segmentfault.com/a/1190000010698609</a></p><h5 id="4、vue与react的区别"><a href="#4、vue与react的区别" class="headerlink" title="4、vue与react的区别"></a>4、vue与react的区别</h5><p><a href="https://blog.csdn.net/qq_37617413/article/details/90669216">https://blog.csdn.net/qq_37617413/article/details/90669216</a></p><h5 id="5、vue的双向绑定原理"><a href="#5、vue的双向绑定原理" class="headerlink" title="5、vue的双向绑定原理"></a>5、vue的双向绑定原理</h5><p>vue的数据双向绑定主要通过Object.defineProperty()方法来进行数据劫持以及发布者-订阅模式来实现的，</p><ul><li>具体怎么实现的呢？</li></ul><p>要想实现数据的双向绑定首先就要通过数据拦截来进行监听数据的改变，这个时候就要设置一个监听器Observer来进行监听，如果属性发生改变的话就告诉订阅者Watcher看看是否需要改变，同时的话订阅者可以有好多个，我们就用一个订阅者管理器(Dep)来管理这些订阅者。紧接着我们还要有个指令解析器来对每个节点进行扫描和解析（解析节点的指令如v-on）,把他们初始化成一个订阅器Watcher,并且绑定相应的函数，Watcher会对比前后两个的数值是否发生变化，然后确定是否通知视图进行重新渲染；</p><h5 id="6、vuex的核心属性"><a href="#6、vuex的核心属性" class="headerlink" title="6、vuex的核心属性"></a>6、vuex的核心属性</h5><ul><li>state:vuex的基本数据，提供唯一 的公共数据源，所有共享的数据都要统一放在store中的state中，使用单一状态树，包含我们所需要的基本状态参数</li><li>getter：相当于State的计算属性</li><li>mutation:更新数据的方法，同步方式</li><li>action:功能和mutaion大致相同，action是通过提交mutation来更改状态。</li><li>module:整个store对象集中到一个很大的对象，将store分割到很多模块，使得每个模块拥有自己的属性</li></ul><h5 id="7、box-sizing的使用场景"><a href="#7、box-sizing的使用场景" class="headerlink" title="7、box-sizing的使用场景"></a>7、box-sizing的使用场景</h5><p>首先盒子模型：ie盒子模型和标准W3C盒子模型</p><ul><li>标准盒子模型：width=content  height=content</li><li>ie盒子模型：width=margin+border+padding+content</li></ul><p>1、考虑到盒子的大小设置会比较麻烦，有时设置的width，结果最后大小不是之前设置的大小，所以这时就要box-sizing登场了，当我们设置box-sizing:border-box以后，如果我们想要一个宽度100的盒子，直接设置width为100，就不用考虑该盒子是否为标准盒子了。这是box-sizing最实用的一个属性。等于：siting-width=border+padding+content-width;（为元素设定的宽度和高度决定了元素的边框盒。就是说，为元素指定的任何内边距和边框都将在已设定的宽度和高度内进行绘制。通过从已设定的宽度和高度分别减去边框和内边距才能得到内容的宽度和高度）</p><p>2、当box-sizing设置成content-box后，等于标准情况：siting-width=conten-width;（在宽度和高度之外绘制元素的内边距和边框。）</p><h5 id="8、弹性flex布局"><a href="#8、弹性flex布局" class="headerlink" title="8、弹性flex布局"></a>8、弹性flex布局</h5><p>给予容器控制内部元素高度和宽度的能力。</p><p>在webkit内核的浏览器使用时，必须加上**-webkit-**前缀</p><ul><li>Google Chrome 谷歌浏览器</li><li>Safari浏览器</li><li>搜狗高速浏览器</li><li>遨游浏览器3</li><li>QQ浏览器</li><li>360极速浏览器</li><li>世界之窗浏览器</li><li>阿里云浏览器</li></ul><p>使用flex的容器，它内部的元素自动成为flex项目。容器拥有两根隐形的轴，水平的主轴和竖直的交叉轴，主轴与左边框的交点为main start,主轴与右边框的交点为main end,交叉轴的起点为cross start,交叉轴结束的位置成位cross end,项目的主轴宽度为main size,交叉轴方向上的宽度为cross size.同时flex item的float、clear、vertical-align属性将失效。</p><p>felx的相关的示意图见下链：</p><p><a href="https://images2015.cnblogs.com/blog/1008386/201608/1008386-20160829212313605-763604383.png">https://images2015.cnblogs.com/blog/1008386/201608/1008386-20160829212313605-763604383.png</a></p><ul><li><p>容器的属性</p><ol><li><p>flex-direction:</p><ul><li>row:主轴为水平方向，项目沿主轴从左至右排列</li><li>column:主轴为竖直方向，项目沿主轴从上至下排列</li><li>row-reverse:主轴水平，项目从右至左排列，与row反向</li><li>column-reverse:主轴竖直，项目从下至上排列，与column反向</li></ul></li><li><p>flex-wrap</p><ul><li>nowrap:自动缩小项目，不换行</li><li>wrap:换行，且第一行在上方</li><li>wrap-reverse:换行，第一行在下面</li></ul></li><li><p>flex-flow</p><p>  是flex-direction和flex-wrap的简写形式，有row wrap|column wrap-reverse等, 默认值为row nowrap</p></li><li><p>justify-content</p><p>决定item在主轴上的对齐方式，可能的值有flex-start(默认）</p><ul><li>flex-start:左对齐</li><li>flex-end:右对齐</li><li>center:居中对齐</li><li>space-between:两端对齐</li><li>space-around:沿轴线均匀分布</li></ul></li><li><p>align-items</p><p>决定item在交叉轴上的对齐方式</p><ul><li>flex-start:顶端对齐</li><li>flex-end:底部对齐</li><li>center:竖直方向上居中对齐</li><li>baseline:item第一行文字的底部对齐</li><li>stretch:当item未设置高度时，item将和容器等高对齐</li></ul></li><li><p>align-content</p><p>该属性定义了当有很多根主轴时，即item不止一行时，多行在交叉轴轴上的对齐方式。注意当有多行时，align-items属性将失效</p><ul><li>flex-start:左对齐</li><li>flex-end:右对齐</li><li>center:居中对齐</li><li>space-between:两端对齐</li><li>space-around:沿轴线均匀分布</li></ul></li></ol></li><li><p>项目属性</p><ol><li><p>order</p><p>order的值越小，项目排列越靠前</p></li><li><p>flex-grow</p><p>定义了当flex容器有多余空间时，item是否放大。默认值为0，即当有多余空间时也不放大，数值为对应的项目的放大比列。</p></li><li><p>flex-shrink</p><p>定义了当容器空间不足时，item是否缩小。默认值为1，当空间不足时，项目自动缩小。其可能的值为整数，表示不同的项目的缩小比例</p></li><li><p>flex-basis</p><p>表示项目的主轴占据的空间，默认值为auto。</p></li><li><p>flex</p><p>属性是flex-grow、flex-shrink和flex-basis三属性的简写总和</p></li><li><p>align-self</p><ul><li><p>auto: 和父元素align-self的值一致</p></li><li><p>flex-start:顶端对齐</p></li><li><p>flex-end:底部对齐</p></li><li><p>center:竖直方向上居中对齐</p></li><li><p>baseline: 项目的第一行文字的底部对齐</p></li><li><p>stretch: 当项目未设置高度时，item将和容器等高对齐</p><p>【参考链接】：<a href="https://www.cnblogs.com/nuannuan7362/p/5823381.html">https://www.cnblogs.com/nuannuan7362/p/5823381.html</a></p></li></ul></li></ol></li></ul><h5 id="9、什么是闭包"><a href="#9、什么是闭包" class="headerlink" title="9、什么是闭包"></a>9、什么是闭包</h5><p><strong>「函数」和「函数内部能访问到的变量」（也叫环境）的总和，就是一个闭包。</strong></p><p>希望能够把变量给隐藏了。</p><p>参考链接：<a href="https://zhuanlan.zhihu.com/p/22486908">https://zhuanlan.zhihu.com/p/22486908</a></p><h5 id="10、箭头函数和普通函数"><a href="#10、箭头函数和普通函数" class="headerlink" title="10、箭头函数和普通函数"></a>10、箭头函数和普通函数</h5><p>箭头函数本身没用prototype所以箭头函数本身没用this</p><p>箭头函数的this永远指向其上下文，call()、bind()、apply()改变不了其this的指向</p><p>普通函数的this指向调用它的那个对象</p><p>箭头函数相当于一个匿名函数，不能作为构造函数，不能new</p><p>箭头函数对比：<a href="https://www.cnblogs.com/shamszhang/p/10530298.html">https://www.cnblogs.com/shamszhang/p/10530298.html</a></p><h5 id="11、flex-1代表什么"><a href="#11、flex-1代表什么" class="headerlink" title="11、flex:1代表什么"></a>11、flex:1代表什么</h5><p><a href="https://zhuanlan.zhihu.com/p/136223806">https://zhuanlan.zhihu.com/p/136223806</a></p><h5 id="12、什么是BFC，如何清除浮动"><a href="#12、什么是BFC，如何清除浮动" class="headerlink" title="12、什么是BFC，如何清除浮动"></a>12、什么是BFC，如何清除浮动</h5><p>Block formatting context 块级格式上下文，它是一个独立的渲染区域。具有BDC特性的元素可以看作是隔离的独立容器，容器里的元素不会在布局上影响到外面的元素，并且BFC具有普通容器所没用的一些特性。</p><p>清除浮动：<a href="https://blog.csdn.net/h_qingyi/article/details/81269667">https://blog.csdn.net/h_qingyi/article/details/81269667</a></p><p>clear:both   overflow:hidden</p><p> 都不如双伪元素清除浮动,不仅可以清除浮动，也可以解决高度坍塌的问题。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.clearfix</span><span class="hljs-selector-pseudo">:before</span>,<br><span class="hljs-selector-class">.clearfix</span><span class="hljs-selector-pseudo">:after</span> &#123;<br>    <span class="hljs-attribute">display</span>: table;<br>    <span class="hljs-attribute">content</span>: <span class="hljs-string">&quot;&quot;</span>;    <span class="hljs-comment">/*不用有内容也可以*/</span><br>&#125;<br><br><span class="hljs-selector-class">.clearfix</span><span class="hljs-selector-pseudo">:after</span> &#123;<br>    <span class="hljs-attribute">clear</span>: both;<br>&#125;<br><br><span class="hljs-selector-class">.clearfix</span> &#123;<br>    <span class="hljs-attribute">*zoom</span>: <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>BFC: <a href="https://zhuanlan.zhihu.com/p/25321647">https://zhuanlan.zhihu.com/p/25321647</a></p><h5 id="13、控制元素显示和隐藏的两种方法"><a href="#13、控制元素显示和隐藏的两种方法" class="headerlink" title="13、控制元素显示和隐藏的两种方法"></a>13、控制元素显示和隐藏的两种方法</h5><ul><li>方法一</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&quot;EleId&quot;</span>).style.visibility=<span class="hljs-string">&quot;hidden&quot;</span>;<br><span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&quot;EleId&quot;</span>).style.visibility=<span class="hljs-string">&quot;visible&quot;</span>;<br></code></pre></td></tr></table></figure><ul><li>方法二</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&quot;EleId&quot;</span>).style.display=<span class="hljs-string">&quot;none&quot;</span>;<br><span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&quot;EleId&quot;</span>).style.display=<span class="hljs-string">&quot;inline&quot;</span>;<br></code></pre></td></tr></table></figure><h5 id="14、防抖和节流"><a href="#14、防抖和节流" class="headerlink" title="14、防抖和节流"></a>14、防抖和节流</h5><p>防抖和节流都是为了解决短时间内大量触发某函数而导致的性能问题。</p><p>手写防抖实例代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">debounce</span>(<span class="hljs-params">func, wait</span>) </span>&#123;<br>    <span class="hljs-keyword">let</span> timeout = <span class="hljs-literal">null</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>        <span class="hljs-keyword">let</span> context = <span class="hljs-built_in">this</span><br>        <span class="hljs-keyword">let</span> args = <span class="hljs-built_in">arguments</span><br>        <span class="hljs-keyword">if</span> (timeout) <span class="hljs-built_in">clearTimeout</span>(timeout)<br>        timeout = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>            func.apply(context, args) <br>        &#125;, wait)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>节流实例代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">throttle</span>(<span class="hljs-params">fn, wait</span>) </span>&#123;<br>    <span class="hljs-keyword">let</span> prev = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123; <br>        <span class="hljs-keyword">const</span> args = <span class="hljs-built_in">arguments</span>;<br>        <span class="hljs-keyword">const</span> now = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>();<br>        <span class="hljs-keyword">if</span> (now - prev &gt; wait) &#123;<br>            fn.apply(<span class="hljs-built_in">this</span>, args);<br>            prev = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>();<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><h5 id="15、promise、事件循环机制、输出什么，以及原理是什么，event-loop解析"><a href="#15、promise、事件循环机制、输出什么，以及原理是什么，event-loop解析" class="headerlink" title="15、promise、事件循环机制、输出什么，以及原理是什么，event  loop解析"></a>15、promise、事件循环机制、输出什么，以及原理是什么，event  loop解析</h5><p><a href="https://blog.csdn.net/vampire10086/article/details/107403506">https://blog.csdn.net/vampire10086/article/details/107403506</a></p><p><a href="https://www.cnblogs.com/tangjianqiang/p/13470363.html">https://www.cnblogs.com/tangjianqiang/p/13470363.html</a></p><p><a href="https://www.cnblogs.com/wxcbg/p/11040362.html">https://www.cnblogs.com/wxcbg/p/11040362.html</a></p><h5 id="16、ES6的新特性，手写Promise、Promise-all、Promise-race"><a href="#16、ES6的新特性，手写Promise、Promise-all、Promise-race" class="headerlink" title="16、ES6的新特性，手写Promise、Promise.all、Promise.race"></a>16、ES6的新特性，手写Promise、Promise.all、Promise.race</h5><p><a href="https://blog.csdn.net/weixin_44141866/article/details/106028210">https://blog.csdn.net/weixin_44141866/article/details/106028210</a></p><h5 id="17、post和get的区别"><a href="#17、post和get的区别" class="headerlink" title="17、post和get的区别"></a>17、post和get的区别</h5><ul><li>GET在浏览器回退时是无害的，而POST会再次提交请求。</li><li>GET产生的URL地址可以被Bookmark，而POST不可以。 </li><li>GET请求会被浏览器主动cache，而POST不会，除非手动设置。</li><li>GET请求只能进行url编码，而POST支持多种编码方式。</li><li>GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留。</li><li>GET请求在URL中传送的参数是有长度限制的，而POST么有。</li><li>对参数的数据类型，GET只接受ASCII字符，而POST没有限制。</li><li>GET比POST更不安全，因为参数直接暴露在URL上，所以不能用来传递敏感信息。</li></ul><p>参考链接：<a href="https://www.cnblogs.com/logsharing/p/8448446.html">https://www.cnblogs.com/logsharing/p/8448446.html</a></p><h5 id="18、call-、apply-、bind-方法的区别"><a href="#18、call-、apply-、bind-方法的区别" class="headerlink" title="18、call()、apply()、bind()方法的区别"></a>18、call()、apply()、bind()方法的区别</h5><p>call和apply都是为了改变某个函数运行时的上下文，改变函数体内部this指针</p><p>call把参数按顺序传递进去，apply是把参数放在数组里。</p><p>bind 是返回对应函数,便于稍后调用;apply 、call 则是立即调用 。</p><p><a href="https://segmentfault.com/a/1190000018270750">https://segmentfault.com/a/1190000018270750</a></p><h5 id="19、什么是事件委托？"><a href="#19、什么是事件委托？" class="headerlink" title="19、什么是事件委托？"></a>19、什么是事件委托？</h5><p>事件代理（Event Delegation），又称之为事件委托。是 JavaScript 中常用绑定事件的常用技巧。顾名思义，“事件代理”即是把原本需要绑定的事件委托给父元素，让父元素担当事件监听的职务。</p><p>为什么要这么做？众所周知，DOM操作是十分消耗性能的，所以重复的事件绑定简直是性能杀手。而事件代理的核心思想，就是通过尽量少的绑定，去监听尽量多的事件。</p><h5 id="20、defer和async的区别"><a href="#20、defer和async的区别" class="headerlink" title="20、defer和async的区别"></a>20、defer和async的区别</h5><p>当浏览器碰到script脚本，没用deffer和async，浏览器会立刻加载并执行指定的脚本</p><p>有async加载和渲染后续文档元素的过程将和script.js的加载与执行并行进行（异步）</p><p>有defer，加载后续文档元素的过程将和script.js的加载并行进行异步</p><p>示例图链接：<a href="https://segmentfault.com/img/bVWhRl?w=801&amp;h=814/view">https://segmentfault.com/img/bVWhRl?w=801&amp;h=814/view</a></p><h5 id="21、keep-alive"><a href="#21、keep-alive" class="headerlink" title="21、keep-alive"></a>21、keep-alive</h5><p><a href="https://www.cnblogs.com/sysuhanyf/p/7454530.html">https://www.cnblogs.com/sysuhanyf/p/7454530.html</a></p><h5 id="22、http状态码"><a href="#22、http状态码" class="headerlink" title="22、http状态码"></a>22、http状态码</h5><table><thead><tr><th align="left">分类</th><th align="left">分类描述</th></tr></thead><tbody><tr><td align="left">1**</td><td align="left">信息，服务器收到请求，需要请求者继续执行操作</td></tr><tr><td align="left">2**</td><td align="left">成功，操作被成功接收并处理</td></tr><tr><td align="left">3**</td><td align="left">重定向，需要进一步的操作以完成请求</td></tr><tr><td align="left">4**</td><td align="left">客户端错误，请求包含语法错误或无法完成请求</td></tr><tr><td align="left">5**</td><td align="left">服务器错误，服务器在处理请求的过程中发生了错误</td></tr></tbody></table><p>​                                                        Http状态码分类</p><table><thead><tr><th align="left">状态码</th><th align="left">状态码英文名称</th><th align="left">中文描述</th></tr></thead><tbody><tr><td align="left">100</td><td align="left">Continue</td><td align="left">继续。<a href="http://www.dreamdu.com/webbuild/client_vs_server/">客户端</a>应继续其请求</td></tr><tr><td align="left">101</td><td align="left">Switching Protocols</td><td align="left">切换协议。服务器根据客户端的请求切换协议。只能切换到更高级的协议，例如，切换到HTTP的新版本协议</td></tr><tr><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">200</td><td align="left">OK</td><td align="left">请求成功。一般用于GET与POST请求</td></tr><tr><td align="left">201</td><td align="left">Created</td><td align="left">已创建。成功请求并创建了新的资源</td></tr><tr><td align="left">202</td><td align="left">Accepted</td><td align="left">已接受。已经接受请求，但未处理完成</td></tr><tr><td align="left">203</td><td align="left">Non-Authoritative Information</td><td align="left">非授权信息。请求成功。但返回的meta信息不在原始的服务器，而是一个副本</td></tr><tr><td align="left">204</td><td align="left">No Content</td><td align="left">无内容。服务器成功处理，但未返回内容。在未更新网页的情况下，可确保浏览器继续显示当前文档</td></tr><tr><td align="left">205</td><td align="left">Reset Content</td><td align="left">重置内容。服务器处理成功，用户终端（例如：浏览器）应重置文档视图。可通过此返回码清除浏览器的表单域</td></tr><tr><td align="left">206</td><td align="left">Partial Content</td><td align="left">部分内容。服务器成功处理了部分GET请求</td></tr><tr><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">300</td><td align="left">Multiple Choices</td><td align="left">多种选择。请求的资源可包括多个位置，相应可返回一个资源特征与地址的列表用于用户终端（例如：浏览器）选择</td></tr><tr><td align="left">301</td><td align="left">Moved Permanently</td><td align="left">永久移动。请求的资源已被永久的移动到新URI，返回信息会包括新的URI，浏览器会自动定向到新URI。今后任何新的请求都应使用新的URI代替</td></tr><tr><td align="left">302</td><td align="left">Found</td><td align="left">临时移动。与301类似。但资源只是临时被移动。客户端应继续使用原有URI</td></tr><tr><td align="left">303</td><td align="left">See Other</td><td align="left">查看其它地址。与301类似。使用GET和POST请求查看</td></tr><tr><td align="left">==<strong>304</strong>==</td><td align="left">Not Modified</td><td align="left">未修改。所请求的资源未修改，服务器返回此状态码时，不会返回任何资源。客户端通常会缓存访问过的资源，通过提供一个头信息指出客户端希望只返回在指定日期之后修改的资源</td></tr><tr><td align="left">305</td><td align="left">Use Proxy</td><td align="left">使用代理。所请求的资源必须通过代理访问</td></tr><tr><td align="left">306</td><td align="left">Unused</td><td align="left">已经被废弃的HTTP状态码</td></tr><tr><td align="left">307</td><td align="left">Temporary Redirect</td><td align="left">临时重定向。与302类似。使用GET请求重定向</td></tr><tr><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">400</td><td align="left">Bad Request</td><td align="left">客户端请求的语法错误，服务器无法理解</td></tr><tr><td align="left">401</td><td align="left">Unauthorized</td><td align="left">请求要求用户的身份认证</td></tr><tr><td align="left">402</td><td align="left">Payment Required</td><td align="left">保留，将来使用</td></tr><tr><td align="left">403</td><td align="left">Forbidden</td><td align="left">服务器理解请求客户端的请求，但是拒绝执行此请求</td></tr><tr><td align="left">404</td><td align="left">Not Found</td><td align="left">服务器无法根据客户端的请求找到资源（网页）。通过此代码，网站设计人员可设置”您所请求的资源无法找到”的个性页面</td></tr><tr><td align="left">405</td><td align="left">Method Not Allowed</td><td align="left">客户端请求中的方法被禁止</td></tr><tr><td align="left">406</td><td align="left">Not Acceptable</td><td align="left">服务器无法根据客户端请求的内容特性完成请求</td></tr><tr><td align="left">407</td><td align="left">Proxy Authentication Required</td><td align="left">请求要求代理的身份认证，与401类似，但请求者应当使用代理进行授权</td></tr><tr><td align="left">408</td><td align="left">Request Time-out</td><td align="left">服务器等待客户端发送的请求时间过长，超时</td></tr><tr><td align="left">409</td><td align="left">Conflict</td><td align="left">服务器完成客户端的 PUT 请求时可能返回此代码，服务器处理请求时发生了冲突</td></tr><tr><td align="left">410</td><td align="left">Gone</td><td align="left">客户端请求的资源已经不存在。410不同于404，如果资源以前有现在被永久删除了可使用410代码，网站设计人员可通过301代码指定资源的新位置</td></tr><tr><td align="left">411</td><td align="left">Length Required</td><td align="left">服务器无法处理客户端发送的不带Content-Length的请求信息</td></tr><tr><td align="left">412</td><td align="left">Precondition Failed</td><td align="left">客户端请求信息的先决条件错误</td></tr><tr><td align="left">413</td><td align="left">Request Entity Too Large</td><td align="left">由于请求的实体过大，服务器无法处理，因此拒绝请求。为防止客户端的连续请求，服务器可能会关闭连接。如果只是服务器暂时无法处理，则会包含一个Retry-After的响应信息</td></tr><tr><td align="left">414</td><td align="left">Request-URI Too Large</td><td align="left">请求的URI过长（URI通常为网址），服务器无法处理</td></tr><tr><td align="left">415</td><td align="left">Unsupported Media Type</td><td align="left">服务器无法处理请求附带的媒体格式</td></tr><tr><td align="left">416</td><td align="left">Requested range not satisfiable</td><td align="left">客户端请求的范围无效</td></tr><tr><td align="left">417</td><td align="left">Expectation Failed</td><td align="left">服务器无法满足Expect的请求头信息</td></tr><tr><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">500</td><td align="left">Internal Server Error</td><td align="left">服务器内部错误，无法完成请求</td></tr><tr><td align="left">501</td><td align="left">Not Implemented</td><td align="left">服务器不支持请求的功能，无法完成请求</td></tr><tr><td align="left">502</td><td align="left">Bad Gateway</td><td align="left">作为网关或者代理工作的服务器尝试执行请求时，从远程服务器接收到了一个无效的响应</td></tr><tr><td align="left">503</td><td align="left">Service Unavailable</td><td align="left">由于超载或系统维护，服务器暂时的无法处理客户端的请求。延时的长度可包含在服务器的Retry-After头信息中</td></tr><tr><td align="left">504</td><td align="left">Gateway Time-out</td><td align="left">充当网关或代理的服务器，未及时从远端服务器获取请求</td></tr><tr><td align="left">505</td><td align="left">HTTP Version not supported</td><td align="left">服务器不支持请求的HTTP协议的版本，无法完成处理</td></tr></tbody></table><h5 id="23、Promise的原理"><a href="#23、Promise的原理" class="headerlink" title="23、Promise的原理"></a>23、Promise的原理</h5><p><code>Promise</code>的规范很多,ES6采用的<code>Promise/A+</code>规范</p><p>Promise的状态包括：pedding、fulfilled、rejected三种状态，并且只能由pedding转变为fulfillde或者rejected,而且仅能改变一次。</p><p>当执行完resolve()的时候，状态会随之改变为reject。</p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>javascript,css</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
