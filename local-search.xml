<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title></title>
    <link href="/2020/12/30/%E5%8C%97%E4%BA%AC%E5%AE%87%E4%BF%A1%E7%A7%91%E6%8A%80%E9%9B%86%E5%9B%A2%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/"/>
    <url>/2020/12/30/%E5%8C%97%E4%BA%AC%E5%AE%87%E4%BF%A1%E7%A7%91%E6%8A%80%E9%9B%86%E5%9B%A2%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/</url>
    
    <content type="html"><![CDATA[<hr><p>title:北京宇信科技集团前端面试<br>tag:面经总结<br>catgory:面经总结</p><hr><a id="more"></a><p>我今天本来是很凌乱的在写代码，去为字节准备。然后我又收到了拼多多的笔试，我裂开了，就在我考完试的一个小时后，还不能换时间，然后，就在做职业性格测试的时候，突然一个北京的电话，我想起了是之前在双选会上投的前端岗位，然后经典开局。</p><h5 id="1、自我介绍"><a href="#1、自我介绍" class="headerlink" title="1、自我介绍"></a>1、自我介绍</h5><h5 id="2、看到你的项目使用到了vuex，能介绍一下vuex"><a href="#2、看到你的项目使用到了vuex，能介绍一下vuex" class="headerlink" title="2、看到你的项目使用到了vuex，能介绍一下vuex"></a>2、看到你的项目使用到了vuex，能介绍一下vuex</h5><p>vuex是做状态管理的，而且核心熟悉如下：</p><ul><li>state:vuex的基本数据，提供唯一 的公共数据源，所有共享的数据都要统一放在store中的state中，使用单一状态树，包含我们所需要的基本状态参数</li><li>getter：相当于State的计算属性</li><li>mutation:更新数据的方法，同步方式</li><li>action:功能和mutaion大致相同，action是通过提交mutation来更改状态。</li><li>module:整个store对象集中到一个很大的对象，将store分割到很多模块，使得每个模块拥有自己的属性</li></ul><h5 id="3、看到你用过ElementUI和iview说说主要有些啥组件？"><a href="#3、看到你用过ElementUI和iview说说主要有些啥组件？" class="headerlink" title="3、看到你用过ElementUI和iview说说主要有些啥组件？"></a>3、看到你用过ElementUI和iview说说主要有些啥组件？</h5><p>ElementUI:</p><ul><li><p>Layout布局</p><ul><li>Container布局容器</li><li>Color色彩</li><li>Typography字体</li><li>Border 边框</li><li>Icon 图标</li><li>Button 按钮</li><li>Link 文字链接</li></ul></li><li><p>Form</p><ul><li>Radio 单选框</li><li>Checkbox 多选框</li><li>Input 输入框</li><li>InputNumber 计数器</li><li>Select 选择器</li><li>Cascader 级联选择器</li><li>Switch 开关</li><li>Slider 滑块</li><li>TimePicker 时间选择器</li><li>DatePicker 日期选择器</li><li>DateTimePicker 日期时间选择器</li><li>Upload 上传</li><li>Rate 评分</li><li>ColorPicker 颜色选择器</li><li>Transfer 穿梭框</li><li>Form 表单</li></ul></li><li><p>Data</p><ul><li>Table表格</li><li>Tag标签</li><li>Progress进度条</li><li>Tree 树形控件</li><li>Pagination 分页</li><li>Badge 标记</li><li>Avatar 头像</li></ul></li><li><p>Notice</p><ul><li>Alert 警告</li><li>Loading 加载</li><li>Message 消息提示</li><li>MessageBox 弹框</li><li>Notification 通知</li></ul></li><li><p>Navigation</p><ul><li>NavMenu 导航菜单</li><li>Tabs 标签页</li><li>Breadcrumb 面包屑</li><li>PageHeader 页头</li><li>DropDown 下拉菜单</li><li>Steps 步骤条</li></ul></li><li><p>Others</p><ul><li>Dialog 对话框</li><li>Tooltip 文字提示</li><li>Popover 弹出框</li><li>Popconfirm 气泡确认框</li><li>Card 卡片</li><li>Carousel 走马灯</li><li>Collapse 折叠面板</li><li>Timeline 时间线</li><li>Divider 分割线</li><li>Calendar 日历</li><li>Backtop回到顶部</li><li>InfiniteScroll 无限滚动</li><li>Drawer抽屉</li></ul><p>iview不罗列了，去官网看吧：<a href="http://v1.iviewui.com/docs/introduce">http://v1.iviewui.com/docs/introduce</a></p></li></ul><h5 id="4、对Vue的命令知道多少"><a href="#4、对Vue的命令知道多少" class="headerlink" title="4、对Vue的命令知道多少?"></a>4、对Vue的命令知道多少?</h5><ul><li><p>v-text:用于操作纯文本，它会替代显示对应的数据对象上的值。当绑定的数据对象上的值发生改变，插值处的内容也会随之更新。注意：此处为单向绑定，数据 对象上的值改变，插值会发生变化；但是当插值发生变化并不会影响数据对象的值。其中：v-text可以简写为<code>&#123;%&#123;&#125;%&#125;</code>，并且支持逻辑运算。</p></li><li><p>v-html ：用于输出html，它与v-text区别在于v-text输出的是纯文本，浏览器不会对其再进行html解析，但v-html会将其当html标签解析后输出。</p></li><li><p>v-model:通常用于表单组件的绑定，例如input、select等。它与v-text的区别在于它实现的表单组件的双向绑定，如果用于表单控件以外的标签是没用的。</p></li><li><p>v-if:如果v-if=”true”显示v-if的内容，否则显示v-else的内容</p><p>注：<strong>v-if和v-show的作用都把内容显示和隐藏，不同的是，v-if在元素隐藏的时候，是把整个DOM元素删除，v-show知识在DOM元素上添加一个样式，把内容隐藏起来。频繁切换用v-show</strong></p></li><li><p>v-show：把v-show=”true”的内容显示出来。</p></li><li><p>v-else:当v-if=“false”的时候显示v-else的内容。</p></li><li><p>v-on:监听元素事件，并执行相应的操作，v-on可以绑定多个事件。</p></li><li><p>v-bind:绑定元素的熟悉并执行相应的操作</p></li></ul><h5 id="5、那v-bind具体呢？"><a href="#5、那v-bind具体呢？" class="headerlink" title="5、那v-bind具体呢？"></a>5、那v-bind具体呢？</h5><p>v-bind 主要用于属性绑定，比如你的class属性、style属性、value属性、href属性，只要是属性都可以用v-bind指令进行绑定。</p><p>如果我们绑定了class，可以动态的切换class</p><h5 id="5、vue的传值"><a href="#5、vue的传值" class="headerlink" title="5、vue的传值"></a>5、vue的传值</h5><ul><li><p>props/$emit（父-&gt;子）</p><p>在父组件的data中定义一个数据，可以在子组件中使用props来接受</p></li><li><p>事件传递（子-&gt;父）</p><p>在子组件中通过事件，将方法绑定，然后在methods中，完成自定义事件</p><p>在父组件中，通过v-on:自定义事件=函数 并将此函数在method中实现</p></li><li><p>创建一个空的vue实例作为中央事件总线</p><p>通过事件绑定这个自定义事件，通过Event(刚才创建的空实例).emit(自定义事件，传递数据)，同理在需要传递到的组件中，使用Event.$on(自定义事件，数据=&gt; function)</p></li><li><p>vuex</p><p>如果项目大了，使用上面这个方面会显得不易于管理，可以采用vuex作为状态管理方法。vuex实现了一个单向数据流，在全局拥有一个State来存放数据。设置为严格模式时，确保state中的值只能在mutations中被修改。getter是State的计算属性。action和mutation类似，是对异步的函数写入这里，以保证mutaions来仅同步实现。module是为了放在一个state显得冗杂，可以module嵌套，每个module都有自己的属性。</p></li></ul><h5 id="6、未来的职业规划"><a href="#6、未来的职业规划" class="headerlink" title="6、未来的职业规划"></a>6、未来的职业规划</h5><p>抱歉没有标准答案，母鸡，瞎掰。</p><p>然后她就说之后通知hr联系我，可能会有老板面？公司规模不大？不知道，在智联的上面看到公司规模1000人，小公司吧，就一面，后面没用技术面了，就这样吧，随便练练手，第一感觉压力不大，哈哈哈，hr小姐姐人挺好的，说没事，当聊天就好了。体验还不错，拿不拿offer无所谓了，感觉没咋学，就随便面面，攒攒人品。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2020/12/30/%E5%AD%97%E8%8A%82%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87day2/"/>
    <url>/2020/12/30/%E5%AD%97%E8%8A%82%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87day2/</url>
    
    <content type="html"><![CDATA[<hr><p>title:为字节准备day2<br>tag:面试准备<br>catgory:面试准备</p><hr><a id="more"></a><h5 id="1、快速排序"><a href="#1、快速排序" class="headerlink" title="1、快速排序"></a>1、快速排序</h5><p>怎么说手写算法都得来，那咱们来练两道算法题，先练个快排，经典操作要娴熟</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">quickSort</span>(<span class="hljs-params">arr, i, j</span>) </span>&#123;<br>    <span class="hljs-keyword">if</span> (i &lt; j) &#123;<br>        <span class="hljs-keyword">let</span> left = i;<br>        <span class="hljs-keyword">let</span> right = j;<br>        <span class="hljs-keyword">let</span> pivot = arr[left];<br>        <span class="hljs-keyword">while</span> (i &lt; j) &#123;<br>            <span class="hljs-keyword">while</span> (arr[j] &gt;= pivot &amp;&amp; i &lt; j) &#123;      <span class="hljs-comment">//从后往前找比基数小的数</span><br>                j--;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(i &lt; j)&#123;<br>                arr[i++] = arr[j];<br>            &#125;<br>            <span class="hljs-keyword">while</span> (arr[i] &lt;= pivot &amp;&amp; i &lt; j) &#123;<br>                i++;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (i &lt; j) &#123;<br>                arr[j--] = arr[i];<br>            &#125;<br>        &#125;<br>        arr[i] = pivot;<br>        quickSort(arr, left, i - <span class="hljs-number">1</span>);<br>        quickSort(arr, i + <span class="hljs-number">1</span>, right);<br>        <span class="hljs-keyword">return</span> arr;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>居然写错了两次才改过来，看来手写真的很有必要，不要纸上谈兵了(此处骂自己)。</p><p>第一次采用c++的习惯思路写错， 改过来了。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">quickSort</span>(<span class="hljs-params">arr, i, j</span>) </span>&#123;<br>    <span class="hljs-keyword">if</span> (i &lt; j) &#123;<br>        <span class="hljs-keyword">let</span> left = i;<br>        <span class="hljs-keyword">let</span> right = j;<br>        <span class="hljs-keyword">let</span> pivot = arr[left];<br>        <span class="hljs-keyword">while</span> (i &lt; j) &#123;<br>            <span class="hljs-keyword">while</span> (arr[j] &gt;= pivot &amp;&amp; i &lt; j) &#123;      <span class="hljs-comment">//从后往前找比基数小的数</span><br>                j--;<br>            &#125;<br>            <span class="hljs-keyword">while</span> (arr[i] &lt;= pivot &amp;&amp; i &lt; j) &#123;      <span class="hljs-comment">//从前往后找比基数大的数</span><br>                i++;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(i&lt;j)&#123;<br>            <span class="hljs-keyword">let</span> temp = arr[i];<br>            arr[i] = arr[j];<br>            arr[j] = temp;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">let</span> temp = arr[left];<br>        arr[left] = arr[i];<br>        arr[i] = temp;<br>        quickSort(arr, left, i - <span class="hljs-number">1</span>);<br>        quickSort(arr, i + <span class="hljs-number">1</span>, right);<br>        <span class="hljs-keyword">return</span> arr;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">var</span> arr = [<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">36</span>,<span class="hljs-number">23</span>,<span class="hljs-number">6</span>,<span class="hljs-number">23</span>,<span class="hljs-number">64</span>,<span class="hljs-number">5</span>,<span class="hljs-number">7</span>,<span class="hljs-number">0</span>,<span class="hljs-number">2</span>,<span class="hljs-number">6</span>,<span class="hljs-number">24</span>]<br><span class="hljs-built_in">console</span>.log(quickSort(arr,<span class="hljs-number">0</span>,arr.length-<span class="hljs-number">1</span>))<br></code></pre></td></tr></table></figure><p>但是我搞明白后，更倾向于第一种方法，不许要借助额外空间，好像交换次数也少了一半。</p><h5 id="2、防抖和节流"><a href="#2、防抖和节流" class="headerlink" title="2、防抖和节流"></a>2、防抖和节流</h5><p>这也是前端面试过程中的高频问题。今天也切实的落实一遍，很基础，要会。在前端的查询请求的过程中，防抖的场景：就比如我们是在刷空间这样，他下面刷到底了，但是要加载下一页的时候，这时候用户因为网络啊一些问题，可能会下拉两次，那么在加载页面的时候，跳了很多页面就显得不合适，就需要使用防抖功能，在一段时间内，只执行一次操作。再次操作就重置时间计时。</p><p>节流操作的应用场景：就是类似百度的实时查询，当你在查询框里输入一个字，马上就会有一些东西弹出来了。但是用户有时候在打第一个字和第二个字之间，也打进去很多字符，但是对于这个查询的操作是没有意义的。这时候就没必要每次输入都请求服务器。这样会对给服务器较大的压力。因此这时候，就需要节流，来保证在一定时间内事件发生，只会响应一次。同时在实现的时候，移动端尽量去使用事件戳来做，设立定时器，对于性能的影响很大。</p><p>下面是手写的代码：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>防抖和节流<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><br><span class="css">        <span class="hljs-selector-class">.content</span>&#123;</span><br><span class="css">            <span class="hljs-selector-tag">height</span><span class="hljs-selector-pseudo">:200px</span>;</span><br><span class="css">            <span class="hljs-selector-tag">width</span><span class="hljs-selector-pseudo">:200px</span>;</span><br><span class="css">            <span class="hljs-selector-tag">border</span><span class="hljs-selector-pseudo">:1px</span> <span class="hljs-selector-tag">blue</span> <span class="hljs-selector-tag">solid</span>;</span><br>        &#125;<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;content&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;content&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span> <br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br><span class="javascript">    <span class="hljs-keyword">let</span> num = <span class="hljs-number">1</span>;</span><br><span class="javascript">    <span class="hljs-keyword">let</span> content = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&quot;content&quot;</span>);</span><br><span class="javascript">    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">count</span>(<span class="hljs-params"></span>)</span>&#123;</span><br>        content.innerHTML = num++;<br>    &#125;<br><span class="javascript">    <span class="hljs-comment">// content.onmousemove = debounce2(count,1000);         //这是用防毒的方式</span></span><br>        content.onmousemove = throttle(count,1000);<br><br><span class="javascript">    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">debounce</span>(<span class="hljs-params">func,wait</span>)</span>&#123;           <span class="hljs-comment">//这是指定时候后执行</span></span><br><span class="javascript">        <span class="hljs-keyword">let</span> timeout; <span class="hljs-comment">//定时器</span></span><br><span class="javascript">        <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;</span><br><span class="javascript">            <span class="hljs-keyword">if</span>(timeout) <span class="hljs-built_in">clearTimeout</span>(timeout);</span><br><span class="javascript">            timeout = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;</span><br><span class="javascript">                func.apply(<span class="hljs-built_in">this</span>); <span class="hljs-comment">//执行查询操作</span></span><br>            &#125;,wait)<br>        &#125;<br>    &#125;<br><span class="javascript">    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">debounce2</span>(<span class="hljs-params">func,wait</span>)</span>&#123;          <span class="hljs-comment">//这里是先执行，然后等时间</span></span><br><span class="javascript">        <span class="hljs-keyword">let</span> timeout;</span><br><span class="javascript">        <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;</span><br><span class="javascript">            <span class="hljs-keyword">if</span>(timeout) <span class="hljs-built_in">clearTimeout</span>(timeout);</span><br><span class="javascript">            <span class="hljs-keyword">let</span> callNow = !timeout;</span><br><span class="javascript">            timeout = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">()=&gt;</span>&#123;</span><br><span class="javascript">                timeout = <span class="hljs-literal">null</span>;</span><br>            &#125;,wait);<br><span class="javascript">            <span class="hljs-keyword">if</span>(callNow) func.apply(<span class="hljs-built_in">this</span>);</span><br>        &#125;<br>    &#125;<br><span class="javascript">    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">throttle</span>(<span class="hljs-params">func,wait</span>)</span>&#123;</span><br><span class="javascript">        <span class="hljs-keyword">let</span> timeout; <span class="hljs-comment">//定义计时器</span></span><br><span class="javascript">        <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;</span><br><span class="javascript">            <span class="hljs-keyword">if</span>(!timeout)&#123;</span><br><span class="javascript">                timeout = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">()=&gt;</span>&#123;</span><br><span class="javascript">                    timeout = <span class="hljs-literal">null</span>;</span><br><span class="javascript">                    func.apply(<span class="hljs-built_in">this</span>);</span><br>                &#125;,wait)<br>            &#125;<br>        &#125;<br>    &#125;<br><span class="javascript">    <span class="hljs-comment">//不能使用timeout的情况下，使用时间戳，性能更好</span></span><br><span class="javascript">    <span class="hljs-comment">//使用时间戳</span></span><br><span class="javascript">    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">throttle2</span>(<span class="hljs-params">func,wait</span>)</span>&#123;</span><br><span class="javascript">        <span class="hljs-keyword">let</span> prev = <span class="hljs-number">0</span>;</span><br><span class="javascript">        <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;</span><br><span class="javascript">            <span class="hljs-keyword">let</span> now = <span class="hljs-built_in">Date</span>.now();</span><br><span class="javascript">            <span class="hljs-keyword">if</span>(now - prev &gt; wait)&#123;</span><br><span class="javascript">                func.apply(<span class="hljs-built_in">this</span>)</span><br>                prev = now;<br>            &#125;<br>        &#125;<br>    &#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">Script</span>&gt;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>为字节准备一个月</title>
    <link href="/2020/12/29/%E5%AD%97%E8%8A%82%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87day1/"/>
    <url>/2020/12/29/%E5%AD%97%E8%8A%82%E9%9D%A2%E8%AF%95%E5%87%86%E5%A4%87day1/</url>
    
    <content type="html"><![CDATA[<a id="more"></a><p>今天接到了字节hr的电话约面，下午连续两次小公司的hr打电话约面试，晚上的时候就收到了字节的电话，本身就很纠结，因为手写代码的次数很少，因此很害怕，所以，这次一个月要落实很多的基础，而且字节一直都是我很向往的公司，标准也很高，因此接下来一个月，我要高标准，严要求自己。保证自己每天都学习，因此，每天都做学习贴，认真准备一个月。接下来主要做一个规划，为了未来的一个月。一定要手写！！一定要是手写！</p><h5 id="Flex布局，实现两个子元素垂直，并一个靠右一个靠左"><a href="#Flex布局，实现两个子元素垂直，并一个靠右一个靠左" class="headerlink" title="Flex布局，实现两个子元素垂直，并一个靠右一个靠左"></a>Flex布局，实现两个子元素垂直，并一个靠右一个靠左</h5><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;parent&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;left&quot;</span>&gt;</span>左子垂直分布<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;right&quot;</span>&gt;</span>右子垂直分布<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><br><span class="css"><span class="hljs-selector-class">.parent</span> &#123;</span><br>    display: flex;<br>    align-items: center;<br>    justify-content: space-between;<br><span class="css">    <span class="hljs-selector-tag">height</span><span class="hljs-selector-pseudo">:400px</span>;</span><br><span class="css">    <span class="hljs-selector-tag">border</span><span class="hljs-selector-pseudo">:1px</span> <span class="hljs-selector-tag">black</span> <span class="hljs-selector-tag">solid</span>;</span><br>&#125;<br><span class="css"><span class="hljs-selector-class">.left</span> &#123;</span><br><span class="css">    <span class="hljs-selector-tag">width</span><span class="hljs-selector-pseudo">:100px</span>;</span><br><span class="css">    <span class="hljs-selector-tag">height</span><span class="hljs-selector-pseudo">:150px</span>;</span><br><span class="css">    <span class="hljs-selector-tag">border</span><span class="hljs-selector-pseudo">:1px</span> <span class="hljs-selector-tag">red</span> <span class="hljs-selector-tag">solid</span>;</span><br>&#125;<br><span class="css"><span class="hljs-selector-class">.right</span> &#123;</span><br><span class="css">    <span class="hljs-selector-tag">width</span><span class="hljs-selector-pseudo">:100px</span>;</span><br><span class="css">    <span class="hljs-selector-tag">height</span><span class="hljs-selector-pseudo">:150px</span>;</span><br><span class="css">    <span class="hljs-selector-tag">border</span><span class="hljs-selector-pseudo">:1px</span> <span class="hljs-selector-tag">green</span> <span class="hljs-selector-tag">solid</span>;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>触类旁通，来练习一手经典居中，实现了其中的四种，剩下的等我有空继续补上，先睡觉惹！</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><span class="hljs-comment">&lt;!-- </span><br><span class="hljs-comment">     垂直居中的组合方式</span><br><span class="hljs-comment">    方法一:display:flex    这个也不错</span><br><span class="hljs-comment">    方法二:绝对定位和负边距   感觉这个方法不错</span><br><span class="hljs-comment">    方法三:绝对定位和为0    和上面的方法殊途同归</span><br><span class="hljs-comment">    方法四：transform</span><br><span class="hljs-comment">--&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Document<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;initial&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;center4&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;center2&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>        <span class="hljs-comment">&lt;!-- &lt;div class=&quot;left&quot;&gt;左子垂直分布&lt;/div&gt; --&gt;</span><br>        <span class="hljs-comment">&lt;!-- &lt;div class=&quot;right&quot;&gt;右子垂直分布&lt;/div&gt; --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;center1&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;center3&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>        <br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><br><span class="css">    <span class="hljs-selector-class">.parent</span> &#123;</span><br>        display: flex;<br>        align-items: center;<br>        justify-content: space-between;<br>        height: 400px;<br>        border: 1px black solid;<br>    &#125;<br><br><span class="css">    <span class="hljs-selector-class">.parentCenter1</span>&#123;</span><br>        display: flex;<br>        align-items: center;<br>        justify-content: center;<br>        height: 400px;<br>        border: 1px black solid;<br>    &#125;<br><br><span class="css">    <span class="hljs-selector-class">.initial</span> &#123;</span><br>        position: absolute;<br>        width: 400px;<br>        height: 400px;<br>        border: 1px black solid;<br>    &#125;<br><br><span class="css">    <span class="hljs-selector-class">.left</span> &#123;</span><br>        width: 100px;<br>        height: 150px;<br>        border: 1px red solid;<br>    &#125;<br><br><span class="css">    <span class="hljs-selector-class">.right</span> &#123;</span><br>        width: 100px;<br>        height: 150px;<br>        border: 1px green solid;<br>    &#125;<br><br><span class="css">    <span class="hljs-selector-class">.center1</span> &#123;</span><br>        position: relative;<br>        margin: -75px auto;<br><span class="css">        <span class="hljs-comment">/* margin: -75px auto 0 auto; */</span></span><br>        top: 50%;<br>        height: 150px;<br>        border: 1px green solid;<br>        width: 100px;<br>    &#125;<br><br><span class="css">    <span class="hljs-selector-class">.center2</span> &#123;</span><br>        opacity: 0.5;<br>        position: absolute;<br>        height: 200px;<br>        width: 200px;<br>        background-color: brown;<br>        top: 50%;<br>        left: 50%;<br>        margin: -100px 0 0 -100px;<br>    &#125;<br><br><span class="css">    <span class="hljs-selector-class">.center3</span> &#123;</span><br>        opacity: 0.3;<br>        position: absolute;<br>        width: 25%;<br>        height: 25%;<br><span class="css">        <span class="hljs-selector-tag">background</span>: <span class="hljs-selector-id">#000</span>;</span><br>        margin: auto;<br>        top: 0;<br>        left: 0;<br>        bottom: 0;<br>        right: 0;<br>    &#125;<br><span class="css">    <span class="hljs-selector-class">.center4</span>&#123;</span><br>        opacity: 0.9;<br>        position: absolute;<br><span class="css">        <span class="hljs-selector-tag">top</span><span class="hljs-selector-pseudo">:50</span>%;</span><br><span class="css">        <span class="hljs-selector-tag">left</span><span class="hljs-selector-pseudo">:50</span>%;</span><br><span class="css">        <span class="hljs-selector-tag">height</span><span class="hljs-selector-pseudo">:30</span>%;</span><br><span class="css">        <span class="hljs-selector-tag">width</span><span class="hljs-selector-pseudo">:30</span>%;</span><br><span class="css">        <span class="hljs-selector-tag">transform</span><span class="hljs-selector-pseudo">:translate(-50</span>%,<span class="hljs-selector-tag">-50</span>%);</span><br><span class="css">        <span class="hljs-selector-tag">background-color</span><span class="hljs-selector-pseudo">:blueviolet</span>;</span><br>    &#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p>参考链接：<a href="https://www.cnblogs.com/mokeycode/p/10635912.html">https://www.cnblogs.com/mokeycode/p/10635912.html</a></p>]]></content>
    
    
    <categories>
      
      <category>面试准备</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面试准备</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>笔试学习贴</title>
    <link href="/2020/12/28/%E7%AC%94%E8%AF%95%E9%97%AE%E9%A2%98/"/>
    <url>/2020/12/28/%E7%AC%94%E8%AF%95%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<p>最近拿到了博思软件校园招聘和拼多多的笔试机会，现在就准备一下</p><h5 id="1、哪个样式定义后，内敛（非块状）元素可以定义宽度和高度"><a href="#1、哪个样式定义后，内敛（非块状）元素可以定义宽度和高度" class="headerlink" title="1、哪个样式定义后，内敛（非块状）元素可以定义宽度和高度"></a>1、哪个样式定义后，内敛（非块状）元素可以定义宽度和高度</h5><p>答案：display:block</p><blockquote><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">display</span>属性 :<br><span class="hljs-selector-tag">block</span> :　<span class="hljs-selector-tag">CSS1</span> 块对象的默认值。将对象强制作为块对象呈递，为对象之后添加新行  可以定义高度和宽度<br><span class="hljs-selector-tag">none</span> :　<span class="hljs-selector-tag">CSS1</span> 隐藏对象。与 <span class="hljs-selector-tag">visibility</span> 属性的<span class="hljs-selector-tag">hidden</span>值不同，其不为被隐藏的对象保留其物理空间<br><span class="hljs-selector-tag">inline</span> :　<span class="hljs-selector-tag">CSS1</span> 内联对象的默认值。将对象强制作为内联对象呈递，从对象中删除行<br><span class="hljs-selector-tag">inline-block</span> :　<span class="hljs-selector-tag">IE5</span>.5 将对象呈递为内联对象，但是对象的内容作为块对象呈递。旁边的内联对象会被呈递在同一行内 <span class="hljs-selector-tag">inherit</span>: 看<span class="hljs-selector-tag">display</span>默认是不具备继承性的，使用<span class="hljs-selector-tag">inherit</span>可以让其继承父对象的<span class="hljs-selector-tag">display</span>属性。<br></code></pre></td></tr></table></figure></blockquote><h5 id="2、新窗口打开网页，用到以下哪个值"><a href="#2、新窗口打开网页，用到以下哪个值" class="headerlink" title="2、新窗口打开网页，用到以下哪个值"></a>2、新窗口打开网页，用到以下哪个值</h5><p>答案：_blank</p><p>在html中通过<code>&lt;a&gt;</code>标签打开一个链接，通过 <code>&lt;a&gt; </code>标签的 target 属性规定在何处打开链接文档。</p><p>如果在标签<code>&lt;a&gt;</code>中写入target属性，则浏览器会根据target的属性值去打开与其命名或名称相符的 框架<code>&lt;frame&gt;</code>或者窗口.</p><p>在target中还存在四个保留的属性值如下，</p><ul><li>属性值</li></ul><table><thead><tr><th align="left">值</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">_blank</td><td align="left">在新窗口中打开被链接文档。</td></tr><tr><td align="left">_self</td><td align="left">默认。在相同的框架中打开被链接文档。</td></tr><tr><td align="left">_parent</td><td align="left">在父框架集中打开被链接文档。</td></tr><tr><td align="left">_top</td><td align="left">在整个窗口中打开被链接文档。</td></tr><tr><td align="left"><em>framename</em></td><td align="left">在指定的框架中打开被链接文档。</td></tr></tbody></table><p>这些 target 的所有 4 个值都以下划线开始。任何其他用一个下划线作为开头的窗口或者目标都会被浏览器忽略，因此，不要将下划线作为文档中定义的任何框架 name 或 id 的第一个字符。</p><h5 id="3、元素的alt和title有什么异同，选出正确的说法"><a href="#3、元素的alt和title有什么异同，选出正确的说法" class="headerlink" title="3、元素的alt和title有什么异同，选出正确的说法"></a>3、元素的alt和title有什么异同，选出正确的说法</h5><p>alt是html标签的属性，而title既是html标签，又是html属性。<br>title标签这个不用多说，网页的标题就是写在<code>&lt;title&gt;&lt;/title&gt;</code>这对标签之内的。<br>title作为属性时，用来为元素提供额外说明信息。例如，给超链接标签a添加了title属性，把鼠标移动到该链接上面是，就会显示title的内容，以达到补充说明或者提示的效果。<br>而alt属性则是用来指定替换文字，只能用在img、area和input元素中（包括applet元素），用于网页中图片无法正常显示时给用户提供文字说明使其了解图像信息。</p><h5 id="4、下述有关css属性position的属性值的描述，说法错误的是？"><a href="#4、下述有关css属性position的属性值的描述，说法错误的是？" class="headerlink" title="4、下述有关css属性position的属性值的描述，说法错误的是？"></a>4、下述有关css属性position的属性值的描述，说法错误的是？</h5><p>CSS中Position属性有四个可选值，它们分别是：static、absolute、fixed、relative。</p><p>◆position:static　无定位</p><p>该属性值是所有元素定位的默认情况，在一般情况下，我们不需要特别的去声明它，但有时候遇到继承的情况，我们不愿意见到元素所继承的属性影响本身，从而可以用position:static取消继承，即还原元素定位的默认值。</p><p>◆position:absolute　绝对定位</p><p>使用position:absolute，能够很准确的将元素移动到你想要的位置，</p><p>◆position:fixed　相对于窗口的固定定位</p><p>这个定位属性值是什么意思呢？元素的定位方式同absolute类似，但它的包含块是视区本身。在屏幕媒体如WEB浏览器中，元素在文档滚动时不会在浏览器视察中移动。例如，它允许框架样式布局。在页式媒体如打印输出中，一个固定元素会出现于第一页的相同位置。这一点可用于生成流动标题或脚注。我们也见过相似的效果，但大都数效果不是通过CSS来实现了，而是应用了JS脚本。</p><p>请特别注意，IE6不支持CSS中的position:fixed属性。真的非常遗憾，要不然我们就可以试试这种酷酷的效果了。</p><p>◆position:relative　相对定位</p><p>所谓相对定位到底是什么意思呢，是基于哪里的相对呢？我们需要明确一个概念，相对定位是相对于元素默认的位置的定位。既然是相对的，我们就需要设置不同的值来声明定位在哪里，top、bottom、left、right四个数值配合，来明确元素的位置。</p><h5 id="5、下面有关javascript常见事件的触发情况"><a href="#5、下面有关javascript常见事件的触发情况" class="headerlink" title="5、下面有关javascript常见事件的触发情况"></a>5、下面有关javascript常见事件的触发情况</h5><p>常见事件：</p><ol><li>点击事件：<ol><li>onclick：单击事件</li><li>ondblclick: 双击事件</li></ol></li><li>焦点事件：<ol><li>onblur:失去焦点</li><li>onfocus:元素获得焦点</li></ol></li><li>加载事件<ol><li>onload：一张页面或一幅图像完成加载</li></ol></li><li>鼠标事件：<ol><li>onmousedown: 鼠标按钮被松下</li><li>onmouseup:鼠标按键被松开</li><li>onmousemove:鼠标被移动</li><li>onmouseover:鼠标移到某元素之上</li><li>onmouseout:鼠标从某元素上移开</li></ol></li><li>键盘事件：<ol><li>onkeydown:某个键盘按键被按下</li><li>onkeyup:某个键盘按键被松开。</li><li>onkeypress:某个键盘按键被按下并松开</li></ol></li><li>选择和改变：<ol><li>onchange:域的内容被改变</li><li>onselect:文本被选中</li></ol></li><li>表单事件：<ol><li>onsubmit 确认按钮被点击</li><li>onreset:重置按钮被点击</li></ol></li></ol><h5 id="6、下述有关border-none以及border-0的区别？"><a href="#6、下述有关border-none以及border-0的区别？" class="headerlink" title="6、下述有关border:none以及border:0的区别？"></a>6、下述有关border:none以及border:0的区别？</h5><p>1.效果</p><p>border-style:none;//无边框     </p><p>border-width:0;//边框宽度为0px  </p><p>2.区别</p><p>（1）性能差异</p><p>border:0;浏览器对border-width、border-color进行渲染，占用内存。</p><p>border:none;浏览器不进行渲染，不占用内存。</p><p>Chrome：</p><p>border:none;&gt;&gt; border:initial none initial;</p><p>border:0;&gt;&gt; border:0 initial initial ;</p><p>Firefox、360：</p><p>border:none; &gt;&gt;border:medium none;</p><p>border:0;&gt;&gt; border:0 none;</p><p>计算出的样式：</p><p><strong>border:0px none 元素color属性值;</strong></p><p>（2）浏览器兼容</p><p>IE7-不支持border:none;</p><p>W3C提示：请始终把border-style属性声明到border-color属性之前，元素必须在改变颜色之前获得边框。</p><h5 id="7、下面有关Css-sprites说法？"><a href="#7、下面有关Css-sprites说法？" class="headerlink" title="7、下面有关Css sprites说法？"></a>7、下面有关Css sprites说法？</h5><p>CSS Sprites</p><p>1.简介</p><p>CSS Sprites在国内很多人叫css精灵，是一种网页图片应用处理方式。它允许将一个页面涉及到的所有零星图片都包含到一张大图中， 利用CSS的“background-image”，“background- repeat”，“background-position”的组合进行背景定位， 访问页面时避免图片载入缓慢的现象。</p><p>2.优点</p><p>（1）CSS Sprites能很好地减少网页的http请求，从而大大的提高页面的性能，这是CSS Sprites最大的优点，也是其被广泛传播和应用的主要原因；</p><p>（2）CSS Sprites能减少图片的字节；</p><p>（3）CSS Sprites解决了网页设计师在图片命名上的困扰，只需对一张集合的图片命名，不需要对每一个小图片进行命名，从而提高了网页制作效率。</p><p>（4）CSS Sprites只需要修改一张或少张图片的颜色或样式来改变整个网页的风格。</p><p>3.缺点</p><p>（1）图片合并麻烦：图片合并时，需要把多张图片有序的合理的合并成一张图片，并留好足够的空间防止版块出现不必要的背景。</p><p>（2）图片适应性差：在高分辨的屏幕下自适应页面，若图片不够宽会出现背景断裂。</p><p>（3）图片定位繁琐：开发时需要通过工具测量计算每个背景单元的精确位置。</p><p>（4）可维护性差：页面背景需要少许改动，可能要修改部分或整张已合并的图片，进而要改动css。在避免改动图片的前提下，又只能（最好）往下追加图片，但这样增加了图片字节。</p><h5 id="8、无webkit内核的是"><a href="#8、无webkit内核的是" class="headerlink" title="8、无webkit内核的是"></a>8、无webkit内核的是</h5><p>Wekbit是一个开源的Web浏览器引擎，也就是浏览器的内核。Apple的Safari, Google的Chrome, Nokia S60平台的默认浏览器，Apple手机的默认浏览器，Android手机的默认浏览器均采用的Webkit作为器浏览器内核。Webkit的采用程度由 此可见一斑，理所当然的成为了当今主流的三大浏览器内核之一。另外两个分别是Gecko和Trident，大名鼎鼎的Firefox便是使用的Gecko 内核，而微软的IE系列则使用的是Trident内核。</p><p>另外，搜狗浏览器是双核的，双核并不是指一个页面由2个内核同时处理,而是所有网页（通常是标准通用标记语言的应用超文本标记语言）由webkit内核处理,只有银行网站用IE内核</p><h5 id="9、为所有-lt-h1-gt-添加背景颜色"><a href="#9、为所有-lt-h1-gt-添加背景颜色" class="headerlink" title="9、为所有&lt;h1&gt;添加背景颜色"></a>9、为所有<code>&lt;h1&gt;</code>添加背景颜色</h5><p>h1{background-color:#111111;}</p><h5 id="10、Css哪个属性不属于尺寸属性"><a href="#10、Css哪个属性不属于尺寸属性" class="headerlink" title="10、Css哪个属性不属于尺寸属性"></a>10、Css哪个属性不属于尺寸属性</h5><p>height、line-height、min-width    top不是，top是距离，而非尺寸</p><h5 id="11、正则里的-描述正确的是"><a href="#11、正则里的-描述正确的是" class="headerlink" title="11、正则里的$描述正确的是"></a>11、正则里的$描述正确的是</h5><p>^是正则表达式匹配字符串开始位置</p><p>$是正则表达式匹配字符串结束位置</p><h5 id="12、关于ES6解构表达式"><a href="#12、关于ES6解构表达式" class="headerlink" title="12、关于ES6解构表达式"></a>12、关于ES6解构表达式</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> [a,b, c,d, e] = <span class="hljs-string">``</span><span class="hljs-string">&quot;hello&quot;</span><span class="hljs-string">``</span>; <br></code></pre></td></tr></table></figure><p>描述正确的是（）</p><p>解析：一峰老师的ECMAScript 6入门：<a href="https://es6.ruanyifeng.com/#docs/destructuring">https://es6.ruanyifeng.com/#docs/destructuring</a></p><p>字符串的解构赋值</p><p>字符串也可以解构赋值，因为此时字符串被转换成一个类似数组的对象</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> [a,b, c,d, e] = <span class="hljs-string">&quot;hello&quot;</span>;<br><span class="hljs-built_in">console</span>.log(a);  <span class="hljs-comment">//h</span><br><span class="hljs-built_in">console</span>.log(b);  <span class="hljs-comment">//e</span><br><span class="hljs-built_in">console</span>.log(c);  <span class="hljs-comment">//l</span><br><span class="hljs-built_in">console</span>.log(d);  <span class="hljs-comment">//l</span><br><span class="hljs-built_in">console</span>.log(e);  <span class="hljs-comment">//o</span><br></code></pre></td></tr></table></figure><p>类似数组的对象都有一个 length 属性，因此还可以对这个属性解构赋值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> &#123;<span class="hljs-attr">length</span> : len&#125; = <span class="hljs-string">&#x27;hello&#x27;</span>;<br><span class="hljs-built_in">console</span>.log(len);  <span class="hljs-comment">//5</span><br></code></pre></td></tr></table></figure><h5 id="13、关于ES6-箭头函数-gt-，描述（）"><a href="#13、关于ES6-箭头函数-gt-，描述（）" class="headerlink" title="13、关于ES6 箭头函数 ()=&gt;{} ，描述（）"></a>13、关于ES6 箭头函数 ()=&gt;{} ，描述（）</h5><ul><li>当箭头函数没有参数或有大于等于两个的参数时，必须使用括号，如：let a = ()=&gt;{} 或 let a = (b, c) =&gt; {};</li><li>箭头函数没有arguments 绑定</li><li>箭头函数的this是函数定义的对象，而不是使用函数的对象</li><li>var f = v =&gt; v</li></ul><h5 id="14、Http请求返回码（status-code）中，代表-未授权的请求-的代码是"><a href="#14、Http请求返回码（status-code）中，代表-未授权的请求-的代码是" class="headerlink" title="14、Http请求返回码（status code）中，代表[未授权的请求]的代码是"></a>14、Http请求返回码（status code）中，代表[未授权的请求]的代码是</h5><p>401</p><h5 id="15、当HTMl页面加载完毕时触发的事件是"><a href="#15、当HTMl页面加载完毕时触发的事件是" class="headerlink" title="15、当HTMl页面加载完毕时触发的事件是"></a>15、当HTMl页面加载完毕时触发的事件是</h5><p>onload</p><h5 id="16、CSS3中，能使用div的宽度变化有2秒的过渡效果的属性是提示："><a href="#16、CSS3中，能使用div的宽度变化有2秒的过渡效果的属性是提示：" class="headerlink" title="16、CSS3中，能使用div的宽度变化有2秒的过渡效果的属性是提示："></a>16、CSS3中，能使用div的宽度变化有2秒的过渡效果的属性是提示：</h5><p>div {<br>      transition: width 2s;<br>}</p><h5 id="17、请使用Promise封装Ajax操作"><a href="#17、请使用Promise封装Ajax操作" class="headerlink" title="17、请使用Promise封装Ajax操作"></a>17、请使用Promise封装Ajax操作</h5><p>原始的Ajax操作如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> onSuccess = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">result</span>)</span>&#123;&#125;; <span class="hljs-comment">//成功的回调</span><br><span class="hljs-keyword">var</span> onFail = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">error</span>)</span>&#123;&#125;; <span class="hljs-comment">//失败的回调</span><br><span class="hljs-keyword">var</span> req = <span class="hljs-keyword">new</span> XMLHttpRequest();<br>req.open(<span class="hljs-string">&quot;POST&quot;</span>, <span class="hljs-string">&quot;www.baidu.com&quot;</span>, <span class="hljs-literal">true</span>);<br>req.onload = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br>  <span class="hljs-keyword">if</span>(req.readyState === <span class="hljs-number">4</span> &amp;&amp; req.status === <span class="hljs-number">200</span>)&#123;<br>    onSuccess(req.response);<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    onFail(req.statusText);<br>  &#125;<br>&#125;<br>req.onerror = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br>  onFail(<span class="hljs-built_in">Error</span>(<span class="hljs-string">&quot;网络异常&quot;</span>));<br>&#125;<br></code></pre></td></tr></table></figure><p>答案：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">resolve, reject</span>)</span>&#123;<br>   <span class="hljs-keyword">var</span> req = <span class="hljs-keyword">new</span> XMLHttpRequest();<br>   req.open(<span class="hljs-string">&quot;POST&quot;</span>,<span class="hljs-string">&quot;www.baidu.com&quot;</span>, <span class="hljs-literal">true</span>);<br>   req.onload = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br>     <span class="hljs-keyword">if</span>(req.readyState === <span class="hljs-number">4</span> &amp;&amp; req.status === <span class="hljs-number">200</span>)&#123;<br>       resolve(req.response);<br>     &#125; <span class="hljs-keyword">else</span> &#123;<br>       reject(req.statusText);<br>     &#125;<br>   &#125;<br>   req.onerror = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br>     reject(<span class="hljs-built_in">Error</span>(<span class="hljs-string">&quot;网络异常&quot;</span>));<br>   &#125;<br> &#125;);<br></code></pre></td></tr></table></figure><p>尝试把它跑起来：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">&quot;myFunction()&quot;</span>&gt;</span>发送<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><br><span class="javascript">    <span class="hljs-keyword">const</span> request = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">method, url, isajax</span>) </span>&#123;</span><br><span class="javascript">        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="javascript">            <span class="hljs-keyword">let</span> req = <span class="hljs-keyword">new</span> XMLHttpRequest();</span><br>            req.open(method, url, isajax);<br><span class="javascript">            req.onload = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;</span><br><span class="javascript">                <span class="hljs-keyword">if</span> (req.readState === <span class="hljs-number">4</span> &amp;&amp; req.status === <span class="hljs-number">200</span>) &#123;</span><br>                    resolve(req.response)<br><span class="javascript">                &#125; <span class="hljs-keyword">else</span> &#123;</span><br>                    reject(req.statusText);<br>                &#125;<br>               <br><span class="javascript">                req.onerror = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;</span><br><span class="javascript">                    reject(<span class="hljs-built_in">Error</span>(<span class="hljs-string">&quot;网络异常&quot;</span>))</span><br>                &#125;<br>            &#125;<br>            req.send();<br>        &#125;)<br>    &#125;<br><br><span class="javascript">    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">myFunction</span>(<span class="hljs-params"></span>) </span>&#123;</span><br><span class="javascript">        <span class="hljs-keyword">let</span> req = request(<span class="hljs-string">&quot;post&quot;</span>, <span class="hljs-string">&quot;www.baidu.com&quot;</span>, <span class="hljs-literal">true</span>)</span><br><span class="javascript">        req.then(<span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> &#123;</span><br><span class="javascript">            <span class="hljs-built_in">console</span>.log(e)</span><br><span class="javascript">        &#125;, <span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> &#123;</span><br><span class="javascript">            <span class="hljs-built_in">console</span>.log(e)</span><br>        &#125;)<br>    &#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><h5 id="18、对于HTTPS建立连接的过程，下面描述正确的是"><a href="#18、对于HTTPS建立连接的过程，下面描述正确的是" class="headerlink" title="18、对于HTTPS建立连接的过程，下面描述正确的是"></a>18、对于HTTPS建立连接的过程，下面描述正确的是</h5><p>DNS TCP TLS HTTP</p><h5 id="19、对于javascript执行引擎描述"><a href="#19、对于javascript执行引擎描述" class="headerlink" title="19、对于javascript执行引擎描述"></a>19、对于javascript执行引擎描述</h5><p>Node.js的Buffer类型对象在创建时内存不会分配到V8堆上</p><h5 id="20、关于解构的说法"><a href="#20、关于解构的说法" class="headerlink" title="20、关于解构的说法"></a>20、关于解构的说法</h5><ul><li>不完全结构，也会成功，不会报错。</li><li>只要支持Iterator接口，都可以被结构赋值。</li><li>null可以替代默认值，而成功的结构赋值。</li><li>结构中不定参数可以出现在除第一个以外的其它的其他位置。</li><li>默认值可以引用结构赋值的其他变量，但该变量必须已经声明。</li></ul><h5 id="21、下列对css外边距描述正确的是（不考虑BFC对边距的影响）"><a href="#21、下列对css外边距描述正确的是（不考虑BFC对边距的影响）" class="headerlink" title="21、下列对css外边距描述正确的是（不考虑BFC对边距的影响）"></a>21、下列对css外边距描述正确的是（不考虑BFC对边距的影响）</h5><p>两个上下相邻的同级元素Div1，Div2。Div1的下边距是20px，Div2的上边距是10px。Div1和Div2的间距是20px</p><p>box1的底部margin为10px，box2的顶部margin为20px，但表现在页面上2者之间的间隔为20px，而不是预想中的10+20px=30px，结果是选择2者之间最大的那个margin，这种机制被称为“外边距合并”；外边距合并不仅仅出现在相邻的元素间，父子间同样会出现。</p><h5 id="22、indexDB"><a href="#22、indexDB" class="headerlink" title="22、indexDB"></a>22、indexDB</h5><p>通俗地说，IndexedDB 就是浏览器提供的本地数据库，它可以被网页脚本创建和操作。IndexedDB 允许储存大量数据，提供查找接口，还能建立索引。这些都是 LocalStorage 所不具备的。就数据库类型而言，IndexedDB 不属于关系型数据库（不支持 SQL 查询语句），更接近 NoSQL 数据库。</p><p>IndexedDB 具有以下特点。</p><p><strong>（1）键值对储存。</strong> IndexedDB 内部采用对象仓库（object store）存放数据。所有类型的数据都可以直接存入，包括 JavaScript 对象。对象仓库中，数据以”键值对”的形式保存，每一个数据记录都有对应的主键，主键是独一无二的，不能有重复，否则会抛出一个错误。</p><p><strong>（2）异步。</strong> IndexedDB 操作时不会锁死浏览器，用户依然可以进行其他操作，这与 LocalStorage 形成对比，后者的操作是同步的。异步设计是为了防止大量数据的读写，拖慢网页的表现。</p><p><strong>（3）支持事务。</strong> IndexedDB 支持事务（transaction），这意味着一系列操作步骤之中，只要有一步失败，整个事务就都取消，数据库回滚到事务发生之前的状态，不存在只改写一部分数据的情况。</p><p><strong>（4）同源限制</strong> IndexedDB 受到同源限制，每一个数据库对应创建它的域名。网页只能访问自身域名下的数据库，而不能访问跨域的数据库。</p><p><strong>（5）储存空间大</strong> IndexedDB 的储存空间比 LocalStorage 大得多，一般来说不少于 250MB，甚至没有上限。</p><p><strong>（6）支持二进制储存。</strong> IndexedDB 不仅可以储存字符串，还可以储存二进制数据（ArrayBuffer 对象和 Blob 对象）</p><h5 id="23、浮点方法"><a href="#23、浮点方法" class="headerlink" title="23、浮点方法"></a>23、浮点方法</h5><ol><li>parseFloat 解析一个字符串，并返回一个浮点数</li><li>toFixed 把数字转换为字符串，结果的小数点后有指定位数的数字</li><li>Math.round 把一个数字舍入为最接近的整数</li><li>toPrecision 把数字格式化为指定的有效数字</li></ol><h5 id="24、如何判断一个js对象是否是Array-arr为要判断的对象，其中最准确的方法是？"><a href="#24、如何判断一个js对象是否是Array-arr为要判断的对象，其中最准确的方法是？" class="headerlink" title="24、如何判断一个js对象是否是Array,arr为要判断的对象，其中最准确的方法是？"></a>24、如何判断一个js对象是否是Array,arr为要判断的对象，其中最准确的方法是？</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">Object</span>.prototype.toString.call(arr) === <span class="hljs-string">&#x27;[object Array]&#x27;</span>;<br></code></pre></td></tr></table></figure><p><img src="https://uploadfiles.nowcoder.com/images/20170720/6941986_1500560338203_5B46C4D74B16DE332AFD135B27C26F7F" alt="img"></p><p>instanceof 在跨 frame 对象构建的场景下会失效</p><h5 id="25、假设DOM结构为："><a href="#25、假设DOM结构为：" class="headerlink" title="25、假设DOM结构为："></a>25、假设DOM结构为：</h5><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;a&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;b&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><p>JS代码为：</p><p>当点击id为b的div时，控制台输出的内容是：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;a&#x27;</span>).addEventListener(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-function"><span class="hljs-params">e</span> =&gt;</span> &#123;<span class="hljs-built_in">console</span>.log(<span class="hljs-number">1</span>)&#125;);<br><span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;b&#x27;</span>).addEventListener(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-function"><span class="hljs-params">e</span> =&gt;</span> &#123;e.preventDefault();<span class="hljs-built_in">console</span>.log(<span class="hljs-number">2</span>)&#125;);<br></code></pre></td></tr></table></figure><p>当点击id为b的div时，控制台输出的内容是：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-number">2</span><br><span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><h5 id="26、js中-和"><a href="#26、js中-和" class="headerlink" title="26、js中==和==="></a>26、js中<code>==</code>和<code>===</code></h5><p>==是会隐式的进行类型转换再进行比较的</p><p>===是不会进行类型转换，严格相等运算符</p><h5 id="27、html5中使用的媒体元素"><a href="#27、html5中使用的媒体元素" class="headerlink" title="27、html5中使用的媒体元素"></a>27、html5中使用的媒体元素</h5><ul><li>audio  定义音频</li><li>video   定义视频</li><li>embed   作为外部应用的容器</li><li>source   多种媒体源的支持</li><li>track   定义媒体的文本跟踪</li></ul><h5 id="28、SVG是什么"><a href="#28、SVG是什么" class="headerlink" title="28、SVG是什么"></a>28、SVG是什么</h5><p>什么是SVG? </p><ul><li>SVG 指可伸缩矢量图形 (Scalable Vector Graphics)</li><li> SVG 用来定义用于网络的基于矢量的图形</li><li>SVG 使用 XML 格式定义图形</li><li>SVG 图像在放大或改变尺寸的情况下其图形质量不会有所损失</li><li>SVG 是万维网联盟的标准</li><li>SVG 与诸如 DOM 和 XSL 之类的 W3C 标准是一个整体<br>(SVG是HTML下的一个分支)</li></ul><h5 id="29、HTML5中新增的标签"><a href="#29、HTML5中新增的标签" class="headerlink" title="29、HTML5中新增的标签"></a>29、HTML5中新增的标签</h5><p>新增header，footer，nav，article，section，aside，datalist，audio，video，embed，input属性</p><h5 id="30、canvas"><a href="#30、canvas" class="headerlink" title="30、canvas"></a>30、canvas</h5><p>canvas 中绘制的元素不可以通过浏览器提供的接口获取到。</p><h5 id="31、SEO优化"><a href="#31、SEO优化" class="headerlink" title="31、SEO优化"></a>31、SEO优化</h5><h5 id="32、XML和JSON的比较"><a href="#32、XML和JSON的比较" class="headerlink" title="32、XML和JSON的比较"></a>32、XML和JSON的比较</h5><p>JSON与XML的区别，在<strong>菜鸟教程</strong>上可以容易找到（<a href="https://www.runoob.com/json/json-vs-xml.html%EF%BC%89%E3%80%82">https://www.runoob.com/json/json-vs-xml.html）。</a></p><p>A. 针对 AJAX 应用，JSON 比 XML 数据加载更快，更简单。</p><p>B. 参考<a href="https://www.nowcoder.com/profile/984905694">tlltll</a>友友对Java和Javascript例子的解释。</p><p>C和E都在说XML比JSON好。但是<strong>菜鸟教程</strong>上明确指明JSON比XML好。😂😂😂JSON可以使用数组形式，XML不能。</p><p>D.JSON 是存储和交换文本信息的语法，是轻量级的文本数据交换格式；而HTML5是为了能在移动设备上支持多媒体而被创造，是HTML（用来描述网页的一种标记语言）最新的修订版本。</p><h5 id="33、伪类和伪元素的区别"><a href="#33、伪类和伪元素的区别" class="headerlink" title="33、伪类和伪元素的区别"></a>33、伪类和伪元素的区别</h5><p><a href="https://www.cnblogs.com/andy-lehhaxm/p/9561776.html">https://www.cnblogs.com/andy-lehhaxm/p/9561776.html</a></p><h5 id="34、哪些可以不用-闭合"><a href="#34、哪些可以不用-闭合" class="headerlink" title="34、哪些可以不用/闭合"></a>34、哪些可以不用/闭合</h5><p>HTML5中：<br>自关闭的斜线(/)对 ：area, base, br, col, command, embed, hr, img, input, keygen, link, meta, param, source, track, wbr空标签无效，言即不再需要自闭合(/)这个小尾巴了，如果要写上也是可以的。</p><h5 id="35、CSS样式中，Border-radius属性作用是什么"><a href="#35、CSS样式中，Border-radius属性作用是什么" class="headerlink" title="35、CSS样式中，Border-radius属性作用是什么"></a>35、CSS样式中，Border-radius属性作用是什么</h5><p>border-radius，国内翻译成圆角，你可能以为这个属性就是用来画圆角，但是除此之外，radius其实指的是边框所在圆的半径，这个CSS3属性不仅能够创建圆角，还可以创建椭圆角，把这些角按照不同的顺序和大小来展现，能够绘制成多种多样的图形。<br>如：border-radius:10px 15px 10px 5px;</p><p>四个值分别表示左上角、右上角、右下角、右下角。</p><h5 id="36、产生带有正方形项目的列表"><a href="#36、产生带有正方形项目的列表" class="headerlink" title="36、产生带有正方形项目的列表"></a>36、产生带有正方形项目的列表</h5><figure class="highlight dsconfig"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dsconfig"><span class="hljs-built_in">list-style-type:</span> <span class="hljs-string">square</span><br></code></pre></td></tr></table></figure><h5 id="37、input属于窗体元素-层级显示比flash、其它元素都高。请判断这句话的正确与否。（F）"><a href="#37、input属于窗体元素-层级显示比flash、其它元素都高。请判断这句话的正确与否。（F）" class="headerlink" title="37、input属于窗体元素,层级显示比flash、其它元素都高。请判断这句话的正确与否。（F）"></a>37、input属于窗体元素,层级显示比flash、其它元素都高。请判断这句话的正确与否。（F）</h5><p>在html中，帧元素（frameset）的优先级最高，表单元素比非表单元素的优先级要高。</p><p>表单元素包括：文本输入框，密码输入框，单选框，复选框，文本输入域，列表框等等；</p><p>非表单元素包括：连接（a），div,table,span等。</p><p>所有的html元素又可以根据其显示分成两类：有窗口元素以及无窗口元素。有窗口元素总是显示在无窗口元素的前面。</p><p>有窗口元素包括：select元素，object元素，以及frames元素等等。</p><p>无窗口元素：大部分html元素都是无窗口元素。</p><h5 id="38、-lt-address-gt-和-lt-hr-gt-和-lt-a-gt-和-lt-cite-gt"><a href="#38、-lt-address-gt-和-lt-hr-gt-和-lt-a-gt-和-lt-cite-gt" class="headerlink" title="38、&lt;address&gt;和&lt;hr&gt;和&lt;a&gt;和&lt;cite&gt;"></a>38、<code>&lt;address&gt;</code>和<code>&lt;hr&gt;</code>和<code>&lt;a&gt;</code>和<code>&lt;cite&gt;</code></h5><p><code>&lt;address&gt; </code>标签定义文档或文章的作者/拥有者的联系信息。</p><p><code>&lt;hr&gt; </code>标签在 HTML 页面中创建一条水平线。</p><p><code>&lt;a&gt;</code> 标签定义超链接，用于从一张页面链接到另一张页面。</p><p><code>&lt;cite&gt;</code> 标签通常表示它所包含的文本对某个参考文献的引用，比如书籍或者杂志的标题。</p><h5 id="39、input元素种类"><a href="#39、input元素种类" class="headerlink" title="39、input元素种类"></a>39、input元素种类</h5><p>HTML input元素种类</p><ul><li><p>email</p></li><li><p>url</p></li><li><p>number</p></li><li><p>range</p></li><li><p>Date pickers(date, month, week, time, datetime, datetime-local)</p></li><li><p>search</p></li><li><p>color</p></li></ul><h5 id="40、hgroup在H5中用于组合标题元素"><a href="#40、hgroup在H5中用于组合标题元素" class="headerlink" title="40、hgroup在H5中用于组合标题元素"></a>40、hgroup在H5中用于组合标题元素</h5><h5 id="41、slider可以定义滑块控件"><a href="#41、slider可以定义滑块控件" class="headerlink" title="41、slider可以定义滑块控件"></a>41、slider可以定义滑块控件</h5><p>其他什么的</p><table><thead><tr><th>button</th><th>定义可点击的按钮（大多与 JavaScript 使用来启动脚本）</th></tr></thead><tbody><tr><td>checkbox</td><td>定义复选框。</td></tr><tr><td>color</td><td>定义拾色器。</td></tr><tr><td>date</td><td>定义日期字段（带有 calendar 控件）</td></tr><tr><td>datetime</td><td>定义日期字段（带有 calendar 和 time 控件）</td></tr><tr><td>datetime-local</td><td>定义日期字段（带有 calendar 和 time 控件）</td></tr><tr><td>month</td><td>定义日期字段的月（带有 calendar 控件）</td></tr><tr><td>week</td><td>定义日期字段的周（带有 calendar 控件）</td></tr><tr><td>time</td><td>定义日期字段的时、分、秒（带有 time 控件）</td></tr><tr><td>email</td><td>定义用于 e-mail 地址的文本字段</td></tr><tr><td>file</td><td>定义输入字段和 “浏览…” 按钮，供文件上传</td></tr><tr><td>hidden</td><td>定义隐藏输入字段</td></tr><tr><td>image</td><td>定义图像作为提交按钮</td></tr><tr><td>number</td><td>定义带有 spinner 控件的数字字段</td></tr><tr><td>password</td><td>定义密码字段。字段中的字符会被遮蔽。</td></tr><tr><td>radio</td><td>定义单选按钮。</td></tr><tr><td>range</td><td>定义带有 slider 控件的数字字段。</td></tr><tr><td>reset</td><td>定义重置按钮。重置按钮会将所有表单字段重置为初始值。</td></tr><tr><td>search</td><td>定义用于搜索的文本字段。</td></tr><tr><td>submit</td><td>定义提交按钮。提交按钮向服务器发送数据。</td></tr><tr><td>tel</td><td>定义用于电话号码的文本字段。</td></tr><tr><td>text</td><td>默认。定义单行输入字段，用户可在其中输入文本。默认是 20 个字符。</td></tr><tr><td>url</td><td>定义用于 URL 的文本字段。</td></tr></tbody></table><h5 id="42、可以继承和不可以继承的"><a href="#42、可以继承和不可以继承的" class="headerlink" title="42、可以继承和不可以继承的"></a>42、可以继承和不可以继承的</h5><p><a href="https://www.cnblogs.com/thislbq/p/5882105.html">https://www.cnblogs.com/thislbq/p/5882105.html</a></p><h5 id="43、自动类型转换"><a href="#43、自动类型转换" class="headerlink" title="43、自动类型转换"></a>43、自动类型转换</h5><p>①为任意的数据类型“10”+3即可将其<strong>转换成String</strong>字符串类型，这是一种隐式类型转换，由浏览器自动完成，实际上也是调用String()函数。</p><p>②为任意的数据类型 “103”-“1” 即可将其<strong>转换成Number</strong>数值类型。</p><h5 id="44、回流触发"><a href="#44、回流触发" class="headerlink" title="44、回流触发"></a>44、回流触发</h5><p>首先早知道reflow是什么？ reflow(回流)是指浏览器为了重新渲染部分或者全部的文档,重新计算文档中的元素的位置和几何构造的过程。 因为回流可能导致整个Dom树的重新构造,所以是性能的一大杀手。 以下操作会引起回流：</p><p> ① 改变窗口大小</p><p> ② font-size大小改变</p><p> ③ 增加或者移除样式表 </p><p> ④ 内容变化（input中输入文字会导致）</p><p> ⑤ 激活CSS伪类（:hover）</p><p> ⑥ 操作class属性，新增或者减少</p><p> ⑦ js操作dom </p><p> ⑧ offset相关属性计算</p><p> ⑨ 设置style的值 …… 另外: reflow与repaint（重绘）是减缓js的几大主要原因，尤其是reflow更是性能杀手，所以我们应该想法避免。</p><h5 id="45、Vue-js具备的特性"><a href="#45、Vue-js具备的特性" class="headerlink" title="45、Vue.js具备的特性"></a>45、Vue.js具备的特性</h5><p>指令和过滤器</p><h5 id="46、Canvas和SVG的区别"><a href="#46、Canvas和SVG的区别" class="headerlink" title="46、Canvas和SVG的区别"></a>46、Canvas和SVG的区别</h5><ul><li><p>Canvas产生的dom数量比SVG要少</p></li><li><p>SVG可以使用css设置动画样式，但是Canv as不能用css设置动画样式</p></li><li><p>canvas 中绘制的元素不可以通过浏览器提供的接口获取到。SVG可以通过浏览器提供的接口获取到。</p><p>SVG与Canvas的区别<br> SVG<br>   不依赖分辨率<br>   支持事件绑定<br>   大型渲染区域的程序(例如百度地图)<br>   不能用来实现网页游戏<br>Canvas<br>   依赖分辨率<br>   不支持事件绑定<br>   最合适网页游戏<br>   保存为”.jpg”格式的图片</p></li></ul><h5 id="47、XML说法"><a href="#47、XML说法" class="headerlink" title="47、XML说法"></a>47、XML说法</h5><ul><li><p>Xml一般用于传输和存储数据，是对html的补充，两者的目的不同</p></li><li><p>在JavaScript里解析和处理xml数据时，因为浏览器的不同，其做法也不同</p></li><li><p>在IE浏览器里处理xml，首先需要创建ActiveXObject对象</p></li></ul><h5 id="48、jquery想找所有元素的同辈元素"><a href="#48、jquery想找所有元素的同辈元素" class="headerlink" title="48、jquery想找所有元素的同辈元素"></a>48、jquery想找所有元素的同辈元素</h5><p>siblings([expr])同辈，find([expr])后辈，eq第几个，next()下一个</p><h5 id="49、-lt-i-gt-lt-em-gt-标签语义表示"><a href="#49、-lt-i-gt-lt-em-gt-标签语义表示" class="headerlink" title="49、&lt;i&gt;``&lt;em&gt;标签语义表示"></a>49、<code>&lt;i&gt;``&lt;em&gt;</code>标签语义表示</h5><p><code>&lt;i&gt;</code>标签只是单纯的样式标签，表现斜体的样式，但是语义上与普通文本无异；<code>&lt;em&gt;</code>标签在样式上表示为斜体，同时在语义上也表示为斜体。<code>&lt;em&gt;</code>标签可以被设备识别，而<code>&lt;i&gt;</code>标签不能被识别。</p><h5 id="50、使用link和-import有什么区别"><a href="#50、使用link和-import有什么区别" class="headerlink" title="50、使用link和@import有什么区别"></a>50、使用link和@import有什么区别</h5><p>1.从属关系区别 @import是 CSS 提供的语法规则，只有导入样式表的作用；link是HTML提供的标签，不仅可以加载 CSS 文件，还可以定义 RSS、rel 连接属性等。 </p><p>2.加载顺序区别 加载页面时，link标签引入的 CSS 被同时加载；@import引入的 CSS 将在页面加载完毕后被加载。</p><p> 3.兼容性区别 @import是 CSS2.1 才有的语法，故只可在 IE5+ 才能识别；link标签作为 HTML 元素，不存在兼容性问题。</p><p> 4.DOM可控性区别 可以通过 JS 操作 DOM ，插入link标签来改变样式；由于 DOM 方法是基于文档的，无法使用@import的方式插入样式。</p><p>5.权重区别 link引入的样式权重大于@import引入的样式。</p><h5 id="51、JS的RegExp对象方法"><a href="#51、JS的RegExp对象方法" class="headerlink" title="51、JS的RegExp对象方法"></a>51、JS的RegExp对象方法</h5><p>JavaScript RegExp 对象有 3 个方法：test()、exec() 和 compile()。</p><ol><li>test() 方法用来检测一个字符串是否匹配某个正则表达式，如果匹配成功，返回 true ，否则返回 false；</li><li>exec() 方法用来检索字符串中与正则表达式匹配的值。exec() 方法返回一个数组，其中存放匹配的结果。如果未找到匹配的值，则返回 null；</li><li>compile() 方法可以在脚本执行过程中编译正则表达式，也可以改变已有表达式。</li></ol><p>注：<strong>match是支持正则表达式的String对象的方法</strong></p><h5 id="52、Javascript的全局函数"><a href="#52、Javascript的全局函数" class="headerlink" title="52、Javascript的全局函数"></a>52、Javascript的全局函数</h5><p>编码相关：</p><p>  escape()、unescape()、encodeURI()、decodeURI()、</p><p>  encodeURIComponent()、decodeURIComponent()</p><p>数据处理：</p><p>  Number()、String()</p><p>数字相关：</p><p>  isFinite()、isNaN()、parseFloat()、parseInt()</p><p>特殊：</p><p>  eval()</p><p>ps:对于 getClass() 方法。</p><h5 id="53、判断是不是数组对象"><a href="#53、判断是不是数组对象" class="headerlink" title="53、判断是不是数组对象"></a>53、判断是不是数组对象</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>]<br><span class="hljs-built_in">Array</span>.isArray()<br><br>arr <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Array</span><br><br><span class="hljs-built_in">Object</span>.prototype.toString.call([<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>])  <span class="hljs-comment">/*比较推荐这个,因为准备吧*/</span><br></code></pre></td></tr></table></figure><h5 id="54、input元素在html5中新增了哪些type属性"><a href="#54、input元素在html5中新增了哪些type属性" class="headerlink" title="54、input元素在html5中新增了哪些type属性"></a>54、input元素在html5中新增了哪些type属性</h5><p>在HTML5中，为input元素新增了以下一些type属性值：</p><ul><li>color：用于指定颜色的控件。</li><li>date：用于输入日期的控件（年，月，日，不包括时间）。</li><li>month：用于输入年月的控件，不带时区。</li><li>week：用于输入一个由星期-年组成的日期，日期不包括时区</li><li>time：用于输入不含时区的时间控件。</li><li>datetime：基于UTC时区的日期时间输入控件（时，分，秒及几分之一秒）。</li><li>datetime-local：用于输入日期时间控件，不包含时区。</li><li>email：用于应该包含 e-mail 地址的输入域。在提交表单时，会自动验证 email 域的值。</li><li>number: 用于应该包含数值的输入域。只能输入数字</li><li>range：用于应该包含一定范围内数字值的输入域。range 类型显示为滑动条。</li><li>search：用于输入搜索字符串的单行文本字段。换行会被从输入的值中自动移除。</li><li>tel：用于输入电话号码的控件。在移动端输入会显示数字键盘，PC端无效果</li><li>url：用于编辑URL的字段。</li></ul><h5 id="55、设置不同屏幕中，元素的位置不会发生改变的是（）"><a href="#55、设置不同屏幕中，元素的位置不会发生改变的是（）" class="headerlink" title="55、设置不同屏幕中，元素的位置不会发生改变的是（）"></a>55、设置不同屏幕中，元素的位置不会发生改变的是（）</h5><p>使用 @media screen查询，你可以针对不同的媒体类型定义不同的样式。</p><p>@media 可以针对不同的屏幕尺寸设置不同的样式，特别是如果你需要设置设计响应式的页面，@media 是非常有用的。</p><p>当你重置浏览器大小的过程中，页面也会根据浏览器的宽度和高度重新渲染页面。</p><h5 id="56、实现翻书的效果可以使用css3里的什么方法"><a href="#56、实现翻书的效果可以使用css3里的什么方法" class="headerlink" title="56、实现翻书的效果可以使用css3里的什么方法"></a>56、实现翻书的效果可以使用css3里的什么方法</h5><p>A、rotateY：定义沿 Y 轴的 3D 旋转，可实现翻书的效果</p><p>B、translateY：沿着 Y 轴移动元素</p><p>C、scaleY：定义 2D 缩放转换时，改变元素的高度；定义 3D 缩放转换时，通过给定一个 Y 轴的值</p><p>D、perspective(n)：改变3D元素是怎样查看透视图（注：只影响 3D 转换元素）</p><h5 id="57、H5中常用的新特性"><a href="#57、H5中常用的新特性" class="headerlink" title="57、H5中常用的新特性"></a>57、H5中常用的新特性</h5><p>HTML5中常用的新特性：</p><p>canvas元素：用于定义图形（图表等），只是图形容器，必须使用脚本来绘制图形。</p><p>audio：用于音频播放。</p><p>video：用于视频播放。</p><p>article：规定独立的自包含内容。</p><p>header：定义文档的页眉，介绍相关信息。</p><p>section：定义文档中的节。</p><p>footer：定义文档的页脚，通常有文档的作者、版权信息、联系方式等。</p><p>nav：定义导航链接。</p><p>表单控件：</p><p>calender</p><p>date</p><p>time</p><p>email</p><p>url</p><p>search</p><h5 id="58、在文件-home-somebody-workspace-somemodule-js中第一行引用了一个模块：require-‘othermodule‘-，请问required-的查找模块的顺序"><a href="#58、在文件-home-somebody-workspace-somemodule-js中第一行引用了一个模块：require-‘othermodule‘-，请问required-的查找模块的顺序" class="headerlink" title="58、在文件/home/somebody/workspace/somemodule.js中第一行引用了一个模块：require(‘othermodule‘)，请问required 的查找模块的顺序"></a>58、在文件/home/somebody/workspace/somemodule.js中第一行引用了一个模块：require(‘othermodule‘)，请问required 的查找模块的顺序</h5><p>A. /home/somebody/workspace/node_modules/othermodule/index.js<br>B. /home/somebody/workspace/node_modules/othermodule. Js<br>C.CORE MODULES named othermodule<br>D./home/somebody/node_modules/othermodule/index.js</p><p>解析：(1):首先，Node在当前目录下查找<code>package.json</code>(CommonJS包规范定义的包描述文件)，通过JSON.parse()解析出包描述对象，从中取出main属性指定的文件名进行定位。如果文件缺少扩展名，将会进入扩展名分析的步骤。 　　</p><p>(2):而如果main属性制定的文件名错误，或者压根没有package.json文件，Node会将index当做默认文件名，然后依次查找index.js、index.node、index.json. 　　</p><p>(3):如果在目录分析的过程中没有定位成功任何文件，则自定义模块进入下一个模块路径进行查找。如果模块路径数组都被遍历完毕，依然没有查找到目标文件，则会抛出查找失败异常。 　　按照上面的思路，首先应该查找package.json文件，看看里面有没有核心模块，应该是C最先，othermodule不是核心模块，那么接着应该进入扩展名分析的步骤，就应该是查找othermodule. js，对应B，紧接着就是以index为默认文件名，也就是A，再接下来就是上一个文件目录D了，<br>所以答案是： C B A D</p><h5 id="59、嵌入在HTMl文档中的图像格式是"><a href="#59、嵌入在HTMl文档中的图像格式是" class="headerlink" title="59、嵌入在HTMl文档中的图像格式是"></a>59、嵌入在HTMl文档中的图像格式是</h5><p>网页html文档支持的图片格式有jpg ， gif  ,   png  和  bmp  这四种，jpg ， gif  和  png 格式的图片特点是体积很小，因为在网上很常见，然而 bmp就不常见了，因为这种格式虽然很清晰色彩丰富，但是所占内存很大，所以很少见，但是也是支持的。一共这4种</p><h5 id="60、bootstrap中如何让一个区块居中"><a href="#60、bootstrap中如何让一个区块居中" class="headerlink" title="60、bootstrap中如何让一个区块居中?"></a>60、bootstrap中如何让一个区块居中?</h5><p>center、center-block</p><p>center是指<code>&lt;center&gt;&lt;/center&gt;</code>标签,center-block是bootstrap的样式 .center-block</p><h5 id="61、行内块标签"><a href="#61、行内块标签" class="headerlink" title="61、行内块标签"></a>61、行内块标签</h5><p>行内元素典型代表 span ,a, ,strong , em, del, ins</p><p>特点：★在一行上显示</p><p>   ★不能直接设置宽高</p><p>   ★元素的宽和高就是内容撑开的宽高。</p><p>行内块元素（内联元素）典型代表 input img</p><p>特点：★在一行上显示</p><p>   ★可以设置宽高</p><p>块元素典型代表,div,h1-h6,p,ul,li</p><p>特点: ★独占一行</p><p>   ★可以设置宽高</p><p>   ★ 嵌套（包含）下，子块元素宽度（没有定义情况下）和父块元素宽度默认一致。</p><h5 id="62、this的问题"><a href="#62、this的问题" class="headerlink" title="62、this的问题"></a>62、this的问题</h5><p>this的行为有时候会显得极其诡异，让人感到困惑，但只需要记住 <strong>this的值要等到代码真正执行时才能确定</strong><br>同时this的值具体有以下几种情况：</p><ol><li>new 调用时指的是被构造的对象</li><li>call、apply调用，指向我们指定的对象</li><li>对象调用，如执行obj.b()，this指向obj</li><li>默认的，指向全局变量window(相当于执行window.fun())</li></ol><p>这样看来，当你执行fun()的时候，以上1,2点均不满足。<br>第3点,因为this是运行时确定的，而我们执行fun()，等同于windown.fun()(<strong>与obj没有任何关系</strong>)，自然的this指向window，而window没有定义变量a，结果是undefined。</p><h5 id="63、如何使用css-选择器定义某个父元素中所有第”奇数”个子元素的样式："><a href="#63、如何使用css-选择器定义某个父元素中所有第”奇数”个子元素的样式：" class="headerlink" title="63、如何使用css 选择器定义某个父元素中所有第”奇数”个子元素的样式："></a>63、如何使用css 选择器定义某个父元素中所有第”奇数”个子元素的样式：</h5><p>nth-child(odd) ：定义某个父元素中所有第”奇数”个子元素的样式</p><p>nth-of-type(odd) ：定义某个父元素中的不同类型中的所有第”奇数”个子元素的样式</p><p>nth-child(odd) 奇数 ,nth-child(even) 偶数。</p><p>nth-child(n) : 匹配父元素中的第 n 个子元素，元素类型没有限制。</p><h5 id="64、哪个元素创建了一组选项"><a href="#64、哪个元素创建了一组选项" class="headerlink" title="64、哪个元素创建了一组选项"></a>64、哪个元素创建了一组选项</h5><p><code>&lt;optgroup&gt;</code></p><h5 id="65、哪些方法可以用作javascript异步模式的编程"><a href="#65、哪些方法可以用作javascript异步模式的编程" class="headerlink" title="65、哪些方法可以用作javascript异步模式的编程"></a>65、哪些方法可以用作javascript异步模式的编程</h5><p>先解释一下“同步模式”和“异步模式”：<br>（1）同步模式：就是后一个任务等待前一个任务结束，然后再执行，程序的执行顺序与任务的排列顺序是一致的、同步的。<br>（2）异步模式：完全不同，每一个任务有一个或多个回调函数（callback），前一个任务结束后，不是执行后一个任务，而是执行回调函数，<br>                           后一个任务则是不等前一个任务结束就执行，所以程序的执行顺序与任务的排列顺序是不一致的、异步的。<br>JavaScript中实现异步编程模式的4种方法,回调函数、事件监听、发布/订阅、Promises对象：<br>（1）回调函数：这是异步编程最基本的方法，优点是简单、容易理解和部署，缺点是不利于代码的阅读和维护，各个部分之间高度耦合<br>                        （Coupling），流程会很混乱，而且每个任务只能指定一个回调函数。<br>                         例：假定有两个函数f1和f2，后者等待前者的执行结果，如果f1是一个很耗时的任务，可以考虑改写f1，把f2写成f1的回调函<br>                         数。<br>（2）事件监听：任务的执行不取决于代码的顺序，而取决于某个事件是否发生。优点是比较容易理解，可以绑定多个事件，每个事件可以指定<br>                           多个回调函数，而且可以”去耦合”（Decoupling），有利于实现模块化。缺点是整个程序都要变成事件驱动型，运行流程会变<br>                           得很不清晰。<br>                           例：为f1绑定一个事件，当f1发生done事件，就执行f2。<br>（3）发布/订阅：我们假定，存在一个”信号中心”，某个任务执行完成，就向信号中心”发布”（publish）一个信号，其他任务可以向信号中心”订<br>                           阅”（subscribe）这个信号，从而知道什么时候自己可以开始执行。这就叫做”发布/订阅模式”（publish-subscribe pattern），<br>                           又称”观察者模式”（observer pattern）。<br>                           这种方法的性质与”事件监听”类似，但是明显优于后者。因为我们可以通过查看”消息中心”，了解存在多少信号、每个信号<br>                           有多少订阅者，从而监控程序的运行。<br>（4）Promises对象：是CommonJS工作组提出的一种规范，目的是为异步编程提供统一接口。简单说，它的思想是，每一个异步任务返回一个<br>                                  Promise对象，该对象有一个then方法，允许指定回调函数。回调函数变成了链式写法，程序的流程可以看得很清楚，而<br>                                  且有一整套的配套方法，可以实现许多强大的功能。<br>                                  例：f1的回调函数f2，f1().then(f2);</p><h5 id="66、Ajax和Flash的优缺点"><a href="#66、Ajax和Flash的优缺点" class="headerlink" title="66、Ajax和Flash的优缺点"></a>66、Ajax和Flash的优缺点</h5><p><strong>引用：<a href="http://www.awflasher.com/blog/archives/503">http://www.awflasher.com/blog/archives/503</a><br>Ajax的优势</strong></p><p><strong>可搜索性</strong><br>普通的文本网页会更有利于SEO。文本内容是搜索引擎容易检索的，而繁琐的swf字节码却是搜索引擎不愿触及的。虽然Google等一些大型的搜索引擎可以检索SWF内部的内容，但是仍然有很多麻烦存在。</p><p><strong>开放性</strong><br>Flash常年以来被Macromedia看的很死。包括Flex、FMS等辅佐技术一直都需要昂贵的安装、维护费用。而JS则没有这样的麻烦。没有人愿意承担法律和版权的风险。</p><p><strong>费用</strong><br>Flash开发是很昂贵的，因为FlashIDE等环境都是要收费的．而Ajax则不同．虽然有一些便宜的生成swf的工具，但是他们的工能实在无法满足复杂需求。</p><p><strong>易用性</strong><br>Ajax程序有更好的易用性。由于中间有一层Flashplayer***层，因此许多辅助功能无法被Flash灵活利用。而且Flash在一些方面有着不好的口碑。比如弹出广告、比如恶意代码。<br>（awflasher.com个人认为这八成是乱上xx网站造成的）</p><p><strong>易于开发</strong><br>人们开发复杂的Ajax和Flash应用程序时，都会借助一些高级的开发工具。普遍来说，Ajax的开发包比Flash简便、容易。</p><p><strong>Flash的优势</strong><br><strong>多媒体处理</strong><br>Flash在音频、视频等多媒体领域相比HTML有绝对的优势。现在几乎所有的网站都包含有Flash内容。</p><p><strong>兼容性</strong><br>兼容性好：由于通过了唯一的FlashPlayer“***”。人们不必像调试JS那样，在不同的浏览器中调试程序。</p><p><strong>矢量图型</strong><br>这是Flash最大的优势，同样处在这一领域的SVG、Canvas element以及Direct完全不能与Flash相比。</p><p><strong>客户端资源调度</strong><br>Flash能够更容易的调用浏览器以外的外部资源。比如摄像头、麦克风等。然而这是普通的HTML无法完成的。但是这也许是一个缺点（为什么呢？）</p><h5 id="67、ele-clientWidth-宽度-padding"><a href="#67、ele-clientWidth-宽度-padding" class="headerlink" title="67、ele.clientWidth = 宽度 + padding"></a>67、ele.clientWidth = 宽度 + padding</h5><p>ele.offsetWidth = 宽度 + padding + border</p><p> ele.scrollTop = 被卷去的上侧距离</p><p> ele.scrollHeight = 自身实际的高度（不包括边框）</p><h5 id="68-关于BFC"><a href="#68-关于BFC" class="headerlink" title="68.关于BFC"></a>68.关于BFC</h5><p>在一个Web页面的CSS渲染中，<a href="http://www.w3.org/TR/CSS21/visuren.html#block-formatting">块级格式化上下文</a> (Block Fromatting Context)是按照块级盒子布局的。W3C对BFC的定义如下：</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gams">浮动元素和绝对定位元素，非块级盒子的块级容器（例如 inline-blocks, <span class="hljs-keyword">table</span>-cells, 和 <span class="hljs-keyword">table</span>-captions），以及overflow值不为“visiable”的块级盒子，都会为他们的内容创建新的BFC（块级格式上下文）。<br></code></pre></td></tr></table></figure><p>为了便于理解，我们换一种方式来重新定义BFC。一个HTML元素要创建BFC，则满足下列的任意一个或多个条件即可：</p><p>1、float的值不是none。<br>2、position的值不是static或者relative。<br>3、display的值是inline-block、table-cell、flex、table-caption或者inline-flex<br>4、overflow的值不是visible</p><p>BFC是一个独立的布局环境，其中的元素布局是不受外界的影响，并且在一个BFC中，块盒与行盒（行盒由一行中所有的内联元素所组成）都会垂直的沿着其父元素的边框排列。</p>]]></content>
    
    
    <categories>
      
      <category>javascript、css、html</category>
      
    </categories>
    
    
    <tags>
      
      <tag>笔试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>学习贴</title>
    <link href="/2020/12/26/%E5%AD%A6%E4%B9%A0%E5%88%AB%E4%BA%BA%E7%9A%84%E9%9D%A2%E7%BB%8F/"/>
    <url>/2020/12/26/%E5%AD%A6%E4%B9%A0%E5%88%AB%E4%BA%BA%E7%9A%84%E9%9D%A2%E7%BB%8F/</url>
    
    <content type="html"><![CDATA[<p>经历了上次面试，我觉得遇到不会的点还是要踏踏实实的落实一遍，just do it！</p><a id="more"></a><h5 id="1、CSS居中的方法有哪些"><a href="#1、CSS居中的方法有哪些" class="headerlink" title="1、CSS居中的方法有哪些"></a>1、CSS居中的方法有哪些</h5><ul><li><p>水平居中</p><ul><li><p>行内元素</p><p>把行内元素放在一个属性块（display:block）元素中，然后设置父层元素属性居中：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.test</span>&#123;<br><span class="hljs-attribute">text-align</span>:center;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>块内元素</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.test</span>&#123;<br><span class="hljs-attribute">margin</span>: <span class="hljs-number">10px</span> auto<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>多个块状元素</p><ul><li>把块状元素属性（display:inline-block）,然后设置父层元素属性居中：</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.test</span>&#123;<br><span class="hljs-attribute">text-align</span>:center<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>flexbox布局实现：把块状元素的父元素属性display:flex和justify-content:center</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.test</span>&#123;<br>        <span class="hljs-attribute">display</span>:flex<br>        justify-content:center<br>    text-align:center;<br>    &#125;<br></code></pre></td></tr></table></figure></li></ul></li><li><p>垂直居中</p><ul><li><p>多行的行内元素</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.test</span>&#123;<br><span class="hljs-attribute">display</span>:table-cell;<br><span class="hljs-attribute">vertical-align</span>:middle;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>已知高度的块状元素</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.test</span>&#123;<br><span class="hljs-attribute">top</span>: <span class="hljs-number">50%</span>;<br><span class="hljs-attribute">margin-top</span>: -<span class="hljs-number">50px</span>;  <span class="hljs-comment">/* margin-top值为自身高度的一半*/</span><br><span class="hljs-attribute">position</span>:absolute;<br><span class="hljs-attribute">padding</span>:<span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li><li><p>水平垂直居中</p><ul><li>已知高度和宽度的元素</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs css">方法一：<br><span class="hljs-selector-class">.test</span>&#123;<br><span class="hljs-attribute">position</span>:absolute;<br><span class="hljs-attribute">margin</span>:auto;<br><span class="hljs-attribute">left</span>:<span class="hljs-number">0</span>;<br><span class="hljs-attribute">top</span>:<span class="hljs-number">0</span>;<br><span class="hljs-attribute">right</span>:<span class="hljs-number">0</span>;<br><span class="hljs-attribute">bottom</span>:<span class="hljs-number">0</span>;<br>&#125;<br><br>方法二：<br><span class="hljs-selector-class">.test</span>&#123;<br><span class="hljs-attribute">position</span>:absolute;<br><span class="hljs-attribute">top</span>:<span class="hljs-number">50%</span>;<br><span class="hljs-attribute">left</span>:<span class="hljs-number">50%</span>;<br><span class="hljs-attribute">margin-top</span>:-<span class="hljs-number">75px</span>;<span class="hljs-comment">/*设置margin-left、margin-top为自身高度和宽度的一半*/</span><br><span class="hljs-attribute">margin-left</span>:-<span class="hljs-number">75px</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>未知高度和宽度元素<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs css">方法一：<br><span class="hljs-selector-class">.test</span>&#123;<br><span class="hljs-attribute">position</span>:absolute:<br>top:<span class="hljs-number">50%</span><br>left:<span class="hljs-number">50%</span><br>transform:<span class="hljs-built_in">translate</span>(-<span class="hljs-number">50%</span>,-<span class="hljs-number">50%</span>)<span class="hljs-comment">/*使用css3的tranform来实现*/</span><br>&#125;<br><br>方法二：<br><span class="hljs-selector-class">.test</span>&#123;<br><span class="hljs-attribute">display</span>:flex;<br><span class="hljs-attribute">justify-content</span>:center;<br><span class="hljs-attribute">align-items</span>:center;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li></ul><h5 id="2、JS的基本数据类型"><a href="#2、JS的基本数据类型" class="headerlink" title="2、JS的基本数据类型"></a>2、JS的基本数据类型</h5><ul><li><p>undefined</p></li><li><p>null</p></li><li><p>string</p><ul><li><p>常用操作方法：</p><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>charAt( index)</td><td>返回在指定位置的字符。</td></tr><tr><td>charCodeAt(index)</td><td>返回指定的位置的字符的Unicode编码。</td></tr><tr><td>concat(str2……)</td><td>连接两个或更多字符串，并返回新的字符串。</td></tr><tr><td>fromCharCode(codeNumber)</td><td>将Unicode编码转为字符</td></tr><tr><td>indexOf(str)</td><td>返回某个指定的字符串值在字符串中首次出现的位置</td></tr><tr><td>includes(str)</td><td>查找字符串是否包含指定的字符串。</td></tr><tr><td>lastIndexof(str)</td><td>从后向钱搜索字符串，并从起始位置开始计算在字符串中出现的位置。</td></tr><tr><td>match(reg)</td><td>查找找到一个或多个正则表达式的匹配</td></tr><tr><td>repeat(Count)</td><td>复制字符串指定次数，并将它们连接在一起返回</td></tr><tr><td>replace(oriStr,repStr)</td><td>在字符串中查找匹配的子串，并替换与正则表达式匹配的子串</td></tr><tr><td>search(str)</td><td>查找与正则表达式匹配的值</td></tr><tr><td>slice(startN,endN)</td><td>提取字符串的片段，并在新的字符串中返回被提取的部分。</td></tr><tr><td>split(str)</td><td>把字符串分割为字符串数组</td></tr><tr><td>startsWith(str)</td><td>查看字符串是否以指定的字符串开头</td></tr><tr><td>substr(start,length)</td><td>从起始索引提取字符串中指定数目的字符</td></tr><tr><td>substring(start,end)</td><td>提取字符串中两个指定的索引号之间的字符</td></tr><tr><td>toLowerCase()</td><td>把字符串转换为小写</td></tr><tr><td>toUpperCase()</td><td>把字符串转换为大写</td></tr><tr><td>trim()</td><td>去除字符串两边的空白</td></tr><tr><td>toLocaleLowerCase()</td><td>根据本地主机的语言环境把字符串转换为小写</td></tr><tr><td>toLocaleUpperCase()</td><td>根据本地主机的语言环境把字符串转换为大写</td></tr><tr><td>valueOf()</td><td>返回某个字符串对象的原始值</td></tr><tr><td>toString()</td><td>返回一个字符串</td></tr></tbody></table></li></ul></li><li><p>boolean</p></li><li><p>number</p><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>isFinite</td><td>检测指定参数是否为无穷大</td></tr><tr><td>toExponential()</td><td>把对象的值转换为指数计数法</td></tr><tr><td>toFixed(num)</td><td>把数字转换为字符串，结果的小数点后有指定位数的数字</td></tr><tr><td>toPrecision()</td><td>把数字格式化为指定的长度</td></tr><tr><td>toString()</td><td>把数字转换为字符串</td></tr><tr><td>valueOf()</td><td>返回一个Number对象的基本数字值</td></tr></tbody></table><p>ES6新增Number方法</p><ul><li><p>Number.isInteger(Num):用来判断给定的参数是否为整数</p></li><li><p>Number.isSafeInteger(Num):判断传入的参数值是否是一个“安全整数”</p><p>安全整数范围为 -($2^{53}$ - 1)到 $2^{53}$ - 1 之间的整数，包含 -($2^{53}$ - 1)和 $2^{53}$ - 1。</p></li></ul></li><li><p>symbol(ES6)</p><p>ES5的对象属性名都是字符串，这容易造成属性名的冲突。比如，你使用了一个他人提供的对象，但又想为这个对象添加新的方法（mixin模式），新方法的名字就又可能与现有方法产生冲突。如果有一种机制，保证有一种机制，保证每个属性的名字都是独一无二的就好了，这样就根本上防止属性名的冲突。这就是ES6引入Symbol的原因。</p><p>加了参数之后，就易于区分。不利于区分。如果参数是一个对象，就会调用该对象的toString方法，将其转换为字符串，然后菜生产一个Symbol值。</p></li><li><p>object</p></li></ul><h5 id="3、数组有哪些方法"><a href="#3、数组有哪些方法" class="headerlink" title="3、数组有哪些方法"></a>3、数组有哪些方法</h5><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>concat(Arr1……)</td><td>连接两个或者更多的数组，并返回结果</td></tr><tr><td>copyWithin(target,start,end)</td><td>从target开始，换成后面的start到end</td></tr><tr><td>entries()</td><td>返回一个数组的迭代对象</td></tr><tr><td>every(function)</td><td>如果数组中检测到元素是否满足条件，如果一个不满足就不检测，返回false</td></tr><tr><td>fill(value,start,end)</td><td>从开始到结束用value填充</td></tr><tr><td>filter(function)</td><td>返回满足条件的全部元素，如果都不满足返回空数组</td></tr><tr><td>find(function)</td><td>可以返回第一个满足条件的元素</td></tr><tr><td>findIndex(function)</td><td>返回满足条件的第一个元素位置的下标</td></tr><tr><td>forEach(function(item,index))</td><td>方法用于调用数组的每个元素，并将该元素传给回调函数</td></tr><tr><td>from(obj)</td><td>将字符串生成一个数组</td></tr><tr><td>includes(SearchEle,start)</td><td>从指定位置开始查找需要查找的元素值，可以省略，从0 开始</td></tr><tr><td>indexOf(item,start)</td><td>返回数组中某个指定的元素的下标</td></tr><tr><td>isArray()</td><td>判断一个对象是否为数组</td></tr><tr><td>join(sep)</td><td>将数组变成字符串，然后插入sep分割</td></tr><tr><td>keys()</td><td>从数组中创建一个可迭代的对象，该对象包含数组的键（下标）</td></tr><tr><td>lastIndexOf(item,start)</td><td>指定元素子数组中出现的最后位置</td></tr><tr><td>map(function)</td><td>返回一个新数组，将数组中的元素为原始数组元素调用函数处理的值</td></tr><tr><td>pop()</td><td>删除数组的最后一个元素，并返回删除元素</td></tr><tr><td>push()</td><td>在数组末尾添加一个或多个元素，并返回新的长度</td></tr><tr><td>reduce(function（total,currentIndex）,initialValue)</td><td>接收一个函数作为累加器，数组中的每个值（从左往右开始缩减）</td></tr><tr><td>reduceRight()</td><td>和reduce一样，从右往左</td></tr><tr><td>reverse()</td><td>将数组中元素的顺序倒置</td></tr><tr><td>shift()</td><td>用于数组的第一个元素从中删除，并返回第一个元素的值</td></tr><tr><td>slice(start,end)</td><td>从start到end-1的选中元素</td></tr><tr><td>some(function(currentValue))</td><td>找到是否存在满足条件的元素，找到一个满足就返回true</td></tr><tr><td>sort(sortfuction)      sortfunciton(a,b){return a-b}小到大，return b-a 从大到小</td><td>按字母或数字的顺序按升序或降序排列</td></tr><tr><td>splice(index,howmany,item,itemX)</td><td>从index开始删除howmany个字符，可为0，插入item，itemX</td></tr><tr><td>toString()</td><td>将数组用，隔开</td></tr><tr><td>unshift(item,itemx)</td><td>向数组开头添加一个或者更多的元素，返回新的长度</td></tr><tr><td>valueOf()</td><td>返回Array对象的原始值</td></tr></tbody></table><h5 id="4、for……in和for……of的区别"><a href="#4、for……in和for……of的区别" class="headerlink" title="4、for……in和for……of的区别"></a>4、for……in和for……of的区别</h5><ul><li><p>for……in是ES5的标准，遍历key(属性名)，并且原型链上的所有属性也会被遍历。过滤原型链上的属性可以用hasOwnProperty()方法过滤。同时for……in遍历并不能保证顺序</p></li><li><p>for……of是ES6的标准，遍历value(属性值)，但是只能对数组使用，不可以对对象使用</p></li></ul><h5 id="5、数组去重"><a href="#5、数组去重" class="headerlink" title="5、数组去重"></a>5、数组去重</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> arr1 = [<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">3</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">4</span>,<span class="hljs-number">4</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">5</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">6</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">7</span>,<span class="hljs-number">7</span>]<br><span class="hljs-built_in">console</span>.log(arr1)<br><span class="hljs-keyword">var</span> arr2 = [];<br>arr1.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">val</span>)</span>&#123;<br><span class="hljs-keyword">if</span>(arr2.indexOf(val) === -<span class="hljs-number">1</span>)&#123;<br>arr2.push(val)<br>&#125;<br>&#125;)<br><span class="hljs-built_in">console</span>.log(arr2)<br><br><span class="hljs-comment">//方法2</span><br><span class="hljs-keyword">var</span> arr = [<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>]<br><span class="hljs-built_in">Array</span>.prototype.unique2 = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;  <br>            <span class="hljs-keyword">var</span> hash = [],<br>            n = [];<span class="hljs-comment">//hash 哈希表，n 为临时数组</span><br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">this</span>.length; i ++)&#123;<br>                <span class="hljs-keyword">if</span>(!hash[<span class="hljs-built_in">this</span>[i]])&#123;<br>                    hash[<span class="hljs-built_in">this</span>[i]] = <span class="hljs-literal">true</span>;<span class="hljs-comment">//存入哈希表</span><br>                    n.push(<span class="hljs-built_in">this</span>[i]);<span class="hljs-comment">//当前元素push到数组中</span><br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">return</span> n<br>        &#125;<br>        <span class="hljs-built_in">console</span>.log(arr.unique2())<br></code></pre></td></tr></table></figure><h5 id="6、使用闭包有什么问题"><a href="#6、使用闭包有什么问题" class="headerlink" title="6、使用闭包有什么问题"></a>6、使用闭包有什么问题</h5><ul><li><p>闭包的官方解释<br>一个拥有许多变量和绑定了这些变量的环境的表达式（通常是一个函数），因而这些变量也是该表达式的一部分。</p></li><li><p>闭包的定义<br>1、闭包就是能够读取其他函数内部变量的函数；<br>2、在javascript中，只有函数内部的子函数才能读取局部变量，所以闭包可以理解成“定义在一个函数内部的函数“；<br>3、在本质上，闭包是将函数内部和函数外部连接起来的桥梁。</p></li><li><p>闭包的用途<br>1、能够读取函数内部的变量；<br>2、让这些变量的值始终保持在内存中。</p></li><li><p>闭包需要注意什么<br>1、闭包会使函数中的变量保存在内存中，内存消耗很大。所以不能滥用闭包，否则会造成网页的性能问题，在IE中可能导致内存泄漏。解决办法是，在退出函数之前，将不使用的局部变量删除。<br>2、闭包会在父函数外部，改变父函数内部变量的值。所以，如果把父函数当做对象使用，把闭包当作它的公用方法，把内部变量当作它的私有属性，这时要注意不要随便改变父函数内部变量的值。</p></li><li><p>闭包的应用场景<br>1、保护函数内部变量的安全；<br>2、通过保护变量安全实现JS私有属性和私有方法不能被外部访问；<br>3、使用闭包代替全局变量，防止变量污染。</p></li><li><p>闭包的优点<br>1、变量长期驻扎在内存中；<br>2、避免全局变量的污染；<br>3、私有成员的存在。</p></li><li><p>闭包的缺点<br>1、常驻内存中，会增大内存的使用量；</p></li></ul><h5 id="7、原生的dom操作"><a href="#7、原生的dom操作" class="headerlink" title="7、原生的dom操作"></a>7、原生的dom操作</h5><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>document.createElement(TagName)</td><td>创建新元素</td></tr><tr><td>document.getElementById(“Id”)</td><td>按照ID查询</td></tr><tr><td>element.getElementsByClassName()  ie9+</td><td>按照Class查询</td></tr><tr><td>element.querySelectorAll()         ie8</td><td>按照Class查询</td></tr><tr><td>element.getElementsByTagName()   ie6+</td><td>按照Tag查询</td></tr><tr><td>element.parentNode()</td><td>获取父节点</td></tr><tr><td>element.childNode()</td><td>获取子节点</td></tr><tr><td>parentElement.appendChild(child)</td><td>添加到最后面</td></tr><tr><td>parentElement.insertBefore(newElement,Element)</td><td>newElement添加到elemnt前面</td></tr><tr><td>element.style.css</td><td>修改css</td></tr><tr><td>element.setAttribute()</td><td></td></tr><tr><td>element.removeAtrribute()</td><td></td></tr><tr><td>element.lacssNam</td><td></td></tr></tbody></table><h5 id="8、inline-block和inline和block区别"><a href="#8、inline-block和inline和block区别" class="headerlink" title="8、inline-block和inline和block区别"></a>8、inline-block和inline和block区别</h5><ul><li><strong>inline</strong>：使元素变成行内元素（内联），拥有行内元素的特性，即</li></ul><ol><li>与其他行内元素共享一行</li><li>不能修改width、height属性，大小由内容撑开</li><li>padding属性 top、right、botto、left设置都有效；margin属性只有left、right设置有效</li></ol><ul><li><strong>block</strong>： 使元素变成块级元素，拥有块级的特性，即</li></ul><ol><li>独占一行，在不设置自己的宽度的情况下，块级元素会默认填满父级元素的宽度</li><li>可以修改width、height属性</li><li>padding、margin四个方向的值设置均有效</li></ol><ul><li><strong>inline-block</strong>： 使元素变成行内块级元素，结合了行内元素和块级元素的特性（不独占一行的块级元素），即</li></ul><ol><li>与其他行内元素共享一行</li><li>可以修改width、height属性</li><li>padding、margin四个方向的值设置均有效</li></ol><p>注意：当多个inline-block的元素写在一起时，是否换行效果不同（换行后两者中间会有间距），如img、button标签，这也是代码经过压缩后效果与开发版本不同的原因之一，解决方案是去除换行</p><h5 id="9、什么是非对称加密"><a href="#9、什么是非对称加密" class="headerlink" title="9、什么是非对称加密"></a>9、什么是非对称加密</h5><ul><li>非对称加密：加密算法需要两个密钥进行加密和解密，这两个密钥是公开密钥和私有密钥</li><li>加密和解密使用的是同一个密钥</li></ul><h5 id="10、CSS3动画"><a href="#10、CSS3动画" class="headerlink" title="10、CSS3动画"></a>10、CSS3动画</h5><p>Css3可以创建动画，它可以取代许多页面动画图像、Flash动画和JavaScript实现的效果</p><p>CSs3 @Keyframes规则</p><ul><li><p>@Keyframes的规则是创建动画：当在@Keyframes创建动画，把它绑定到一个选择器，否则动画不会有任何效果。指定至少这两个CSS3的动画属性绑定向一个选择器。</p><ul><li><p>规定动画的名称</p></li><li><p>规定动画的时长</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">div</span><br>&#123;<br><span class="hljs-attribute">animation</span>: myfirst <span class="hljs-number">5s</span><span class="hljs-comment">/*您必须定义动画的名称和动画的持续时间。如果省略的持续时间，动画将无法运行，因为默认值是0*/</span><br>-webkit-animation:myfirst <span class="hljs-number">5s</span>; <span class="hljs-comment">/*Safari与Chrome*/</span><br>    <br>&#125;<br></code></pre></td></tr></table></figure></li></ul></li><li><p>@Keyframes规则内指定一个Css样式和动画将逐步从目前的样式更改为新的样式。</p><ul><li>Css3动画是什么？动画是使元素从一种样式逐渐变化为另一种样式的效果。</li></ul><p>您可以改变任意多的样式任意多的次数。</p><p>请用百分比来规定<code>发生的时间</code>,或用关键词“from”和”to“，等同于0%和100%</p><p>0%是动画的开始，100%是动画的完成。</p><p>为了得到最佳的浏览器支持，您应该始终定义0%和100%的选择器</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-keyword">@keyframes</span> myfirst<br>&#123;<br>0% &#123;<span class="hljs-attribute">background</span>:red; <span class="hljs-attribute">left</span>:<span class="hljs-number">0px</span>; <span class="hljs-attribute">top</span>:<span class="hljs-number">0px</span>;&#125;<br>25%&#123;<span class="hljs-attribute">background</span>:yellow; <span class="hljs-attribute">left</span>:<span class="hljs-number">200px</span>; <span class="hljs-attribute">top</span>:<span class="hljs-number">0px</span>;&#125;<br>50%&#123;<span class="hljs-attribute">background</span>:blue; <span class="hljs-attribute">left</span>:<span class="hljs-number">200px</span>; <span class="hljs-attribute">top</span>:<span class="hljs-number">200px</span>;&#125;<br>100%&#123;<span class="hljs-attribute">background</span>:green; <span class="hljs-attribute">left</span>:<span class="hljs-number">0px</span>; <span class="hljs-attribute">top</span>:<span class="hljs-number">0px</span>;&#125;<br>&#125;<br><br><span class="hljs-keyword">@-webkit-keyframes</span> myfirst /*Safari与Chrome*/<br>&#123;<br>0% &#123;<span class="hljs-attribute">background</span>:red; <span class="hljs-attribute">left</span>:<span class="hljs-number">0px</span>; <span class="hljs-attribute">top</span>:<span class="hljs-number">0px</span>;&#125;<br>25%&#123;<span class="hljs-attribute">background</span>:yellow; <span class="hljs-attribute">left</span>:<span class="hljs-number">200px</span>; <span class="hljs-attribute">top</span>:<span class="hljs-number">0px</span>;&#125;<br>50%&#123;<span class="hljs-attribute">background</span>:blue; <span class="hljs-attribute">left</span>:<span class="hljs-number">200px</span>; <span class="hljs-attribute">top</span>:<span class="hljs-number">200px</span>;&#125;<br>100%&#123;<span class="hljs-attribute">background</span>:green; <span class="hljs-attribute">left</span>:<span class="hljs-number">0px</span>; <span class="hljs-attribute">top</span>:<span class="hljs-number">0px</span>;&#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><p>@keyframes规则和所有动画属性</p><table><thead><tr><th>属性</th><th>描述</th></tr></thead><tbody><tr><td>@keyframes</td><td>规定动画</td></tr><tr><td>animation</td><td>所有动画属性的简写属性。</td></tr><tr><td>animation-name</td><td>规定@keyframes动画的名称</td></tr><tr><td>animation-duration</td><td>规定动画完成一个周期所花费的秒或毫秒</td></tr><tr><td>animation-timing-function</td><td>规定动画的速度曲线。默认是”ease“</td></tr><tr><td>animation-fill-mode</td><td>规定当动画不播放时（当动画完成时，或当动画有一个延迟未开始播放时）元素的样式</td></tr><tr><td>animation-delay</td><td>规定动画何时开始，默认是0。</td></tr><tr><td>animation-iteration-count</td><td>规定动画被播放的次数。默认是1。</td></tr><tr><td>animation-direction</td><td>规定动画是否在下一周期逆向地播放。默认是”normal“。</td></tr><tr><td>animation-play-state</td><td>规定动画是否正在运行或暂停。默认是”running“</td></tr></tbody></table><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">div</span><br>&#123;<br>    <span class="hljs-attribute">animation-name</span>: myfirst;<br>    <span class="hljs-attribute">animation-duration</span>: <span class="hljs-number">5s</span>;<br>    <span class="hljs-attribute">animation-timing-function</span>: linear;<br>    <span class="hljs-attribute">animation-delay</span>: <span class="hljs-number">2s</span>;<br>    <span class="hljs-attribute">animation-iteration-count</span>: infinite;<br>    <span class="hljs-attribute">animation-direction</span>: alternate;<br>    <span class="hljs-attribute">animation-play-state</span>: running;<br>    <span class="hljs-comment">/* Safari 与 Chrome: */</span><br>    <span class="hljs-attribute">-webkit-animation-name</span>: myfirst;<br>    <span class="hljs-attribute">-webkit-animation-duration</span>: <span class="hljs-number">5s</span>;<br>    <span class="hljs-attribute">-webkit-animation-timing-function</span>: linear;<br>    <span class="hljs-attribute">-webkit-animation-delay</span>: <span class="hljs-number">2s</span>;<br>    <span class="hljs-attribute">-webkit-animation-iteration-count</span>: infinite;<br>    <span class="hljs-attribute">-webkit-animation-direction</span>: alternate;<br>    <span class="hljs-attribute">-webkit-animation-play-state</span>: running;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="11、事件冒泡和事件捕获"><a href="#11、事件冒泡和事件捕获" class="headerlink" title="11、事件冒泡和事件捕获"></a>11、事件冒泡和事件捕获</h5><p>事件是文档和浏览器窗口中发生的</p><h5 id="12、transition属性"><a href="#12、transition属性" class="headerlink" title="12、transition属性"></a>12、transition属性</h5><p>transition属性设置元素当过渡效果，四个简写属性为：</p><ul><li>transition-property      指定Css属性的name,transition效果</li><li>transition-duration       transition效果需要指定多少秒或毫秒才能完成</li><li>transition-timing-function       指定transition效果的转速曲线</li><li>transition-delay             定义transition效果开始的时候</li></ul>]]></content>
    
    
    <categories>
      
      <category>javascript、css</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学习笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>西安腾讯前端一面试总结</title>
    <link href="/2020/12/25/%E8%85%BE%E8%AE%AF%E8%A5%BF%E5%AE%89%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93%E4%B8%80%E9%9D%A2/"/>
    <url>/2020/12/25/%E8%85%BE%E8%AE%AF%E8%A5%BF%E5%AE%89%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93%E4%B8%80%E9%9D%A2/</url>
    
    <content type="html"><![CDATA[<a id="more"></a><p>事发突然很难受，刚睡醒，就接到腾讯面试官的电话，之前一直在想面试会问啥，其实这次面试并不能，出乎意料的简单，但是错失了机会。基础问题，被说安全基础差，踏实学习吧。之前一直浮躁，从没用认识思考基础知识，而且这是第一次面试，超级紧张。</p><p>现在回顾复盘一下问了一些什么，附带应该有的回答</p><h5 id="1、你什么时候开始学习前端的，项目经历"><a href="#1、你什么时候开始学习前端的，项目经历" class="headerlink" title="1、你什么时候开始学习前端的，项目经历"></a>1、你什么时候开始学习前端的，项目经历</h5><h5 id="2、你从输出一个url到看到页面经过的过程"><a href="#2、你从输出一个url到看到页面经过的过程" class="headerlink" title="2、你从输出一个url到看到页面经过的过程"></a>2、你从输出一个url到看到页面经过的过程</h5><ul><li>输入网址：浏览器在输入网址的时候，就可能只能的匹配url</li><li>DNS解析：详细见4问（回答的不具体，然后展开又问了一下）</li><li>建立TCP连接</li><li>向客户端发起HTTP请求</li><li>服务器处理请求</li><li>服务器响应</li><li>浏览器展示HTML</li></ul><h5 id="3、页面渲染的过程"><a href="#3、页面渲染的过程" class="headerlink" title="3、页面渲染的过程"></a>3、页面渲染的过程</h5><ul><li><p>根据html文件构建DOM树和CSSOM树。构建DOM树期间，如果遇到JS,阻塞DOM树及CSSOM树的构建，优先加载JS文件，加载完毕后，继续再构建DOM树及CSSOM树</p></li><li><p>构建渲染树</p></li><li><p>页面的重绘与重排。页面渲染完成后，若JS操作了DOM节点，根据JS对DOM操作动作的大小，浏览器会对页面进行重绘和重排</p><p>（<code>重排</code>：由于布局的改变引起的页面重新渲染     <code>重绘</code>：由于样式的改变引起的页面重新渲染）</p></li></ul><h5 id="4、DNS具体解析的过程"><a href="#4、DNS具体解析的过程" class="headerlink" title="4、DNS具体解析的过程"></a>4、DNS具体解析的过程</h5><ol><li><p>首先会在本机的hosts的文件里寻找，如果没用就向本地DNS服务器进行递归查询</p></li><li><p>本地服务器采用迭代查询。它向一个根域名服务器查询。</p></li><li><p>根域名服务器告诉本地服务器，下一次查询的顶级域名服务器的ip地址</p></li><li><p>本地域名服务器向顶级域名服务器查询</p></li><li><p>顶级域名服务器告诉本地域名服务器下一把的权限服务器的ip地址</p></li><li><p>本地域名服务器向权限服务器进行查询。</p></li><li><p>权限服务器告诉本地服务器所查的主机的ip地址</p></li><li><p>本地域名服务器把查询结果告诉主机</p><p>整个过程共用到8个UDP报文</p></li></ol><h5 id="5、三次握手、四次挥手的细节"><a href="#5、三次握手、四次挥手的细节" class="headerlink" title="5、三次握手、四次挥手的细节"></a>5、三次握手、四次挥手的细节</h5><ul><li>三次握手<ol><li>客户端发送syn包（seq=x）到服务器，并进入SYN_SEND状态，等待服务器确认</li><li>服务器收到syn包，必须确认客户的SYN（ack=x+1），同时自己页发送一个SYN包（seq=y）,即SYN+ACK包，此时服务器进入SYN_RECV状态</li><li>客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack=y+1)，此包发送完毕，客户端和服务器进入Established状态</li></ol></li><li>四次挥手<ol><li>主动关闭方发送一个FIN，用来关闭主动方到被动关闭方的数据传送，也就是主动关闭方告诉被动关闭方：我已经不会再给你发送数据了（当然，再FIN包之前发送出去的数据，如果没用收到对应的ack确认报文，主动关闭方依然会重发这些数据），但是此时主动关闭方还可以接受数据</li><li>被动关闭方收到FIN包后，发送一个ACK给对方，确认序号为收到序号+1（与SYN相同，一个FIN占用一个序号）</li><li>被动关闭方发送一个FIN,用来关闭被动关闭方到主动关闭方的数据传送，也就是告诉主动关闭方，我的数据页发送完了，不会再给你发送数据了。</li><li>主动关闭方收到FIN后，发送一个ACK给被动关闭方，确认序号为收到序号+！，至此，完成四次挥手</li></ol></li></ul><p>既然都到这里了，我们把传输过程中的问题页一并复习了吧</p><ul><li>超时重传：超时重传机制用来保障TCP传输的可靠性。每次发送数据包时，发送的数据宝都有seq号，接受端收到数据后，会回复ack进行确认，表示某一seq号数据已经收到。发送方在发送了某个seq包后，等待一段时间，如果没有收到对应的ack回复，就会认为报文丢失，会重传这个数据包。</li><li>快速重传：接受数据一方发现有数据包丢失掉了，就会发送ack报文告诉发送方重传丢失的报文。如果发送端连续收到标号相同的ack包，则会触发发送端的快速重传。（超时重传就类似于发送端傻等超时，而快速重传就类似接受端主动告诉发送端，没收到，而触发超时重传）</li><li>流量控制：这里主要说TCP的滑动窗口流量控制。TCP头有个字段叫WIndow，由叫Advertised-Window,这个字段是接受端告诉发送端自己还有多少缓冲区可以接受数据。于是发送端就可以根据这个接受端的处理能力来发送数据，而不会导致接收端处理不过来。滑动窗口可以提高TCP传输效率的一种机制。</li><li>拥塞控制：滑动窗口用来做流量控制。流量控制只会关注发送端和接受端自身的状况，而没有考虑整个网络的通信情况。拥塞控制，则是基于整个网络来考虑的。考虑一下这样的场景：某个时刻网络上的延时突然增加，那么，TCP对这个事做出的应对只有重传数据，但是，重传会导致网络负担更重，于是会导致更大的延迟以及更多丢包，于是，这种情况会进入恶心循环被不断地放大。试想一下，如果一个网络内有成千上万的TCP连接都这样行事，会马上形成“网络风暴”,TCP这个协议就会拖垮整个网络。为此TCP就引入了拥塞控制策略。拥塞策略算法主要包括：慢启动，拥塞避免，快重传，快速恢复。<ul><li>慢开始：刚开始发送方维护一个拥塞窗口，大小等于发送窗口，通过出现了超时来判断网络出现拥塞。慢开始的思路是一开始发送方发送一个字节，在收到接受方的确认，然后发送的字节数量增大一倍（就是以指数增长的速率），逐步增大拥塞窗口，当拥塞窗口到达满开始门限，停止慢开始算法，开始拥塞避免算法。</li><li>拥塞避免：拥塞避免的增长速率变成线性增长，也就是每经过一个往返时间RTT就把发送方的拥塞窗口加1</li><li>快重传：上述两个算法使得网络传输速率一直增大，直至出现<code>超时</code>，这时候需要将<code>拥塞窗口</code>重新调整到1字节开始，使用<code>慢开始算法</code>，同时需要将<code>慢开始门限</code>调整为<code>超时</code>时的<code>拥塞窗口</code>大小的<code>一半</code>,继续执行慢开始算法、拥塞避免算法。</li><li>快恢复：如果收到了连续3个对同一报文的重复确认，此时可能发生了报文缺失，发送方不执行慢开始算法，直接使用<code>快重传算法</code>，立即发送缺失的报文段。同时执行快恢复算法，将门限值调整为此时拥塞窗口的一半，并执行拥塞避免算法</li></ul></li></ul><h5 id="6、前端安全的问题有哪些，具体防范措施"><a href="#6、前端安全的问题有哪些，具体防范措施" class="headerlink" title="6、前端安全的问题有哪些，具体防范措施"></a>6、前端安全的问题有哪些，具体防范措施</h5><ul><li><p>跨站脚本攻击（XSS攻击）：跨站脚本攻击，指的是恶意攻击者往Web页面里插入恶意html代码，当用户浏览该页之时，嵌入其中Web里面的html代码会被执行，从而达到用户的特殊目的。</p><p><code>预防措施</code>:输入过滤，对用户提交的数据进行有效性验证。</p><ul><li><p>过滤一些些常见的敏感字符，例如：&lt; &gt; ‘ “ &amp; # \ javascript expression ；</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">.replace(<span class="hljs-regexp">/src=&quot;javascript:/g</span>, <span class="hljs-string">&#x27;src=&quot;&#x27;</span>).replace(<span class="hljs-regexp">/src=&#x27;javascript:/g</span>, <span class="hljs-string">&#x27;src=\&#x27;&#x27;</span>)<br></code></pre></td></tr></table></figure></li><li><p>过滤或移除特殊的Html标签， 例如: <code>&lt;script&gt;</code>, <code>&lt;iframe&gt;</code> </p></li><li><p>过滤JavaScript 事件的标签，例如 “onclick=”, “onfocus”</p></li><li><p>通过http-only Cooke禁止读取某些敏感Cookies</p></li><li><p>在关键业务部分增加验证码，防止脚本冒充用户提交危险操作</p></li></ul><p>输出编码：当需要将一个字符串输出到Web网页时，同时又不确定这个字符串中是否包括XSS特殊字符（如&lt; &gt; &amp;‘”等），为了确保输出内容的完整性和正确性，可以使用编码（HTMLEncode）进行处理。</p></li><li><p>SQL语句注入</p></li><li><p>跨站请求伪造（CSRF攻击）</p></li><li><p>文件上传</p><p>xss参考链接：<a href="https://www.cnblogs.com/for-easy-fast/articles/12956062.html">https://www.cnblogs.com/for-easy-fast/articles/12956062.html</a></p></li></ul><h5 id="7、XSS具体是如何发动攻击的"><a href="#7、XSS具体是如何发动攻击的" class="headerlink" title="7、XSS具体是如何发动攻击的"></a>7、XSS具体是如何发动攻击的</h5><ul><li><p>分类：XSS分为反射型、存储型、及DOM-based型，其中反射型和DOM-based型可以归为非持久XSS攻击类型。存储型可以归类为持久性XSS攻击</p><ul><li><p>反射型XSS:一般指攻击者通过特定的方式来诱惑受害者去访问一个包含恶意代码的URL。当受害者点击恶意链接url的时候，恶意代码会直接在受害者的主机上的浏览器执行。</p><p>那么为什么要叫反射型呢？因为这种攻击方式的注入代码是从目标服务器通过错误信息，搜索结果等方式反射回来的，而为什么又叫非持久性XSS呢？因为这种攻击方式只有一次性。</p><p>攻击步骤如下</p><ol><li>攻击者在url后面的参数中加入恶意攻击代码</li><li>当用户打开带有恶意代码的URL的时候，网址服务器将恶意代码从URL中取出，拼接在html中并返回给浏览器端</li><li>用户浏览器接受到响应后执行解析，其中的恶意代码也会被执行到。</li><li>攻击者通过恶意代码来窃取到用户数据并发送到攻击者的网址。攻击者会获取到比如cookie等信息，然后使用该信息来冒充合法用户的行为，调用目标网站接口执行攻击等操作。</li></ol></li><li><p>存储型XSS:如果有一个博客网站，攻击者在上面发布一篇文章，如果不对文章进行任何处理就存入数据库，那么下次，其他用户访问该文章的时候，服务器就会读取然后响应给客户端，那么浏览器就会执行该段脚本，然后攻击者就会获取用户的cookie，然后会把cookie发送到攻击者的服务器上了。</p><p>攻击步骤如下:</p><ol><li>攻击者将恶意代码提交到目标网站数据库中</li><li>用户打开目标网站时，网站服务器将恶意代码从数据库中取出，然后拼接成html中返回给浏览器。</li><li>用户浏览器接受到响应后解析执行，其中恶意代码也会被执行。</li><li>那么恶意执行代码后，就能获取到用户数据，比如上面的cookie等信息，那么把该cookie发送到攻击者网站中，那么攻击者拿到该cookie然后会冒充该用户的行为，调用目标网站接口等违法操作。</li></ol><p>防范措施：后端需要对提交的数据进行过滤</p><p>前端页可以做一下处理方式，比如对script标签，将特殊字符替换成HTML编码等。</p></li><li><p>DOM-based型xss:我们客户端的js可以对页面dom节点进行动态的操作，比如插入、修改页面的内容。比如说客户端从URL中提取数据并且在本地执行、如果用户在客户端输入的数据包含了恶意的js脚本的话，但是这些脚本又没有做任何过滤处理的话，那么我们的应用程序就又可能收到DOM-based XSS的攻击。</p><p>攻击步骤如下：</p><ol><li>攻击者构造出特殊的URL、在其中可能包含恶意代码。</li><li>用户打开带有恶意的代码的URL</li><li>用户浏览器收到响应后解析执行。前端使用js取出url的恶意代码并执行。</li><li>执行时，，恶意代码窃取用户数据并发送到攻击者的网站中，那么攻击者网站拿着这些数据去冒充用户的行为操作。调用目标网站接口执行攻击者的一些操作。</li></ol><p>一般又如下的DOM操作</p><ul><li><p>document.write</p></li><li><p>innerHTML</p></li><li><p>location、location.href、location.replace、iframe.src、document.referer、window.name</p><p>因此我们需要对HTML进行编码，对JS进行编码来防止这些问题产生。</p></li></ul><p>参考链接：<a href="https://www.cnblogs.com/tugenhua0707/p/10909284.html#_labelTop">https://www.cnblogs.com/tugenhua0707/p/10909284.html#_labelTop</a></p><p><a href="https://www.cnblogs.com/mmy67/p/9923422.html">https://www.cnblogs.com/mmy67/p/9923422.html</a></p></li></ul></li></ul><h5 id="8、有哪些页面优化的手段，从框架啊、代码的角度说"><a href="#8、有哪些页面优化的手段，从框架啊、代码的角度说" class="headerlink" title="8、有哪些页面优化的手段，从框架啊、代码的角度说"></a>8、有哪些页面优化的手段，从框架啊、代码的角度说</h5><ul><li><p>资源压缩，减少http请求：合并css、合并javascript、合并图片（精灵图片的使用：例如微博上有很多的小图标，浏览器上的图片很多都是从服务器上获取的，如果分别存放在服务器上，就会增加很多的请求），同时使用Gzip压缩可以达到比较好的效果，但是如果服务器的资源不足的时候，但是通信带宽良好需要权衡考虑。</p></li><li><p>使用CDN:在浏览器第一次打开页面时，缓存是起不了作用的。这时候，CDN就很有用（CDN的本质仍然是一个缓存，而且将数据缓存在离用户最近的地方，使用户以最快的速度获取数据，就是所谓的网络访问第一跳，由于CDN部署在网络运营商的机房，这些运营商又是终端用户的网络服务提供商，因此用户请求路由的第一跳就到达了CDN服务器）</p></li><li><p>图片较多的页面可以使用lazyLoad等技术优化</p></li><li><p>非核心代码异步加载：不用立即使用的js代码可以采用异步加载</p></li><li><p>利用浏览器缓存:Css、javascript、logo、图标这些静态资源文件更新的频率都比较低，而且这些文件几乎每次http请求都需要的，如果将这些文件缓存在浏览器中，可以极好的改善性能。通过设置http头中的<code>cache-control</code>和<code>expires</code>属性，可设定浏览器缓存，缓存时间可以是几天，甚至是几个月。</p><p>但是某些时候，静态资源文件变化需要及时应用到客户端浏览器，这种情况，可以通过改变文件名实现，即更新javascript文件并不是更新javascript文件内容，而是生成一个新的JS文件并更新HTML文件中的引用。</p><p>使用浏览器缓存策略的网站在更新静态资源时，应该采用逐量更新的方法，比如需要更新1-个图标文件，不应当把10个文件一次全部更新，而是应该一个文件一个文件逐步更新，并有一定的间隔时间，以避免用户浏览器突然大量缓存失效，集中更新缓存，造成服务器负载骤增、网络堵塞的情况。</p></li><li><p>DNS预解析</p></li><li><p>Css尽量放在上方，javascript尽量放在下方：浏览器在下载完全部Css之后，才会对整个页面进行渲染，因此最好的做法是将Css放在页面的最上方（<code>&lt;head&gt;</code>）如果将Css放在Body中，则浏览器可能还未下载和解析到Css就已经开始渲染页面了，这就导致页面可能会从无Css状态跳转到有Css状态，用户体验会比较差。相反，JavaScript在浏览器加载javascript之后立即执行，有可能会阻塞整个页面，造成页面显示缓慢，因此javascript最好放在页面最下面。如果页面解析的时候就需要用到javascript，这时放在下面就不是很合适。</p></li><li><p>减少cookie传输：太大的cookie会严重影响数据传输，因此哪些数据需要写入cookie需要慎重考虑，尽量减少cookie中 传输量。另一方面。对于某些静态资源的访问，发送cookie没有意义，可以考虑静态资源使用独立域名去访问，避免请求静态资源时发送cookie，减少cookie传输次数</p></li><li><p>Javascript代码优化</p><ul><li><p>Dom：</p><ol><li>HTMl Collection（HTMl收集器，返回的是一个数组内容信息）在脚本中document.images、document.forms、getElementsByTagName()返回的都是HTMLCollection类型的集合，在平时使用的时候大多将它作为数组来使用，因为它有length属性，也可以使用索引来访问每个元素。不过在访问性能上比数组差很多，原因是这个集合并不是一个静态的结果，它表示的仅仅是一个特定的查询，每次访问该集合时都会重新执行这个查询从而更新查询的结果。所谓的<code>访问集合</code>包括读取集合的length属性、访问集合里的元素。 因此，当你需要遍历HEML Collection的时候，尽量将它转为数组再去访问，以提高性能。即使不转变成为数组，也尽可能的少访问它，例如在遍历的时候可以将length属性、成员保存到局部变量后再使用局部变量。</li><li>DOM操作还需要考虑浏览器的回流和重绘，应位哪都需要消耗资源的。</li></ol></li><li><p>慎用with</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-title">with</span>(<span class="hljs-params">obj</span>)</span>&#123;<br>p = <span class="hljs-number">1</span><br>&#125;;<br></code></pre></td></tr></table></figure><p>代码块的行为实际上的修改了代码块中的执行环境，将obj放在了其作用域链的最前端，在with代码块中访问非局部变量是都是先从obj上开始查找，如果没有再依次按作用链域向上查找，因此使用with相当于增加了作用域链长度。而每次查找作用域链都是要消耗时间的，过长的作用域链会导致查找性能下降。因此，除非你能肯定在with代码中只访问obj中的属性，否则慎用with，替代的可以使用局部变量来缓存需要访问的属性。</p></li><li><p>避免使用eval和Function</p><p>每次eval或Function构造函数作用于字符串表示的源代码时，脚本引擎都需要将源代码转换成可执行代码。这是很消耗资源的操——通常比简单的函数调用慢100倍以上。</p><p>eval函数效率特别低，由于事先无法知晓上下文，因此只能有浏览器在运行时解释代码。这对性能影响很大。Function构造函数也比eval略好，因为使用此代码不会影响周围代码，但是速度仍然很慢，此外，使用eval和Function也不利于Javascript压缩攻击执行压缩。</p></li><li><p>减少作用域查找</p><p>在循环的时候尤其需要注意的问题。如果在循环中需要访问非本作用域下的变量时请在遍历之前用局部变量缓存该变量，并在遍历结束后再重写那个变量，这一点对全局变量尤其重要，因为全局变量处于作用域链的最顶端，访问时的查找次数是最多的。此外，要减少作用域链查找还应该减少闭包的使用。</p></li><li><p>字符串拼接，使用<code>+</code>号来拼接字符串的效率比较低，因此相比较之下可以使用数组的join方法，将需要拼接的字符串放在数组中最后调用join方法得到结果。但是数组也有一定的开销，因此需要拼接的字符串较多的时候可以考虑用此方法。</p></li></ul></li><li><p>反向代理服务器：传统代理服务器位于浏览器以测，代理浏览器将http请求发送到互联网上，而反向代理服务器位于网站机房以测，代理网站web服务器接收http请求。和传统代理服务器可以保护浏览器安全一样，反向代理服务器也具有保护网站安全的作用，来自互联网的请求必须经过代理服务器，相当于web服务器和可能的网络攻击之间建立了一个屏障。除了安全功能代理服务器也可以通过配置缓存功能加速web请求。当用户第一次访问静态内容的时候，静态内容就被缓存在反向代理服务器上，这样当用户访问该静态能让的时候，就可以直接从反向代理服务器返回，加速web请求速度，减轻web服务器负载压力。事实上，有些网站会把动态内容也缓存在代理服务器上，比如维基百科和一些博客论坛网站，把热门词条、帖子、博客缓存在反向代理服务器上加速用户访问速度，当这些动态内容有变化的时，通过内部通知反向代理缓存失效，反向代理会重新加载最新的动态内容再次缓存起来。</p><p>此外，反向代理也可以实现负载均衡的功能，而通过负载均衡构建的应用集群可以提高系统总体处理能力，进而改善网站高并发情况下的性能。</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>面经</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面经</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Interview Summary</title>
    <link href="/2020/12/13/Css3%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/"/>
    <url>/2020/12/13/Css3%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<p>Css问题汇总</p><a id="more"></a><h5 id="1、Css的选择器"><a href="#1、Css的选择器" class="headerlink" title="1、Css的选择器"></a>1、Css的选择器</h5><table><thead><tr><th>选择器</th><th>用法</th></tr></thead><tbody><tr><td>id选择器</td><td>#myid</td></tr><tr><td>类选择器</td><td>.myclassname</td></tr><tr><td>标签选择器</td><td>div,h1,p</td></tr><tr><td>相邻选择器</td><td>h1+p</td></tr><tr><td>子选择器</td><td>ul &gt; li</td></tr><tr><td>后代选择器</td><td>li a</td></tr><tr><td>通配符选择器</td><td>*</td></tr><tr><td>属性选择器</td><td>a[rel=”external”]</td></tr><tr><td>伪类选择器</td><td>a:hover, li:nth-child</td></tr></tbody></table><h5 id="2、样式层叠次序"><a href="#2、样式层叠次序" class="headerlink" title="2、样式层叠次序"></a>2、样式层叠次序</h5><p>当同一个 HTML 元素定义了多个样式时，应该使用哪个样式？</p><p>一般而言，所有的样式会根据下面的规则层叠于一个新的虚拟样式表中，其中数字 4 拥有最高的优先权。</p><ol><li>浏览器缺省设置</li><li>外部样式表（在<code>&lt;head&gt;和&lt;/head&gt;之间的link中</code>）</li><li>内部样式表（位于 <code>&lt;head&gt;</code> 标签内部）</li><li>内联样式（在 HTML 元素内部）</li></ol><p>因此，内联样式（在 HTML 元素内部）拥有最高的优先权，这意味着它将优先于以下的样式声明： 标签中的样式声明，外部样式表中的样式声明，或者浏览器中的样式声明（缺省值）。</p><p>注： CS 选择器有修饰上的优先级，即：</p><p>内联选择器 &gt; id选择器 &gt; 类选择器 &gt; 标签选择器</p><h5 id="3、多重样式优先级顺序"><a href="#3、多重样式优先级顺序" class="headerlink" title="3、多重样式优先级顺序"></a>3、多重样式优先级顺序</h5><p>下列是一份优先级逐级增加的选择器列表，其中数字 7 拥有最高的优先权：</p><ol><li>通用选择器（*）</li><li>元素(类型)选择器</li><li>类选择器</li><li>属性选择器</li><li>伪类</li><li>ID 选择器</li><li>内联样式</li></ol><h5 id="4、权重计算"><a href="#4、权重计算" class="headerlink" title="4、权重计算:"></a>4、权重计算:</h5><ul><li>内联样式表的权值最高 1000</li><li>ID 选择器的权值为 100</li><li>Class 类选择器的权值为 10</li><li>HTML 标签选择器的权值为 1</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-id">#redP</span> <span class="hljs-selector-tag">p</span> &#123;   <br><br><span class="hljs-comment">/* 权值 = 100+1=101 */</span>    <br><br><span class="hljs-attribute">color</span>:<span class="hljs-number">#F00</span>;  <span class="hljs-comment">/* 红色 */</span>   <br><br>&#125;    <br><br><span class="hljs-selector-id">#redP</span> <span class="hljs-selector-class">.red</span> <span class="hljs-selector-tag">em</span> &#123;    <br><br><span class="hljs-comment">/* 权值 = 100+10+1=111 */</span>    <br><br><span class="hljs-attribute">color</span>:<span class="hljs-number">#00F</span>; <span class="hljs-comment">/* 蓝色 */</span>   <br><br>&#125;   <br><br><span class="hljs-selector-id">#redP</span> <span class="hljs-selector-tag">p</span> <span class="hljs-selector-tag">span</span> <span class="hljs-selector-tag">em</span> &#123;   <br><br><span class="hljs-comment">/* 权值 = 100+1+1+1=103 */</span><br><br><span class="hljs-attribute">color</span>:<span class="hljs-number">#FF0</span>;<span class="hljs-comment">/*黄色*/</span>   <br><br>&#125;    <br></code></pre></td></tr></table></figure><h3 id="CSS-优先级法则："><a href="#CSS-优先级法则：" class="headerlink" title="CSS 优先级法则："></a>CSS 优先级法则：</h3><ul><li> A 选择器都有一个权值，权值越大越优先；</li><li> B 当权值相等时，后出现的样式表设置要优于先出现的样式表设置；</li><li> C 创作者的规则高于浏览者：即网页编写者设置的 CSS 样式的优先权高于浏览器所设置的样式；</li><li> D 继承的 CSS 样式不如后来指定的 CSS 样式；</li><li> E 在同一组属性设置中标有 “!important” 规则的优先级最大；</li></ul><h5 id="5、https-www-w3cschool-cn-css-css-outline-html"><a href="#5、https-www-w3cschool-cn-css-css-outline-html" class="headerlink" title="5、https://www.w3cschool.cn/css/css-outline.html"></a>5、<a href="https://www.w3cschool.cn/css/css-outline.html">https://www.w3cschool.cn/css/css-outline.html</a></h5>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>css</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Interview Summary</title>
    <link href="/2020/12/12/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93(%E4%BA%8C)/"/>
    <url>/2020/12/12/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93(%E4%BA%8C)/</url>
    
    <content type="html"><![CDATA[<p>前端面试总结</p><a id="more"></a><h5 id="1、如何看待前端框架选型"><a href="#1、如何看待前端框架选型" class="headerlink" title="1、如何看待前端框架选型"></a>1、如何看待前端框架选型</h5><p><a href="https://blog.csdn.net/qq_42774426/article/details/86600913">https://blog.csdn.net/qq_42774426/article/details/86600913</a></p><h5 id="2、vue如何实现双向绑定"><a href="#2、vue如何实现双向绑定" class="headerlink" title="2、vue如何实现双向绑定"></a>2、vue如何实现双向绑定</h5><p>vue.js 是采用数据劫持结合发布者-订阅者模式的方式，通过new Proxy()来劫持各个属性的setter，getter，在数据变动时发布消息给订阅者，触发相应的监听回调。</p><p>Vue 3.0与Vue 2.0的区别仅是数据劫持的方式由Object.defineProperty更改为Proxy代理，其他代码不变。</p><h5 id="3、react虚拟DOM是什么"><a href="#3、react虚拟DOM是什么" class="headerlink" title="3、react虚拟DOM是什么"></a>3、react虚拟DOM是什么</h5><p>当我们更新了<code>state</code>中的值的时候，React会去调用<code>render()</code>方法来重新渲染整个组件的UI，但是如果我们真的去操作这么大量的DOM，显然性能是堪忧的。所以React实现了一个<code>Virtual DOM</code>，组件的<code>真实DOM结构</code>和<code>Virtual DOM</code>之间有一个映射的关系，React在虚拟DOM上实现了一个<code>diff</code>算法，当<code>render()</code>去重新渲染组件的时候，<code>diff</code>会找到需要变更的DOM，然后再把修改更新到浏览器上面的真实DOM上，所以，React并不是渲染了整个DOM树，<code>Virtual DOM</code>就是JS数据结构，所以比原生的DOM快得多。</p><h5 id="4、diff算法将传统的复杂度o-n-3-变成o-n-2"><a href="#4、diff算法将传统的复杂度o-n-3-变成o-n-2" class="headerlink" title="4、diff算法将传统的复杂度o(n$^3$)变成o(n$^2$)"></a>4、diff算法将传统的复杂度o(n$^3$)变成o(n$^2$)</h5><p>策略一（tree diff）：<br>Web UI中DOM节点跨层级的移动操作特别少，可以忽略不计。</p><p>策略二（component diff）：<br>拥有相同类的两个组件 生成相似的树形结构，<br>拥有不同类的两个组件 生成不同的树形结构。</p><p>策略三（element diff）：<br>对于同一层级的一组子节点，通过唯一id区分。</p><h5 id="5、vue组件间传值的方式"><a href="#5、vue组件间传值的方式" class="headerlink" title="5、vue组件间传值的方式"></a>5、vue组件间传值的方式</h5><ul><li><p>props/$emit（父-&gt;子）</p><p>在父组件的data中定义一个数据，可以在子组件中使用props来接受</p></li><li><p>事件传递（子-&gt;父）</p><p>在子组件中通过事件，将方法绑定，然后在methods中，完成自定义事件</p><p>在父组件中，通过v-on:自定义事件=函数 并将此函数在method中实现</p></li><li><p>创建一个空的vue实例作为中央事件总线</p><p>通过事件绑定这个自定义事件，通过Event(刚才创建的空实例).emit(自定义事件，传递数据)，同理在需要传递到的组件中，使用Event.$on(自定义事件，数据=&gt; function)</p></li><li><p>vuex</p><p>如果项目大了，使用上面这个方面会显得不易于管理，可以采用vuex作为状态管理方法。vuex实现了一个单向数据流，在全局拥有一个State来存放数据。设置为严格模式时，确保state中的值只能在mutations中被修改。getter是State的计算属性。action和mutation类似，是对异步的函数写入这里，以保证mutaions来仅同步实现。module是为了放在一个state显得冗杂，可以module嵌套，每个module都有自己的属性。</p></li></ul><h5 id="6、前端网络攻击"><a href="#6、前端网络攻击" class="headerlink" title="6、前端网络攻击"></a>6、前端网络攻击</h5><ul><li><p>XSS跨站脚本攻击，开启cookie的HttpOnly</p></li><li><p>SQL注入</p></li><li><p>CSRF跨站请求伪造，利用浏览器的cookis或服务器的session策略，模拟用户向第三方网站发送恶意请求</p><ul><li><p>解决方式：1、同源检测：可以禁止外域或不受信任的域名对我们发起请求。可以通过<code>origin header</code>或者<code>referer header</code>判断请求源</p><p>​                   2、Token验证：请求提交的时候携带Token，并且每次的Token都是合法的随机数，采用post去传递token</p></li></ul></li></ul><h5 id="7、前端跨域问题如何解决"><a href="#7、前端跨域问题如何解决" class="headerlink" title="7、前端跨域问题如何解决"></a>7、前端跨域问题如何解决</h5><p>常见的跨域常见</p><table><thead><tr><th>URL</th><th>说明</th><th>是否允许通信</th></tr></thead><tbody><tr><td><a href="http://www.domain.com/a.js">http://www.domain.com/a.js</a><br/><a href="http://www.domain.com/b.js">http://www.domain.com/b.js</a> <br/><a href="http://www.domain.com/lab/c.js">http://www.domain.com/lab/c.js</a></td><td>同一域名，不同文件或路径</td><td>允许</td></tr><tr><td><a href="http://www.domain.com:8000/a.js">http://www.domain.com:8000/a.js</a><br/><a href="http://www.domain.com/b.js">http://www.domain.com/b.js</a></td><td>同一域名，不同端口</td><td>不允许</td></tr><tr><td><a href="http://www.domain.com/a.js">http://www.domain.com/a.js</a><br/><a href="https://www.domain.com/b.js">https://www.domain.com/b.js</a></td><td>同一域名，不同协议</td><td>不允许</td></tr><tr><td><a href="http://www.domain.com/a.js">http://www.domain.com/a.js</a><br/><a href="http://192.168.4.12/b.js">http://192.168.4.12/b.js</a></td><td>域名和域名对应相同ip</td><td>不允许</td></tr><tr><td><a href="http://www.domain.com/a.js">http://www.domain.com/a.js</a><br/><a href="http://x.domain.com/b.js">http://x.domain.com/b.js</a> <br/><a href="http://domain.com/c.js">http://domain.com/c.js</a></td><td>主域相同，子域不同</td><td>不允许</td></tr><tr><td><a href="http://www.domain1.com/a.js">http://www.domain1.com/a.js</a><br/><a href="http://www.domain2.com/b.js">http://www.domain2.com/b.js</a></td><td>不同域名</td><td>不允许</td></tr></tbody></table><ul><li><p><code>JSONP</code></p><p>当为了减轻web服务器的负载，我们把js、css、img等静态资源分离到另一个独立域名的服务器上，在html页面中再通过相应的标签从不同域名下加载静态资源。动态创建script，再请求一个带参数网址实现跨域通信。 </p></li><li><p><code>CORS跨域</code></p><p>后端修改请求头</p></li><li><p>document.domain + iframe跨域问题</p><blockquote><p>这两个域名必须属于同一个一级域名!而且所用的协议，端口都要一致，否则无法利用document.domain进行跨域。</p></blockquote><p>通过js强制设置document.domain为基础主域，就实现了同域</p></li><li><p>location.hash+iframe</p><p>不同域之间只能通过hash值单向通信，a借助一个辅助页c,再通过与a同域的数据传回，但是会直接暴露在url中，数据容量和类型都有限</p><p>缺陷：只能实现get一种请求不同域只能通过hash值单向通信，b与c也不同域也只能单向通信，但c与a同域，所以c可通过parent.parent访问a页面所有对象。</p></li><li><p>window.name+iframe跨域</p><p>window.name在不同页面（甚至不同域名）加载后依旧存在，并且支持2MB的name值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> proxy = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">url, callback</span>) </span>&#123;<br>    <span class="hljs-keyword">var</span> state = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">var</span> iframe = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">&#x27;iframe&#x27;</span>);<br><br>    <span class="hljs-comment">// 加载跨域页面</span><br>    iframe.src = url;<br><br>    <span class="hljs-comment">// onload事件会触发2次，第1次加载跨域页，并留存数据于window.name</span><br>    iframe.onload = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>        <span class="hljs-keyword">if</span> (state === <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-comment">// 第2次onload(同域proxy页)成功后，读取同域window.name中数据</span><br>            callback(iframe.contentWindow.name);<br>            destoryFrame();<br><br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (state === <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-comment">// 第1次onload(跨域页)成功后，切换到同域代理页面</span><br>            iframe.contentWindow.location = <span class="hljs-string">&#x27;http://www.domain1.com/proxy.html&#x27;</span>;<br>            state = <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;;<br><br>    <span class="hljs-built_in">document</span>.body.appendChild(iframe);<br><br>    <span class="hljs-comment">// 获取数据以后销毁这个iframe，释放内存；这也保证了安全（不被其他域frame js访问）</span><br>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">destoryFrame</span>(<span class="hljs-params"></span>) </span>&#123;<br>        iframe.contentWindow.document.write(<span class="hljs-string">&#x27;&#x27;</span>);<br>        iframe.contentWindow.close();<br>        <span class="hljs-built_in">document</span>.body.removeChild(iframe);<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">// 请求跨域b页面数据</span><br>proxy(<span class="hljs-string">&#x27;http://www.domain2.com/b.html&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">data</span>)</span>&#123;<br>    alert(data);<br>&#125;);<br></code></pre></td></tr></table></figure></li></ul><h5 id="8、RESTful-API"><a href="#8、RESTful-API" class="headerlink" title="8、RESTful API"></a>8、RESTful API</h5><p>REST全称是Representational State Transfer（表征性状态转移）</p><p>RESTful更多的是一种风格，只要符合标准的框架都是RESTful的</p><p>RESTful框架的主要原则</p><ul><li>对网络上所有的资源都有一个资源标志符。</li><li>对资源的操作不会改变标识符。</li><li>同一资源有多种表现形式（xml、json）</li><li>所有操作都是无状态的（Stateless）</li></ul><p>符合上述REST原则的架构方式称为RESTful</p><p>参考链接：<a href="https://blog.csdn.net/x541211190/article/details/81141459">https://blog.csdn.net/x541211190/article/details/81141459</a></p><h5 id="9、CORS跨域资源共享请求分类"><a href="#9、CORS跨域资源共享请求分类" class="headerlink" title="9、CORS跨域资源共享请求分类"></a>9、CORS跨域资源共享请求分类</h5><p><code>简单请求</code>和<code>预检请求</code></p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>javascript,css</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Interview Summary</title>
    <link href="/2020/12/07/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/"/>
    <url>/2020/12/07/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<p>前端面试总结</p><a id="more"></a><h5 id="1、盒子模型"><a href="#1、盒子模型" class="headerlink" title="1、盒子模型"></a>1、盒子模型</h5><p>所有HTML元素可以看作盒子，在CSS中，”box model”这一术语是用来设计和布局时使用。</p><p>CSS盒模型本质上是一个盒子，封装周围的HTML元素，它包括：边距，边框，填充，和实际内容。</p><p>盒模型允许我们在其它元素和周围元素边框之间的空间放置元素。</p><p>不同部分的说明：</p><ul><li><strong>Margin(外边距)</strong> - 清除边框外的区域，外边距是透明的。</li><li><strong>Border(边框)</strong> - 围绕在内边距和内容外的边框。</li><li><strong>Padding(内边距)</strong> - 清除内容周围的区域，内边距是透明的。</li><li><strong>Content(内容)</strong> - 盒子的内容，显示文本和图像。</li></ul><h5 id="2、https加密"><a href="#2、https加密" class="headerlink" title="2、https加密"></a>2、https加密</h5><p>https协议是由http和ssl协议构建的可进行加密传输和身份认证的网络协议，比http协议的安全性更高。</p><p>Https协议需要ca证书，费用较高。https则是具有安全性的ssl加密传输协议。</p><h5 id="3、css实现两栏布局、左边固定、右边自适应"><a href="#3、css实现两栏布局、左边固定、右边自适应" class="headerlink" title="3、css实现两栏布局、左边固定、右边自适应"></a>3、css实现两栏布局、左边固定、右边自适应</h5><p><a href="https://segmentfault.com/a/1190000010698609">https://segmentfault.com/a/1190000010698609</a></p><h5 id="4、vue与react的区别"><a href="#4、vue与react的区别" class="headerlink" title="4、vue与react的区别"></a>4、vue与react的区别</h5><p><a href="https://blog.csdn.net/qq_37617413/article/details/90669216">https://blog.csdn.net/qq_37617413/article/details/90669216</a></p><h5 id="5、vue的双向绑定原理"><a href="#5、vue的双向绑定原理" class="headerlink" title="5、vue的双向绑定原理"></a>5、vue的双向绑定原理</h5><p>vue的数据双向绑定主要通过Object.defineProperty()方法来进行数据劫持以及发布者-订阅模式来实现的，</p><ul><li>具体怎么实现的呢？</li></ul><p>要想实现数据的双向绑定首先就要通过数据拦截来进行监听数据的改变，这个时候就要设置一个监听器Observer来进行监听，如果属性发生改变的话就告诉订阅者Watcher看看是否需要改变，同时的话订阅者可以有好多个，我们就用一个订阅者管理器(Dep)来管理这些订阅者。紧接着我们还要有个指令解析器来对每个节点进行扫描和解析（解析节点的指令如v-on）,把他们初始化成一个订阅器Watcher,并且绑定相应的函数，Watcher会对比前后两个的数值是否发生变化，然后确定是否通知视图进行重新渲染；</p><h5 id="6、vuex的核心属性"><a href="#6、vuex的核心属性" class="headerlink" title="6、vuex的核心属性"></a>6、vuex的核心属性</h5><ul><li>state:vuex的基本数据，提供唯一 的公共数据源，所有共享的数据都要统一放在store中的state中，使用单一状态树，包含我们所需要的基本状态参数</li><li>getter：相当于State的计算属性</li><li>mutation:更新数据的方法，同步方式</li><li>action:功能和mutaion大致相同，action是通过提交mutation来更改状态。</li><li>module:整个store对象集中到一个很大的对象，将store分割到很多模块，使得每个模块拥有自己的属性</li></ul><h5 id="7、box-sizing的使用场景"><a href="#7、box-sizing的使用场景" class="headerlink" title="7、box-sizing的使用场景"></a>7、box-sizing的使用场景</h5><p>首先盒子模型：ie盒子模型和标准W3C盒子模型</p><ul><li>标准盒子模型：width=content  height=content</li><li>ie盒子模型：width=margin+border+padding+content</li></ul><p>1、考虑到盒子的大小设置会比较麻烦，有时设置的width，结果最后大小不是之前设置的大小，所以这时就要box-sizing登场了，当我们设置box-sizing:border-box以后，如果我们想要一个宽度100的盒子，直接设置width为100，就不用考虑该盒子是否为标准盒子了。这是box-sizing最实用的一个属性。等于：siting-width=border+padding+content-width;（为元素设定的宽度和高度决定了元素的边框盒。就是说，为元素指定的任何内边距和边框都将在已设定的宽度和高度内进行绘制。通过从已设定的宽度和高度分别减去边框和内边距才能得到内容的宽度和高度）</p><p>2、当box-sizing设置成content-box后，等于标准情况：siting-width=conten-width;（在宽度和高度之外绘制元素的内边距和边框。）</p><h5 id="8、弹性flex布局"><a href="#8、弹性flex布局" class="headerlink" title="8、弹性flex布局"></a>8、弹性flex布局</h5><blockquote><p>通过修改父元素div的<code>display:flex</code>，让父元素成为一个<code>flex容器</code>，从而可以自由的操作容器中子元素（项目）的排列方式。</p></blockquote><ul><li>为什么现在我们都用flex布局</li></ul><p>例如我们让多个div横向排列，传统做法是使用浮动，但浮空后因为脱离文档流的缘故，父元素会失去高度，这又涉及了清除浮动等一系列的问题。</p><p>而flex布局相对简单很多，修改父元素display:flex，你会发现div自动就排列成了一行，而且没有浮动之后的副作用，从回流角度考虑，flex的性能更优于float；随着浏览器不断兼容以及旧版本的淘汰，flex布局注定会成为更为流行的布局方案。</p><p>给予容器控制内部元素高度和宽度的能力。</p><p>在webkit内核的浏览器使用时，必须加上**-webkit-**前缀</p><ul><li>Google Chrome 谷歌浏览器</li><li>Safari浏览器</li><li>搜狗高速浏览器</li><li>遨游浏览器3</li><li>QQ浏览器</li><li>360极速浏览器</li><li>世界之窗浏览器</li><li>阿里云浏览器</li></ul><p>使用flex的容器，它内部的元素自动成为flex项目。容器拥有两根隐形的轴，水平的主轴和竖直的交叉轴，主轴与左边框的交点为main start,主轴与右边框的交点为main end,交叉轴的起点为cross start,交叉轴结束的位置成位cross end,项目的主轴宽度为main size,交叉轴方向上的宽度为cross size.同时flex item的float、clear、vertical-align属性将失效。</p><p>felx的相关的示意图见下链：</p><p><a href="https://images2015.cnblogs.com/blog/1008386/201608/1008386-20160829212313605-763604383.png">https://images2015.cnblogs.com/blog/1008386/201608/1008386-20160829212313605-763604383.png</a></p><ul><li><p>容器的属性</p><ol><li><p>flex-direction:</p><ul><li>row:主轴为水平方向，项目沿主轴从左至右排列</li><li>column:主轴为竖直方向，项目沿主轴从上至下排列</li><li>row-reverse:主轴水平，项目从右至左排列，与row反向</li><li>column-reverse:主轴竖直，项目从下至上排列，与column反向</li></ul></li><li><p>flex-wrap</p><ul><li>nowrap:自动缩小项目，不换行</li><li>wrap:换行，且第一行在上方</li><li>wrap-reverse:换行，第一行在下面</li></ul></li><li><p>flex-flow</p><p>  是flex-direction和flex-wrap的简写形式，有row wrap|column wrap-reverse等, 默认值为row nowrap</p></li><li><p>justify-content</p><p>决定item在主轴上的对齐方式，可能的值有flex-start(默认）</p><ul><li>flex-start:左对齐</li><li>flex-end:右对齐</li><li>center:居中对齐</li><li>space-between:两端对齐</li><li>space-around:沿轴线均匀分布</li></ul></li><li><p>align-items</p><p>决定item在交叉轴上的对齐方式</p><ul><li>flex-start:顶端对齐</li><li>flex-end:底部对齐</li><li>center:竖直方向上居中对齐</li><li>baseline:item第一行文字的底部对齐</li><li>stretch:当item未设置高度时，item将和容器等高对齐</li></ul></li><li><p>align-content</p><p>该属性定义了当有很多根主轴时，即item不止一行时，多行在交叉轴轴上的对齐方式。注意当有多行时，align-items属性将失效</p><ul><li>flex-start:左对齐</li><li>flex-end:右对齐</li><li>center:居中对齐</li><li>space-between:两端对齐</li><li>space-around:沿轴线均匀分布</li></ul></li></ol></li><li><p>项目属性</p><ol><li><p>order</p><p>order的值越小，项目排列越靠前</p></li><li><p>flex-grow</p><p>定义了当flex容器有多余空间时，item是否放大。默认值为0，即当有多余空间时也不放大，数值为对应的项目的放大比列。</p></li><li><p>flex-shrink</p><p>定义了当容器空间不足时，item是否缩小。默认值为1，当空间不足时，项目自动缩小。其可能的值为整数，表示不同的项目的缩小比例</p></li><li><p>flex-basis</p><p>表示项目的主轴占据的空间，默认值为auto。</p></li><li><p>flex</p><p>属性是flex-grow、flex-shrink和flex-basis三属性的简写总和</p></li><li><p>align-self</p><ul><li><p>auto: 和父元素align-self的值一致</p></li><li><p>flex-start:顶端对齐</p></li><li><p>flex-end:底部对齐</p></li><li><p>center:竖直方向上居中对齐</p></li><li><p>baseline: 项目的第一行文字的底部对齐</p></li><li><p>stretch: 当项目未设置高度时，item将和容器等高对齐</p><p>【参考链接】：<a href="https://www.cnblogs.com/nuannuan7362/p/5823381.html">https://www.cnblogs.com/nuannuan7362/p/5823381.html</a></p></li></ul></li></ol></li></ul><h5 id="9、什么是闭包"><a href="#9、什么是闭包" class="headerlink" title="9、什么是闭包"></a>9、什么是闭包</h5><p><strong>「函数」和「函数内部能访问到的变量」（也叫环境）的总和，就是一个闭包。</strong></p><p>希望能够把变量给隐藏了。</p><p>参考链接：<a href="https://zhuanlan.zhihu.com/p/22486908">https://zhuanlan.zhihu.com/p/22486908</a></p><h5 id="10、箭头函数和普通函数"><a href="#10、箭头函数和普通函数" class="headerlink" title="10、箭头函数和普通函数"></a>10、箭头函数和普通函数</h5><p>箭头函数本身没用prototype所以箭头函数本身没用this</p><p>箭头函数的this永远指向其上下文，call()、bind()、apply()改变不了其this的指向</p><p>普通函数的this指向调用它的那个对象</p><p>箭头函数相当于一个匿名函数，不能作为构造函数，不能new</p><p>箭头函数对比：<a href="https://www.cnblogs.com/shamszhang/p/10530298.html">https://www.cnblogs.com/shamszhang/p/10530298.html</a></p><h5 id="11、flex-1代表什么"><a href="#11、flex-1代表什么" class="headerlink" title="11、flex:1代表什么"></a>11、flex:1代表什么</h5><p><a href="https://zhuanlan.zhihu.com/p/136223806">https://zhuanlan.zhihu.com/p/136223806</a></p><h5 id="12、什么是BFC，如何清除浮动"><a href="#12、什么是BFC，如何清除浮动" class="headerlink" title="12、什么是BFC，如何清除浮动"></a>12、什么是BFC，如何清除浮动</h5><p>Block formatting context 块级格式上下文，它是一个独立的渲染区域。具有BDC特性的元素可以看作是隔离的独立容器，容器里的元素不会在布局上影响到外面的元素，并且BFC具有普通容器所没用的一些特性。</p><p>清除浮动：<a href="https://blog.csdn.net/h_qingyi/article/details/81269667">https://blog.csdn.net/h_qingyi/article/details/81269667</a></p><p>clear:both   overflow:hidden</p><p> 都不如双伪元素清除浮动,不仅可以清除浮动，也可以解决高度坍塌的问题。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.clearfix</span><span class="hljs-selector-pseudo">:before</span>,<br><span class="hljs-selector-class">.clearfix</span><span class="hljs-selector-pseudo">:after</span> &#123;<br>    <span class="hljs-attribute">display</span>: table;<br>    <span class="hljs-attribute">content</span>: <span class="hljs-string">&quot;&quot;</span>;    <span class="hljs-comment">/*不用有内容也可以*/</span><br>&#125;<br><br><span class="hljs-selector-class">.clearfix</span><span class="hljs-selector-pseudo">:after</span> &#123;<br>    <span class="hljs-attribute">clear</span>: both;<br>&#125;<br><br><span class="hljs-selector-class">.clearfix</span> &#123;<br>    <span class="hljs-attribute">*zoom</span>: <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>BFC: <a href="https://zhuanlan.zhihu.com/p/25321647">https://zhuanlan.zhihu.com/p/25321647</a></p><h5 id="13、控制元素显示和隐藏的两种方法"><a href="#13、控制元素显示和隐藏的两种方法" class="headerlink" title="13、控制元素显示和隐藏的两种方法"></a>13、控制元素显示和隐藏的两种方法</h5><ul><li>方法一</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&quot;EleId&quot;</span>).style.visibility=<span class="hljs-string">&quot;hidden&quot;</span>;<br><span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&quot;EleId&quot;</span>).style.visibility=<span class="hljs-string">&quot;visible&quot;</span>;<br></code></pre></td></tr></table></figure><ul><li>方法二</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&quot;EleId&quot;</span>).style.display=<span class="hljs-string">&quot;none&quot;</span>;<br><span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&quot;EleId&quot;</span>).style.display=<span class="hljs-string">&quot;inline&quot;</span>;<br></code></pre></td></tr></table></figure><h5 id="14、防抖和节流"><a href="#14、防抖和节流" class="headerlink" title="14、防抖和节流"></a>14、防抖和节流</h5><p>防抖和节流都是为了解决短时间内大量触发某函数而导致的性能问题。</p><p>手写防抖实例代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">debounce</span>(<span class="hljs-params">func, wait</span>) </span>&#123;<br>    <span class="hljs-keyword">let</span> timeout = <span class="hljs-literal">null</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>        <span class="hljs-keyword">let</span> context = <span class="hljs-built_in">this</span><br>        <span class="hljs-keyword">let</span> args = <span class="hljs-built_in">arguments</span><br>        <span class="hljs-keyword">if</span> (timeout) <span class="hljs-built_in">clearTimeout</span>(timeout)<br>        timeout = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>            func.apply(context, args) <br>        &#125;, wait)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>节流实例代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">throttle</span>(<span class="hljs-params">fn, wait</span>) </span>&#123;<br>    <span class="hljs-keyword">let</span> prev = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123; <br>        <span class="hljs-keyword">const</span> args = <span class="hljs-built_in">arguments</span>;<br>        <span class="hljs-keyword">const</span> now = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>();<br>        <span class="hljs-keyword">if</span> (now - prev &gt; wait) &#123;<br>            fn.apply(<span class="hljs-built_in">this</span>, args);<br>            prev = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>();<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><h5 id="15、promise、事件循环机制、输出什么，以及原理是什么，event-loop解析"><a href="#15、promise、事件循环机制、输出什么，以及原理是什么，event-loop解析" class="headerlink" title="15、promise、事件循环机制、输出什么，以及原理是什么，event  loop解析"></a>15、promise、事件循环机制、输出什么，以及原理是什么，event  loop解析</h5><p><a href="https://blog.csdn.net/vampire10086/article/details/107403506">https://blog.csdn.net/vampire10086/article/details/107403506</a></p><p><a href="https://www.cnblogs.com/tangjianqiang/p/13470363.html">https://www.cnblogs.com/tangjianqiang/p/13470363.html</a></p><p><a href="https://www.cnblogs.com/wxcbg/p/11040362.html">https://www.cnblogs.com/wxcbg/p/11040362.html</a></p><h5 id="16、ES6的新特性，手写Promise、Promise-all、Promise-race"><a href="#16、ES6的新特性，手写Promise、Promise-all、Promise-race" class="headerlink" title="16、ES6的新特性，手写Promise、Promise.all、Promise.race"></a>16、ES6的新特性，手写Promise、Promise.all、Promise.race</h5><p><a href="https://blog.csdn.net/weixin_44141866/article/details/106028210">https://blog.csdn.net/weixin_44141866/article/details/106028210</a></p><h5 id="17、post和get的区别"><a href="#17、post和get的区别" class="headerlink" title="17、post和get的区别"></a>17、post和get的区别</h5><ul><li>GET在浏览器回退时是无害的，而POST会再次提交请求。</li><li>GET产生的URL地址可以被Bookmark，而POST不可以。 </li><li>GET请求会被浏览器主动cache，而POST不会，除非手动设置。</li><li>GET请求只能进行url编码，而POST支持多种编码方式。</li><li>GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留。</li><li>GET请求在URL中传送的参数是有长度限制的，而POST么有。</li><li>对参数的数据类型，GET只接受ASCII字符，而POST没有限制。</li><li>GET比POST更不安全，因为参数直接暴露在URL上，所以不能用来传递敏感信息。</li></ul><p>参考链接：<a href="https://www.cnblogs.com/logsharing/p/8448446.html">https://www.cnblogs.com/logsharing/p/8448446.html</a></p><h5 id="18、call-、apply-、bind-方法的区别"><a href="#18、call-、apply-、bind-方法的区别" class="headerlink" title="18、call()、apply()、bind()方法的区别"></a>18、call()、apply()、bind()方法的区别</h5><p>call和apply都是为了改变某个函数运行时的上下文，改变函数体内部this指针</p><p>call把参数按顺序传递进去，apply是把参数放在数组里。</p><p>bind 是返回对应函数,便于稍后调用;apply 、call 则是立即调用 。</p><p><a href="https://segmentfault.com/a/1190000018270750">https://segmentfault.com/a/1190000018270750</a></p><h5 id="19、什么是事件委托？"><a href="#19、什么是事件委托？" class="headerlink" title="19、什么是事件委托？"></a>19、什么是事件委托？</h5><p>事件代理（Event Delegation），又称之为事件委托。是 JavaScript 中常用绑定事件的常用技巧。顾名思义，“事件代理”即是把原本需要绑定的事件委托给父元素，让父元素担当事件监听的职务。</p><p>为什么要这么做？众所周知，DOM操作是十分消耗性能的，所以重复的事件绑定简直是性能杀手。而事件代理的核心思想，就是通过尽量少的绑定，去监听尽量多的事件。</p><h5 id="20、defer和async的区别"><a href="#20、defer和async的区别" class="headerlink" title="20、defer和async的区别"></a>20、defer和async的区别</h5><p>当浏览器碰到script脚本，没用deffer和async，浏览器会立刻加载并执行指定的脚本</p><p>有async加载和渲染后续文档元素的过程将和script.js的加载与执行并行进行（异步）</p><p>有defer，加载后续文档元素的过程将和script.js的加载并行进行异步</p><p>示例图链接：<a href="https://segmentfault.com/img/bVWhRl?w=801&amp;h=814/view">https://segmentfault.com/img/bVWhRl?w=801&amp;h=814/view</a></p><h5 id="21、keep-alive"><a href="#21、keep-alive" class="headerlink" title="21、keep-alive"></a>21、keep-alive</h5><p><a href="https://www.cnblogs.com/sysuhanyf/p/7454530.html">https://www.cnblogs.com/sysuhanyf/p/7454530.html</a></p><h5 id="22、http状态码"><a href="#22、http状态码" class="headerlink" title="22、http状态码"></a>22、http状态码</h5><table><thead><tr><th align="left">分类</th><th align="left">分类描述</th></tr></thead><tbody><tr><td align="left">1**</td><td align="left">信息，服务器收到请求，需要请求者继续执行操作</td></tr><tr><td align="left">2**</td><td align="left">成功，操作被成功接收并处理</td></tr><tr><td align="left">3**</td><td align="left">重定向，需要进一步的操作以完成请求</td></tr><tr><td align="left">4**</td><td align="left">客户端错误，请求包含语法错误或无法完成请求</td></tr><tr><td align="left">5**</td><td align="left">服务器错误，服务器在处理请求的过程中发生了错误</td></tr></tbody></table><p>​                                                        Http状态码分类</p><table><thead><tr><th align="left">状态码</th><th align="left">状态码英文名称</th><th align="left">中文描述</th></tr></thead><tbody><tr><td align="left">100</td><td align="left">Continue</td><td align="left">继续。<a href="http://www.dreamdu.com/webbuild/client_vs_server/">客户端</a>应继续其请求</td></tr><tr><td align="left">101</td><td align="left">Switching Protocols</td><td align="left">切换协议。服务器根据客户端的请求切换协议。只能切换到更高级的协议，例如，切换到HTTP的新版本协议</td></tr><tr><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">200</td><td align="left">OK</td><td align="left">请求成功。一般用于GET与POST请求</td></tr><tr><td align="left">201</td><td align="left">Created</td><td align="left">已创建。成功请求并创建了新的资源</td></tr><tr><td align="left">202</td><td align="left">Accepted</td><td align="left">已接受。已经接受请求，但未处理完成</td></tr><tr><td align="left">203</td><td align="left">Non-Authoritative Information</td><td align="left">非授权信息。请求成功。但返回的meta信息不在原始的服务器，而是一个副本</td></tr><tr><td align="left">204</td><td align="left">No Content</td><td align="left">无内容。服务器成功处理，但未返回内容。在未更新网页的情况下，可确保浏览器继续显示当前文档</td></tr><tr><td align="left">205</td><td align="left">Reset Content</td><td align="left">重置内容。服务器处理成功，用户终端（例如：浏览器）应重置文档视图。可通过此返回码清除浏览器的表单域</td></tr><tr><td align="left">206</td><td align="left">Partial Content</td><td align="left">部分内容。服务器成功处理了部分GET请求</td></tr><tr><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">300</td><td align="left">Multiple Choices</td><td align="left">多种选择。请求的资源可包括多个位置，相应可返回一个资源特征与地址的列表用于用户终端（例如：浏览器）选择</td></tr><tr><td align="left">301</td><td align="left">Moved Permanently</td><td align="left">永久移动。请求的资源已被永久的移动到新URI，返回信息会包括新的URI，浏览器会自动定向到新URI。今后任何新的请求都应使用新的URI代替</td></tr><tr><td align="left">302</td><td align="left">Found</td><td align="left">临时移动。与301类似。但资源只是临时被移动。客户端应继续使用原有URI</td></tr><tr><td align="left">303</td><td align="left">See Other</td><td align="left">查看其它地址。与301类似。使用GET和POST请求查看</td></tr><tr><td align="left">==<strong>304</strong>==</td><td align="left">Not Modified</td><td align="left">未修改。所请求的资源未修改，服务器返回此状态码时，不会返回任何资源。客户端通常会缓存访问过的资源，通过提供一个头信息指出客户端希望只返回在指定日期之后修改的资源</td></tr><tr><td align="left">305</td><td align="left">Use Proxy</td><td align="left">使用代理。所请求的资源必须通过代理访问</td></tr><tr><td align="left">306</td><td align="left">Unused</td><td align="left">已经被废弃的HTTP状态码</td></tr><tr><td align="left">307</td><td align="left">Temporary Redirect</td><td align="left">临时重定向。与302类似。使用GET请求重定向</td></tr><tr><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">400</td><td align="left">Bad Request</td><td align="left">客户端请求的语法错误，服务器无法理解</td></tr><tr><td align="left">401</td><td align="left">Unauthorized</td><td align="left">请求要求用户的身份认证</td></tr><tr><td align="left">402</td><td align="left">Payment Required</td><td align="left">保留，将来使用</td></tr><tr><td align="left">403</td><td align="left">Forbidden</td><td align="left">服务器理解请求客户端的请求，但是拒绝执行此请求</td></tr><tr><td align="left">404</td><td align="left">Not Found</td><td align="left">服务器无法根据客户端的请求找到资源（网页）。通过此代码，网站设计人员可设置”您所请求的资源无法找到”的个性页面</td></tr><tr><td align="left">405</td><td align="left">Method Not Allowed</td><td align="left">客户端请求中的方法被禁止</td></tr><tr><td align="left">406</td><td align="left">Not Acceptable</td><td align="left">服务器无法根据客户端请求的内容特性完成请求</td></tr><tr><td align="left">407</td><td align="left">Proxy Authentication Required</td><td align="left">请求要求代理的身份认证，与401类似，但请求者应当使用代理进行授权</td></tr><tr><td align="left">408</td><td align="left">Request Time-out</td><td align="left">服务器等待客户端发送的请求时间过长，超时</td></tr><tr><td align="left">409</td><td align="left">Conflict</td><td align="left">服务器完成客户端的 PUT 请求时可能返回此代码，服务器处理请求时发生了冲突</td></tr><tr><td align="left">410</td><td align="left">Gone</td><td align="left">客户端请求的资源已经不存在。410不同于404，如果资源以前有现在被永久删除了可使用410代码，网站设计人员可通过301代码指定资源的新位置</td></tr><tr><td align="left">411</td><td align="left">Length Required</td><td align="left">服务器无法处理客户端发送的不带Content-Length的请求信息</td></tr><tr><td align="left">412</td><td align="left">Precondition Failed</td><td align="left">客户端请求信息的先决条件错误</td></tr><tr><td align="left">413</td><td align="left">Request Entity Too Large</td><td align="left">由于请求的实体过大，服务器无法处理，因此拒绝请求。为防止客户端的连续请求，服务器可能会关闭连接。如果只是服务器暂时无法处理，则会包含一个Retry-After的响应信息</td></tr><tr><td align="left">414</td><td align="left">Request-URI Too Large</td><td align="left">请求的URI过长（URI通常为网址），服务器无法处理</td></tr><tr><td align="left">415</td><td align="left">Unsupported Media Type</td><td align="left">服务器无法处理请求附带的媒体格式</td></tr><tr><td align="left">416</td><td align="left">Requested range not satisfiable</td><td align="left">客户端请求的范围无效</td></tr><tr><td align="left">417</td><td align="left">Expectation Failed</td><td align="left">服务器无法满足Expect的请求头信息</td></tr><tr><td align="left"></td><td align="left"></td><td align="left"></td></tr><tr><td align="left">500</td><td align="left">Internal Server Error</td><td align="left">服务器内部错误，无法完成请求</td></tr><tr><td align="left">501</td><td align="left">Not Implemented</td><td align="left">服务器不支持请求的功能，无法完成请求</td></tr><tr><td align="left">502</td><td align="left">Bad Gateway</td><td align="left">作为网关或者代理工作的服务器尝试执行请求时，从远程服务器接收到了一个无效的响应</td></tr><tr><td align="left">503</td><td align="left">Service Unavailable</td><td align="left">由于超载或系统维护，服务器暂时的无法处理客户端的请求。延时的长度可包含在服务器的Retry-After头信息中</td></tr><tr><td align="left">504</td><td align="left">Gateway Time-out</td><td align="left">充当网关或代理的服务器，未及时从远端服务器获取请求</td></tr><tr><td align="left">505</td><td align="left">HTTP Version not supported</td><td align="left">服务器不支持请求的HTTP协议的版本，无法完成处理</td></tr></tbody></table><h5 id="23、Promise的原理"><a href="#23、Promise的原理" class="headerlink" title="23、Promise的原理"></a>23、Promise的原理</h5><p><code>Promise</code>的规范很多,ES6采用的<code>Promise/A+</code>规范</p><p>Promise的状态包括：pedding、fulfilled、rejected三种状态，并且只能由pedding转变为fulfillde或者rejected,而且仅能改变一次。</p><p>当执行完resolve()的时候，状态会随之改变为reject。</p><h5 id="24、vue是什么时候从后台获取数据的"><a href="#24、vue是什么时候从后台获取数据的" class="headerlink" title="24、vue是什么时候从后台获取数据的"></a>24、vue是什么时候从后台获取数据的</h5><p>beforeCreate 和 created 都是早期钩子，是我们获取数据的较好时机，如果获取的数据与绑定事件有关，可以放到 created 里面，无关的话，都可以，在服务器端的应用场景中， beforeCreate 可能会用到的多一些。</p><p>beforeMount 和 mounted 多用于页面组件上有新的用户交互，触发新的请求时候使用，比如在 mounted 里手动去触发滚动条的位置，而 beforeMount 里面，可以做比如通过域名识别来获取微信认证信息的操作。</p><p>应该beforecreate和created</p>]]></content>
    
    
    <categories>
      
      <category>学习笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>javascript,css</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
