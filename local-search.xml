<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Interview Summary</title>
    <link href="/2020/12/07/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/"/>
    <url>/2020/12/07/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<p>前端面试总结</p><a id="more"></a><h5 id="1、盒子模型"><a href="#1、盒子模型" class="headerlink" title="1、盒子模型"></a>1、盒子模型</h5><p>所有HTML元素可以看作盒子，在CSS中，”box model”这一术语是用来设计和布局时使用。</p><p>CSS盒模型本质上是一个盒子，封装周围的HTML元素，它包括：边距，边框，填充，和实际内容。</p><p>盒模型允许我们在其它元素和周围元素边框之间的空间放置元素。</p><p>不同部分的说明：</p><ul><li><strong>Margin(外边距)</strong> - 清除边框外的区域，外边距是透明的。</li><li><strong>Border(边框)</strong> - 围绕在内边距和内容外的边框。</li><li><strong>Padding(内边距)</strong> - 清除内容周围的区域，内边距是透明的。</li><li><strong>Content(内容)</strong> - 盒子的内容，显示文本和图像。</li></ul><h5 id="2、https加密"><a href="#2、https加密" class="headerlink" title="2、https加密"></a>2、https加密</h5><p>https协议是由http和ssl协议构建的可进行加密传输和身份认证的网络协议，比http协议的安全性更高。</p><p>Https协议需要ca证书，费用较高。https则是具有安全性的ssl加密传输协议。</p><h5 id="3、css实现两栏布局、左边固定、右边自适应"><a href="#3、css实现两栏布局、左边固定、右边自适应" class="headerlink" title="3、css实现两栏布局、左边固定、右边自适应"></a>3、css实现两栏布局、左边固定、右边自适应</h5><p><a href="https://segmentfault.com/a/1190000010698609">https://segmentfault.com/a/1190000010698609</a></p><h5 id="4、vue与react的区别"><a href="#4、vue与react的区别" class="headerlink" title="4、vue与react的区别"></a>4、vue与react的区别</h5><p><a href="https://blog.csdn.net/qq_37617413/article/details/90669216">https://blog.csdn.net/qq_37617413/article/details/90669216</a></p><h5 id="5、vue的双向绑定原理"><a href="#5、vue的双向绑定原理" class="headerlink" title="5、vue的双向绑定原理"></a>5、vue的双向绑定原理</h5><p>vue的数据双向绑定主要通过Object.defineProperty()方法来进行数据劫持以及发布者-订阅模式来实现的，</p><ul><li>具体怎么实现的呢？</li></ul><p>要想实现数据的双向绑定首先就要通过数据拦截来进行监听数据的改变，这个时候就要设置一个监听器Observer来进行监听，如果属性发生改变的话就告诉订阅者Watcher看看是否需要改变，同时的话订阅者可以有好多个，我们就用一个订阅者管理器(Dep)来管理这些订阅者。紧接着我们还要有个指令解析器来对每个节点进行扫描和解析（解析节点的指令如v-on）,把他们初始化成一个订阅器Watcher,并且绑定相应的函数，Watcher会对比前后两个的数值是否发生变化，然后确定是否通知视图进行重新渲染；</p><h5 id="6、vuex的核心属性"><a href="#6、vuex的核心属性" class="headerlink" title="6、vuex的核心属性"></a>6、vuex的核心属性</h5><ul><li>state:vuex的基本数据，提供唯一 的公共数据源，所有共享的数据都要统一放在store中的state中，使用单一状态树，包含我们所需要的基本状态参数</li><li>getter：相当于State的计算属性</li><li>mutation:更新数据的方法，同步方式</li><li>action:功能和mutaion大致相同，action是通过提交mutation来更改状态。</li><li>module:整个store对象集中到一个很大的对象，将store分割到很多模块，使得每个模块拥有自己的属性</li></ul><h5 id="7、box-sizing的使用场景"><a href="#7、box-sizing的使用场景" class="headerlink" title="7、box-sizing的使用场景"></a>7、box-sizing的使用场景</h5><p>首先盒子模型：ie盒子模型和标准W3C盒子模型</p><ul><li>标准盒子模型：width=content  height=content</li><li>ie盒子模型：width=margin+border+padding+content</li></ul><p>1、考虑到盒子的大小设置会比较麻烦，有时设置的width，结果最后大小不是之前设置的大小，所以这时就要box-sizing登场了，当我们设置box-sizing:border-box以后，如果我们想要一个宽度100的盒子，直接设置width为100，就不用考虑该盒子是否为标准盒子了。这是box-sizing最实用的一个属性。等于：siting-width=border+padding+content-width;（为元素设定的宽度和高度决定了元素的边框盒。就是说，为元素指定的任何内边距和边框都将在已设定的宽度和高度内进行绘制。通过从已设定的宽度和高度分别减去边框和内边距才能得到内容的宽度和高度）</p><p>2、当box-sizing设置成content-box后，等于标准情况：siting-width=conten-width;（在宽度和高度之外绘制元素的内边距和边框。）</p><h5 id="8、弹性flex布局"><a href="#8、弹性flex布局" class="headerlink" title="8、弹性flex布局"></a>8、弹性flex布局</h5>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
